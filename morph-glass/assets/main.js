!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))n(e);new MutationObserver((e=>{for(const t of e)if("childList"===t.type)for(const e of t.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&n(e)})).observe(document,{childList:!0,subtree:!0})}function n(e){if(e.ep)return;e.ep=!0;const n=function(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?n.credentials="include":"anonymous"===e.crossOrigin?n.credentials="omit":n.credentials="same-origin",n}(e);fetch(e.href,n)}}();const e=2,n=Math.PI/180,t={Points:0,Lines:1,LineLoop:2,LineStrip:3,Triangles:4,TriangleStrip:5,TriangleFan:6},r={Lit:1,Unlit:2,Skybox:3},a={Never:0,Less:1,Equal:2,Lequal:3,Greater:4,NotEqual:5,Gequal:6,Always:7},o={Opaque:0,Transparent:1,Additive:2},i={Opaque:"o",AlphaTest:"a",Skybox:"s",Transparent:"t"},l={Depth:0},s={Null:0,Mesh:1,Light:2,Skybox:3,Camera:4,PostProcessVolume:6},u={Default:0,Skinned:1,ObjectSpaceRaymarch:2,ScreenSpaceRaymarch:3,Text:4},c={Misc:0,GBuffer:1,ObjectSpaceRaymarch:2,ScreenSpaceRaymarch:3},m={Front:0,Back:1,Double:2},f={RGBA:0,Depth:1,RGBA16F:2,RGBA32F:3,R11F_G11F_B10F:4,R16F:5},p={Repeat:0,ClampToEdge:1,MirroredRepeat:2},d={Nearest:0,Linear:1,NearestMipmapNearest:2,NearestMipmapLinear:3,LinearMipmapNearest:4,LinearMipmapLinear:5},g={Medium:0,High:1},h={Default:0,GBuffer:1,DoubleBuffer:2},v={RGBA:0,Depth:1,Empty:2,RGBA16F:3,R11F_G11F_B10F:4,R16F:5},x={StaticDraw:0,DynamicDraw:1,DynamicCopy:2},T={Position:"aPosition",Color:"aColor",Uv:"aUv",Normal:"aNormal",Tangent:"aTangent",Binormal:"aBinormal",BoneIndices:"aBoneIndices",BoneWeights:"aBoneWeighs",InstancePosition:"aInstancePosition",InstanceScale:"aInstanceScale",InstanceRotation:"aInstanceRotation",InstanceAnimationOffset:"aInstanceAnimationOffset",InstanceVertexColor:"aInstanceVertexColor",InstanceEmissiveColor:"aInstanceEmissiveColor",InstanceVelocity:"aInstanceVelocity",InstanceLookDirection:"aLookDirection",InstanceState:"aInstanceState"},y={Matrix4:0,Matrix4Array:1,Texture:2,CubeMap:3,Vector2:4,Vector2Array:5,Vector3:6,Vector3Array:7,Vector4:8,Vector4Array:9,Struct:10,StructArray:11,Float:12,FloatArray:13,Int:14,Color:15,ColorArray:16,TextureArray:17,Bool:18},S={WorldMatrix:"uWorldMatrix",ViewMatrix:"uViewMatrix",ProjectionMatrix:"uProjectionMatrix",ViewProjectionMatrix:"uViewProjectionMatrix",NormalMatrix:"uNormalMatrix",InverseWorldMatrix:"uInverseWorldMatrix",InverseViewMatrix:"uInverseViewMatrix",InverseViewProjectionMatrix:"uInverseViewProjectionMatrix",InverseProjectionMatrix:"uInverseProjectionMatrix",TransposeInverseViewMatrix:"uTransposeInverseViewMatrix",ViewDirectionProjectionInverse:"uViewDirectionProjectionInverse",ViewPosition:"uViewPosition",ViewDirection:"uViewDirection",CameraAspect:"uAspect",CameraFov:"uFov",GBufferATexture:"uGBufferATexture",GBufferBTexture:"uGBufferBTexture",GBufferCTexture:"uGBufferCTexture",GBufferDTexture:"uGBufferDTexture",ShadingModelId:"uShadingModelId",DepthTexture:"uDepthTexture",BaseMap:"uBaseMap",BaseColor:"uBaseColor",BaseMapTiling:"uBaseMapTiling",Metallic:"uMetallic",MetallicMap:"uMetallicMap",MetallicMapTiling:"uMetallicMapTiling",Roughness:"uRoughness",RoughnessMap:"uRoughnessMap",RoughnessMapTiling:"uRoughnessMapTiling",EmissiveColor:"uEmissiveColor",EmissiveMap:"uEmissiveMap",EmissiveMapTiling:"uEmissiveMapTiling",NormalMap:"uNormalMap",NormalMapTiling:"uNormalMapTiling",JointMatrices:"uJointMatrices",JointTexture:"uJointTexture",BoneCount:"uBoneCount",JointTextureColNum:"uJointTextureColNum",TotalFrameCount:"uTotalFrameCount",Time:"uTime",DeltaTime:"uDeltaTime",TimelineTime:"uTimelineTime",TimelineDeltaTime:"uTimelineDeltaTime",Viewport:"uViewport",TargetWidth:"uTargetWidth",TargetHeight:"uTargetHeight",Aspect:"uAspect",TexelSize:"uTexelSize",CameraNear:"uNearClip",CameraFar:"uFarClip",CubeTexture:"uCubeTexture",DirectionalLight:"uDirectionalLight",SpotLight:"uSpotLight",PointLight:"uPointLight",LightDirection:"direction",LightIntensity:"intensity",LightColor:"color",ShadowMap:"shadowMap",ShadowMapProjectionMatrix:"shadowMapProjectionMatrix",ShadowBias:"shadowBias",DirectionalLightShadowMap:"uDirectionalLightShadowMap",SpotLightShadowMap:"uSpotLightShadowMap",LightPosition:"position",LightDistance:"distance",LightAttenuation:"attenuation",LightConeCos:"coneCos",LightPenumbraCos:"penumbraCos",SpotLightColor:"uSpotLightColor",SpotLightIntensity:"uSpotLightIntensity",SceneTexture:"uSceneTexture",SrcTexture:"uSrcTexture",BlendRate:"uBlendRate",FontMap:"uFontMap",FontTiling:"uFontTiling",Skybox:"uSkybox",RotationOffset:"uRotationOffset",ObjectSpaceRaymarchBoundsScale:"uBoundsScale"},b={Common:"ubCommon",Transformations:"ubTransformations",Camera:"ubCamera",DirectionalLight:"ubDirectionalLight",SpotLight:"ubSpotLight",PointLight:"ubPointLight",Timeline:"ubTimeline"},C={BEGIN_MAIN:"BEGIN_MAIN",END_MAIN:"END_MAIN",APPEND_ATTRIBUTES:"APPEND_ATTRIBUTES",APPEND_UNIFORMS:"APPEND_UNIFORMS",RAYMARCH_SCENE:"RAYMARCH_SCENE"},M={LOCAL_POSITION_POST_PROCESS:"LOCAL_POSITION_POST_PROCESS",INSTANCE_TRANSFORM_PRE_PROCESS:"INSTANCE_TRANSFORM_PRE_PROCESS",WORLD_POSITION_POST_PROCESS:"WORLD_POSITION_POST_PROCESS",VIEW_POSITION_POST_PROCESS:"VIEW_POSITION_POST_PROCESS",OUT_CLIP_POSITION_PRE_PROCESS:"OUT_CLIP_POSITION_PRE_PROCESS",...C},P={BLOCK_BEFORE_RAYMARCH_CONTENT:"BLOCK_BEFORE_RAYMARCH_CONTENT",BEFORE_OUT:"BEFORE_OUT",AFTER_OUT:"AFTER_OUT",...C},w={DEFINES:"DEFINES",ATTRIBUTES:"ATTRIBUTES",...C},R="EXT_color_buffer_float",D=3553,F=34067,L=33984,B=36160,E=256,I=16384,A=0,N=1,k=2,O=3,_=4,V=2884,U=1029,z=2305,j=1028,G=512,W=513,H=514,$=515,X=516,q=517,J=518,Y=519,K=2929,Z=3042,Q=770,ee=771,ne=1,te=5123,re=35044,ae=34962,oe=5126,ie=6408,le=34836,se=6403,ue=33325,ce=35898,me=6407,fe=34842,pe=6402,de=36012,ge=33189,he=5121,ve=37440,xe=36096,Te=36161,ye=36008,Se=36009,be=34963,Ce=35345,Me=10241,Pe=10240,we={NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_NEAREST:9985,LINEAR_MIPMAP_LINEAR:9987},Re=10242,De=10243,Fe={REPEAT:10497,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648},Le={COLOR_ATTACHMENT0:36064,COLOR_ATTACHMENT1:36065,COLOR_ATTACHMENT2:36066,COLOR_ATTACHMENT3:36067,COLOR_ATTACHMENT4:36068,COLOR_ATTACHMENT5:36069,COLOR_ATTACHMENT6:36070,COLOR_ATTACHMENT7:36071},Be=(e,n)=>{e.renderCount=0,e.startCountTime=n};function Ee(e){return{name:e.name,data:e.data,location:e.location||0,size:e.size,offset:e.offset||0,usageType:e.usageType||x.StaticDraw,divisor:e.divisor||0}}function Ie(e,n){return{gpu:e,glObject:n}}function Ae(e){switch(e){case we.NEAREST:return d.Nearest;case we.LINEAR:return d.Linear;case we.NEAREST_MIPMAP_NEAREST:return d.NearestMipmapNearest;case we.LINEAR_MIPMAP_NEAREST:return d.LinearMipmapNearest;case we.NEAREST_MIPMAP_LINEAR:return d.NearestMipmapLinear;case we.LINEAR_MIPMAP_LINEAR:return d.LinearMipmapLinear}}function Ne(e){switch(e){case WebGLRenderingContext.CLAMP_TO_EDGE:return p.ClampToEdge;case WebGLRenderingContext.REPEAT:return p.Repeat;case WebGLRenderingContext.MIRRORED_REPEAT:return p.MirroredRepeat}}function ke({gpu:e,name:n,img:t=null,arraybuffer:r,type:a=f.RGBA,width:o,height:i,mipmap:l=!1,minFilter:s=d.Nearest,magFilter:u=d.Nearest,wrapS:c=p.Repeat,wrapT:m=p.Repeat,flipY:h,depthPrecision:v,dxt1:x=!1}){const T=e.gl,y=T.createTexture();if(null!==(t=t||null)&&(void 0===o&&(o=t.width),void 0===i&&(i=t.height)),h=!(!t||void 0!==h)||!!h,v=a===f.Depth&&void 0!==v?v:void 0,T.bindTexture(D,y),x){const e=T.getExtension("WEBGL_compressed_texture_s3tc"),n=e=>(e.charCodeAt(0)<<0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24),t=new Int32Array(r,0,32);t[0],n("DDS ");const a=n("DXT1"),o=n("DXT3"),i=n("DXT5");let l=-1,s=-1;switch(t[21]){case a:l=8,s=e?.COMPRESSED_RGBA_S3TC_DXT1_EXT;break;case o:l=16,s=e?.COMPRESSED_RGBA_S3TC_DXT3_EXT;break;case i:l=16,s=e?.COMPRESSED_RGBA_S3TC_DXT5_EXT}const u=t[4],c=t[3],m=t[1]+4,f=Math.max(4,u)/4*Math.max(4,c)/4*l,p=new Uint8Array(r,m,f);T.compressedTexImage2D(D,0,s,u,c,0,p)}switch(l&&T.generateMipmap(D),a){case f.RGBA:case f.RGBA16F:case f.RGBA32F:case f.R11F_G11F_B10F:case f.R16F:switch(s){case d.Nearest:T.texParameteri(D,Me,we.NEAREST);break;case d.Linear:default:T.texParameteri(D,Me,we.LINEAR)}switch(u){case d.Nearest:T.texParameteri(D,Pe,we.NEAREST);break;case d.Linear:default:T.texParameteri(D,Pe,we.LINEAR)}break;case f.Depth:T.texParameteri(D,Me,we.NEAREST),T.texParameteri(D,Pe,we.NEAREST)}switch(c){case p.ClampToEdge:T.texParameteri(D,Re,Fe.CLAMP_TO_EDGE);break;case p.Repeat:default:T.texParameteri(D,Re,Fe.REPEAT)}switch(m){case p.ClampToEdge:T.texParameteri(D,De,Fe.CLAMP_TO_EDGE);break;case p.Repeat:default:T.texParameteri(D,De,Fe.REPEAT)}switch(h?T.pixelStorei(ve,!0):T.pixelStorei(ve,!1),a){case f.RGBA:o&&i?t?T.texImage2D(D,0,ie,o,i,0,ie,he,t):T.texImage2D(D,0,ie,o,i,0,ie,he,null):t&&T.texImage2D(D,0,ie,ie,he,t);break;case f.Depth:o&&i?t?T.texImage2D(D,0,v===g.High?de:ge,o,i,0,pe,v===g.High?oe:te,t):T.texImage2D(D,0,v===g.High?de:ge,o,i,0,pe,v===g.High?oe:te,null):t&&T.texImage2D(D,0,v===g.High?de:ge,pe,v===g.High?oe:te,t);break;case f.RGBA16F:o&&i?t?T.texImage2D(D,0,fe,o,i,0,ie,oe,t):T.texImage2D(D,0,fe,o,i,0,ie,oe,null):t&&T.texImage2D(D,0,fe,ie,oe,t);break;case f.RGBA32F:o&&i?t?T.texImage2D(D,0,le,o,i,0,ie,oe,t):T.texImage2D(D,0,le,o,i,0,ie,oe,null):t&&T.texImage2D(D,0,le,ie,oe,t);break;case f.R11F_G11F_B10F:o&&i?t?T.texImage2D(D,0,ce,o,i,0,me,oe,t):T.texImage2D(D,0,ce,o,i,0,me,oe,null):t&&T.texImage2D(D,0,ce,me,oe,t);break;case f.R16F:o&&i?t?T.texImage2D(D,0,ue,o,i,0,se,oe,t):T.texImage2D(D,0,ue,o,i,0,se,oe,null):t&&T.texImage2D(T.TEXTURE_2D,0,T.R16F,T.RED,T.FLOAT,t)}return T.bindTexture(D,null),{...Ie(e,y),name:n??"",img:t,type:a,minFilter:s,magFilter:u,mipmap:l,wrapS:c,wrapT:m,flipY:h,width:o,height:i,depthPrecision:v}}function Oe(e,n,t){e.width=Math.floor(n),e.height=Math.floor(t);const r=e.gpu.gl;switch(r.bindTexture(D,e.glObject),e.type){case f.RGBA:e.img?r.texImage2D(D,0,ie,n,t,0,ie,he,e.img):r.texImage2D(D,0,ie,n,t,0,ie,he,null);break;case f.Depth:e.img?r.texImage2D(D,0,e.depthPrecision===g.High?de:ge,n,t,0,pe,e.depthPrecision===g.High?oe:te,e.img):r.texImage2D(D,0,e.depthPrecision===g.High?de:ge,n,t,0,pe,e.depthPrecision===g.High?oe:te,null);break;case f.RGBA16F:e.img?r.texImage2D(D,0,fe,n,t,0,ie,oe,e.img):r.texImage2D(D,0,fe,n,t,0,ie,oe,null);break;case f.RGBA32F:e.img?r.texImage2D(D,0,le,n,t,0,ie,oe,e.img):r.texImage2D(D,0,le,n,t,0,ie,oe,null);break;case f.R11F_G11F_B10F:e.img?r.texImage2D(D,0,ce,n,t,0,me,oe,e.img):r.texImage2D(D,0,ce,n,t,0,me,oe,null);break;case f.R16F:e.img?r.texImage2D(D,0,ue,n,t,0,se,oe,e.img):r.texImage2D(D,0,ue,n,t,0,se,oe,null)}r.bindTexture(D,null)}function _e(e,{width:n,height:t,data:r}){e.width=n,e.height=t;const a=e.gpu.gl;a.bindTexture(D,e.glObject),e.type===f.RGBA32F&&a.texImage2D(D,0,le,n,t,0,ie,oe,r),a.bindTexture(D,null)}function Ve({gpu:e}){const{gl:n}=e;return{...Ie(e,n.createFramebuffer()),drawBufferList:[]}}function Ue(e,n){e.drawBufferList.push(n)}function ze(e){!function(e,n){e.bindFramebuffer(B,n)}(e.gpu.gl,e.glObject)}function je(e){!function(e){e.bindFramebuffer(B,null)}(e.gpu.gl)}function Ge(e,n,t,r,a,o,i,l=-1,s=-1){return function(e,n,t,r,a,o,i,l,s){const u=e.gl,c=Math.log2(Math.max(n,t)),m=u.createTexture();return u.bindTexture(F,m),u.pixelStorei(ve,!1),u.texImage2D(34069,0,ie,ie,he,r),u.texImage2D(34070,0,ie,ie,he,a),u.texImage2D(34071,0,ie,ie,he,o),u.texImage2D(34072,0,ie,ie,he,i),u.texImage2D(34073,0,ie,ie,he,l),u.texImage2D(34074,0,ie,ie,he,s),u.texParameteri(F,Me,we.LINEAR_MIPMAP_LINEAR),u.texParameteri(F,Pe,we.LINEAR),u.texParameteri(F,Re,Fe.CLAMP_TO_EDGE),u.texParameteri(F,De,Fe.CLAMP_TO_EDGE),u.generateMipmap(F),u.bindTexture(F,null),{...Ie(e,m),width:n,height:t,maxLodLevel:c}}(e,l>-1?l:n.width,s>-1?s:n.height,n,t,r,a,o,i)}function We(e,n){const t=[];switch(e){case y.Float:case y.Int:t.push(n),t.push(0),t.push(0),t.push(0);break;case y.Bool:t.push(n?1:0),t.push(0),t.push(0),t.push(0);break;case y.Vector2:case y.Vector3:t.push(...n.e),t.push(0);break;case y.Vector4:case y.Matrix4:case y.Color:t.push(...n.e)}return t}function He(e,n){e.bindBuffer(Ce,n)}function $e(e){e.bindBuffer(Ce,null)}const Xe=(e,n,t,r=!1)=>{const a=e.variableInfo.find((e=>e.name===n));a&&(function(e){He(e.gpu.gl,e.glObject)}(e),e.gpu.gl.bufferSubData(Ce,a.offset,t,0),function(e){$e(e.gpu.gl)}(e))},qe=(e,n,t,r)=>{switch(t){case y.Struct:r.forEach((t=>{const r=`${n}.${t.name}`,a=We(t.type,t.value);Xe(e,r,new Float32Array(a))}));break;case y.StructArray:r.forEach(((t,r)=>{t.forEach((t=>{const a=`${n}[${r}].${t.name}`,o=We(t.type,t.value);Xe(e,a,new Float32Array(o))}))}));break;default:if(Array.isArray(r)){const t=[];r.forEach((e=>{"number"==typeof e?(t.push(e),t.push(0),t.push(0),t.push(0)):"boolean"==typeof e?(t.push(e?1:0),t.push(0),t.push(0),t.push(0)):t.push(...e.e)})),Xe(e,n,new Float32Array(t))}else Xe(e,n,"number"==typeof r?new Float32Array([r]):r.e)}},Je=(e="black")=>{const n=document.createElement("canvas"),t=n.getContext("2d");return n.width=1,n.height=1,t.fillStyle=e,t.fillRect(0,0,1,1),n},Ye=e=>{switch(e){case x.StaticDraw:return re;case x.DynamicDraw:return 35048;case x.DynamicCopy:return 35050;default:return-1}};function Ke(e,n,t,r,a){e.gl.viewport(n,t,r,a)}function Ze(e,n){const t=e.gl;n?(t.bindFramebuffer(B,n.glObject),function(e){return e.drawBufferList.length>=2}(n)&&t.drawBuffers(n.drawBufferList)):t.bindFramebuffer(B,null)}function Qe(e,n){return!!e.validExtensions.includes(n)||!e.invalidExtensions.includes(n)&&(null!=e.gl.getExtension(n)?(e.validExtensions.push(n),!0):(e.invalidExtensions.push(n),!1))}function en(e,n,t,r){const a=[];r.forEach((e=>{switch(e.type){case y.Struct:e.value.forEach((n=>{a.push(`${e.name}.${n.name}`)}));break;case y.StructArray:e.value.forEach(((n,t)=>{n.forEach((n=>{a.push(`${e.name}[${t}].${n.name}`)}))}));break;default:a.push(e.name)}}));const o=e.gl,i=o.getUniformBlockIndex(n.glObject,t),l=o.getActiveUniformBlockParameter(n.glObject,i,35392),s=o.getUniformIndices(n.glObject,a),u=o.getActiveUniforms(n.glObject,s,35387),c=function(e,n,t,r,a,o,i,l){const{gl:s}=e,u=s.createBuffer();He(s,u),s.bufferData(Ce,i,35048),$e(s),s.bindBufferBase(Ce,l,u);const c=r.map(((e,n)=>({name:e,index:a[n],offset:o[n]})));return{...Ie(e,u),blockName:n,blockSize:t,dataSize:i,bindingPoint:l,variableInfo:c}}(e,t,l,a,s,u,l,e.uboBindingPoint);return e.uboBindingPoint++,c}function nn(e){!function(e,n){e.bindVertexArray(n)}(e.gpu.gl,e.glObject)}function tn(e,n){const t=e.gpu.gl;nn(e);const{name:r,data:a,size:o,location:i,usageType:l,divisor:s}=n,u=null!=i?i:e.vboList.length,c=t.createBuffer();t.bindBuffer(ae,c);const m=Ye(l);switch(t.bufferData(ae,a,m),t.enableVertexAttribArray(u),a.constructor){case Float32Array:t.vertexAttribPointer(u,o,oe,!1,0,0);break;case Uint16Array:t.vertexAttribIPointer(u,o,te,0,0)}s&&t.vertexAttribDivisor(u,s),e.vboList.push({name:r,vbo:c,usage:m,location:i,size:o,divisor:s,elementSize:a.length/o,dataLength:a.length}),t.bindVertexArray(null),t.bindBuffer(ae,null)}function rn(e,n,t){const r=e.attributes.find((({name:e})=>e===n));r&&(r.data=t,function(e,n,t){const{gl:r}=e.gpu,a=function(e,n){return e.vboList.find((({name:e})=>n===e))||null}(e,n);r.bindBuffer(ae,a.vbo),r.bufferSubData(ae,0,t),r.bindBuffer(ae,null)}(e.vertexArrayObject,n,r.data))}const an=(e,n)=>e.attributes.find((({name:e})=>e===n)),on=e=>e.attributes.map((e=>(e=>({name:e.name,location:e.location,size:e.size,dataType:e.data.constructor}))(e))),ln=(e,n,t,r)=>{const a=e.passes.findIndex((e=>e.groupLabel===n)),o=an(r,T.Position).data.length/3;a<0?cn(e,n,{passLabel:t,vertexCount:o}):e.passes[a].passInfos.push({passLabel:t,vertexCount:o})},sn=(e,n)=>{const t=an(n,T.Position);t&&(e.drawVertexCount+=t.data.length/3)},un=e=>{e.drawCallCount++},cn=(e,n,t)=>{e.passes.push({groupLabel:n,passInfos:[t]})};function mn(e,n,t,r){return{e:new Float32Array([e,n,t,r])}}const fn=e=>e.e[0],pn=e=>e.e[1],dn=e=>e.e[2],gn=e=>e.e[3];function hn(e){const n=function(e){const n=fn(e),t=pn(e),r=dn(e),a=gn(e),o=a*n,i=a*t,l=a*r,s=a*a,u=n*n,c=n*t,m=n*r,f=t*t,p=t*r,d=r*r,g=0===Math.cos(n);return{x:(h=2*p+2*o,h>=1?Math.PI/2:h<=-1?-Math.PI/2:Math.asin(h)),y:g?0:Math.atan2(-(2*m-2*i),2*s+2*d-1),z:g?Math.atan2(2*c+2*l,2*s+2*u-1):Math.atan2(-(2*c-2*l),2*s+2*f-1)};var h}(e);return{x:180*n.x/Math.PI,y:180*n.y/Math.PI,z:180*n.z/Math.PI}}function vn(e,n,t){return function(e,n,t){const r=Math.cos(e/2),a=Math.sin(e/2),o=Math.cos(n/2),i=Math.sin(n/2),l=Math.cos(t/2),s=Math.sin(t/2);return mn(a*o*l+r*i*s,r*i*l-a*o*s,r*o*s+a*i*l,r*o*l-a*i*s)}(e*Math.PI/180,n*Math.PI/180,t*Math.PI/180)}function xn(e){const n=fn(e),t=pn(e),r=dn(e),a=gn(e),o=a*n,i=a*t,l=a*r,s=n*n,u=n*t,c=n*r,m=t*t,f=t*r,p=r*r;return wn(1-2*(m+p),2*(u-l),2*(c+i),0,2*(u+l),1-2*(s+p),2*(f-o),0,2*(c-i),2*(f+o),1-2*(s+m),0,0,0,0,1)}function Tn(){return mn(0,0,0,1)}function yn(e){return{rawMatrix:null,quaternion:e}}function Sn(e){return hn(e.quaternion).y}function bn(e){return hn(e.quaternion).z}function Cn(){return yn(vn(0,0,0))}function Mn(e,n){const t=hn(e.quaternion);t.y=n;const r=vn(t.x,t.y,t.z);e.quaternion=r}function Pn(e){const n=yn(Tn());return function(e,n){e.rawMatrix=n}(n,e),n}function wn(e,n,t,r,a,o,i,l,s,u,c,m,f,p,d,g){return{e:new Float32Array([e,a,s,f,n,o,u,p,t,i,c,d,r,l,m,g])}}function Rn(e){return e.e[4]}function Dn(e){return e.e[8]}function Fn(e){return e.e[12]}function Ln(e){return e.e[1]}function Bn(e){return e.e[9]}function En(e){return e.e[13]}function In(e){return e.e[2]}function An(e){return e.e[6]}function Nn(e){return e.e[10]}function kn(e){return e.e[14]}function On(e){return e.e[3]}function _n(e){return e.e[7]}function Vn(e){return e.e[11]}function Un(e){return e.e[15]}function zn(e,n){e.e[0]=n}function jn(e,n){e.e[4]=n}function Gn(e,n){e.e[8]=n}function Wn(e,n){e.e[12]=n}function Hn(e,n){e.e[1]=n}function $n(e,n){e.e[5]=n}function Xn(e,n){e.e[9]=n}function qn(e,n){e.e[13]=n}function Jn(e,n){e.e[2]=n}function Yn(e,n){e.e[6]=n}function Kn(e,n){e.e[10]=n}function Zn(e,n){e.e[14]=n}function Qn(e,n){e.e[3]=n}function et(e,n){e.e[7]=n}function nt(e,n){e.e[11]=n}function tt(e,n){e.e[15]=n}function rt(e){return ft(Fn(e),En(e),kn(e))}function at(){return wn(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}function ot(e){return wn(1,0,0,pt(e),0,1,0,dt(e),0,0,1,gt(e),0,0,0,1)}function it(e){return wn(pt(e),0,0,0,0,dt(e),0,0,0,0,gt(e),0,0,0,0,1)}function lt(...e){const n=at();return e.forEach((e=>function(e,n){const t=e.e,r=n.e,a=t[0],o=t[4],i=t[8],l=t[12],s=t[1],u=t[5],c=t[9],m=t[13],f=t[2],p=t[6],d=t[10],g=t[14],h=t[3],v=t[7],x=t[11],T=t[15],y=r[0],S=r[4],b=r[8],C=r[12],M=r[1],P=r[5],w=r[9],R=r[13],D=r[2],F=r[6],L=r[10],B=r[14],E=r[3],I=r[7],A=r[11],N=r[15];return k=wn(a*y+o*M+i*D+l*E,a*S+o*P+i*F+l*I,a*b+o*w+i*L+l*A,a*C+o*R+i*B+l*N,s*y+u*M+c*D+m*E,s*S+u*P+c*F+m*I,s*b+u*w+c*L+m*A,s*C+u*R+c*B+m*N,f*y+p*M+d*D+g*E,f*S+p*P+d*F+g*I,f*b+p*w+d*L+g*A,f*C+p*R+d*B+g*N,h*y+v*M+x*D+T*E,h*S+v*P+x*F+T*I,h*b+v*w+x*L+T*A,h*C+v*R+x*B+T*N),e.e=new Float32Array([...k.e]),e;var k}(n,e))),n}function st(e){const n=at();return zn(n,function(e){return e.e[0]}(e)),jn(n,Rn(e)),Gn(n,Dn(e)),Wn(n,Fn(e)),Hn(n,Ln(e)),$n(n,function(e){return e.e[5]}(e)),Xn(n,Bn(e)),qn(n,En(e)),Jn(n,In(e)),Yn(n,An(e)),Kn(n,Nn(e)),Zn(n,kn(e)),Qn(n,On(e)),et(n,_n(e)),nt(n,Vn(e)),tt(n,Un(e)),n}function ut(e){const n=Rn(e);jn(e,Ln(e)),Hn(e,n);const t=Dn(e);Gn(e,In(e)),Jn(e,t);const r=Fn(e);Wn(e,On(e)),Qn(e,r);const a=Bn(e);Xn(e,An(e)),Yn(e,a);const o=En(e);qn(e,_n(e)),et(e,o);const i=kn(e);return Zn(e,Vn(e)),nt(e,i),e}function ct(e){const n=e.e,t=n[0],r=n[1],a=n[2],o=n[3],i=n[4],l=n[5],s=n[6],u=n[7],c=n[8],m=n[9],f=n[10],p=n[11],d=n[12],g=n[13],h=n[14],v=n[15],x=m*h*u-g*f*u+g*s*p-l*h*p-m*s*v+l*f*v,T=d*f*u-c*h*u-d*s*p+i*h*p+c*s*v-i*f*v,y=c*g*u-d*m*u+d*l*p-i*g*p-c*l*v+i*m*v,S=d*m*s-c*g*s-d*l*f+i*g*f+c*l*h-i*m*h,b=t*x+r*T+a*y+o*S;if(0===b)return wn(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/b;return n[0]=x*C,n[1]=(g*f*o-m*h*o-g*a*p+r*h*p+m*a*v-r*f*v)*C,n[2]=(l*h*o-g*s*o+g*a*u-r*h*u-l*a*v+r*s*v)*C,n[3]=(m*s*o-l*f*o-m*a*u+r*f*u+l*a*p-r*s*p)*C,n[4]=T*C,n[5]=(c*h*o-d*f*o+d*a*p-t*h*p-c*a*v+t*f*v)*C,n[6]=(d*s*o-i*h*o-d*a*u+t*h*u+i*a*v-t*s*v)*C,n[7]=(i*f*o-c*s*o+c*a*u-t*f*u-i*a*p+t*s*p)*C,n[8]=y*C,n[9]=(d*m*o-c*g*o-d*r*p+t*g*p+c*r*v-t*m*v)*C,n[10]=(i*g*o-d*l*o+d*r*u-t*g*u-i*r*v+t*l*v)*C,n[11]=(c*l*o-i*m*o-c*r*u+t*m*u+i*r*p-t*l*p)*C,n[12]=S*C,n[13]=(c*g*a-d*m*a+d*r*f-t*g*f-c*r*h+t*m*h)*C,n[14]=(d*l*a-i*g*a-d*r*s+t*g*s+i*r*h-t*l*h)*C,n[15]=(i*m*a-c*l*a+c*r*s-t*m*s-i*r*f+t*l*f)*C,e}function mt(e,n,t=Ft(),r=!1){const a=St(r?bt(e,n):bt(n,e)),o=St(At(St(t),a)),i=At(a,o);return wn(pt(o),pt(i),pt(a),pt(e),dt(o),dt(i),dt(a),dt(e),gt(o),gt(i),gt(a),gt(e),0,0,0,1)}function ft(e,n,t){return{e:new Float32Array([e,n,t])}}const pt=e=>e.e[0],dt=e=>e.e[1],gt=e=>e.e[2],ht=(e,n)=>e.e[0]=n,vt=(e,n)=>e.e[1]=n,xt=(e,n)=>e.e[2]=n,Tt=(e,n,t,r)=>{ht(e,n),vt(e,t),xt(e,r)};function yt(e){return Math.max(1e-4,Math.sqrt(pt(e)*pt(e)+dt(e)*dt(e)+gt(e)*gt(e)))}function St(e){const n=yt(e);return Tt(e,pt(e)/n,dt(e)/n,gt(e)/n),e}function bt(e,n){return ft(pt(e)-pt(n),dt(e)-dt(n),gt(e)-gt(n))}function Ct(e){return Tt(e,-pt(e),-dt(e),-gt(e)),e}function Mt(e,n){return Tt(e,pt(e)*n,dt(e)*n,gt(e)*n),e}function Pt(e){return ft(pt(e),dt(e),gt(e))}function wt(e,n){const t=1e-7;return Math.abs(pt(e)-pt(n))<t&&Math.abs(dt(e)-dt(n))<t&&Math.abs(gt(e)-gt(n))<t}function Rt(){return ft(0,0,0)}function Dt(){return ft(1,1,1)}function Ft(){return ft(0,1,0)}function Lt(){return ft(0,-1,0)}function Bt(){return ft(0,0,-1)}function Et(){return ft(1,0,0)}function It(...e){const n=Rt();return e.forEach((e=>{Tt(n,pt(n)+pt(e),dt(n)+dt(e),gt(n)+gt(e))})),n}function At(e,n){return ft(dt(e)*gt(n)-gt(e)*dt(n),gt(e)*pt(n)-pt(e)*gt(n),pt(e)*dt(n)-dt(e)*pt(n))}function Nt(e){return wt(e,Ft())||wt(e,Lt())?Et():At(e,Lt())}function kt(e,n){return At(e,Ct(Pt(n)))}function Ot(e){return ft(e,e,e)}const _t=e=>St(ft(Dn(e.worldMatrix),Bn(e.worldMatrix),Nn(e.worldMatrix))),Vt=(e,n)=>e.scale=n,Ut=(e,n)=>e.position=n,zt=(e,n)=>{e.lookAtTarget=n,e.lookAtTargetActor=null},jt=(e,n)=>{e.poseMatrix=n?lt(n.poseMatrix,e.offsetMatrix):e.offsetMatrix,e.boneOffsetMatrix=ct(st(e.poseMatrix)),e.children.forEach((n=>jt(n,e)))},Gt=(e,n)=>{e.offsetMatrix=lt(ot(e.position),e.rotation.rawMatrix,it(e.scale)),e.jointMatrix=n?lt(n.jointMatrix,e.offsetMatrix):e.offsetMatrix,e.children.forEach((n=>Gt(n,e)))},Wt=(e,n)=>{n(e),e.children.forEach((e=>{Wt(e,n)}))};function Ht(e){const n=[],t=[];for(let r=0;r<e.length/3;r++){const a=ft(e[3*r+0],e[3*r+1],e[3*r+2]),o=Nt(a),i=kt(o,a);n.push(...o.e),t.push(...i.e)}return{tangents:n,binormals:t}}function $t(e){const{gpu:n,drawCount:t}=e,r=e.indices||null,a="number"==typeof e.instanceCount?e.instanceCount:null,o=function({gpu:e,attributes:n=[],indices:t}){const r={...Ie(e,e.gl.createVertexArray()),vboList:[],ibo:null,indicesCount:t?t.length:null,attributes:n};return nn(r),n.forEach((e=>{tn(r,e)})),t&&(r.ibo=function(e,n){const t=e.gl.createBuffer();return function(e,n){e.bindBuffer(be,n)}(e.gl,t),e.gl.bufferData(be,new Uint16Array(n),re),Ie(e,t)}(e,t)),function(e){e.bindVertexArray(null)}(r.gpu.gl),r.ibo&&function(e){e.bindBuffer(be,null)}(r.ibo.gpu.gl),r.attributes=n,r}({gpu:n,attributes:[],indices:r});e.attributes.forEach(((e,n)=>{e.location=n,e.divisor=e.divisor||0}));const i={attributes:[],indices:r,drawCount:t,instanceCount:a,vertexArrayObject:o};return e.attributes.filter((e=>Object.keys(e).length>0)).forEach((e=>{!function(e,n){const t=n.location?n.location:e.attributes.length,r=n.divisor?n.divisor:0,a=Ee({name:n.name,data:n.data,location:t,size:n.size,offset:n.offset,usageType:n.usageType||x.StaticDraw,divisor:r});e.attributes.push(a),tn(e.vertexArrayObject,a)}(i,e)})),i}function Xt({gpu:e,vertexShader:n,fragmentShader:t,transformFeedbackVaryings:r}){const{gl:a}=e,o=a.createProgram(),i=qt(a,35633,n);a.attachShader(o,i);const l=qt(a,35632,t);a.attachShader(o,l),r&&r.length>0&&a.transformFeedbackVaryings(o,r,35981),a.linkProgram(o);const s=a.getProgramInfoLog(o);return s&&s.length,{...Ie(e,o)}}function qt(e,n,t){const r=e.createShader(n);e.shaderSource(r,t),e.compileShader(r);const a=e.getShaderInfoLog(r);return a&&a.length,r}const Jt=new Map([["common","#define saturate(a) clamp(a, 0., 1.)\n\n#define smooth(x) smoothstep(0., 1., x)\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6"],["buffer_visualizer_h","float isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}"],["lighting","#define MAX_SPOT_LIGHT_COUNT 2\n#define MAX_POINT_LIGHT_COUNT 1\n\nstruct Surface {\n    vec3 worldNormal;\n    vec3 worldPosition;\n    vec4 baseColor;\n    float specularAmount;\n};\n\nstruct DirectionalLight {\n    vec3 direction; \n    float intensity;\n    vec4 color;\n    mat4 shadowMapProjectionMatrix;\n};\n\nstruct SpotLight {\n    vec4 color;\n    vec3 position;\n    vec3 direction; \n    float intensity;\n    float distance;\n    float attenuation;\n    float coneCos;\n    float penumbraCos;\n    mat4 shadowMapProjectionMatrix;\n};\n\nstruct PointLight {\n    vec4 color;\n    vec3 position;\n    float intensity;\n    float distance;\n    float attenuation;\n};"],["ub","layout (std140) uniform ubCommon {\n    float uTime; \n    float uDeltaTime; \n    vec4 uViewport; \n};\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\n\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\nlayout (std140) uniform ubDirectionalLight {\n    DirectionalLight uDirectionalLight;\n};\n\nlayout (std140) uniform ubSpotLight {\n    SpotLight uSpotLight[MAX_SPOT_LIGHT_COUNT];\n};\n\nlayout (std140) uniform ubPointLight {\n    PointLight uPointLight[MAX_POINT_LIGHT_COUNT];\n};\n\nlayout (std140) uniform ubTimeline {\n    float uTimelineTime; \n    float uTimelineDeltaTime; \n};"],["rand","float rand(vec2 co){\n    \n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rand2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n    dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nvec3 hash3(vec3 p) {\n    vec3 q = vec3(\n    dot(p, vec3(127.1, 311.7, 114.5)),\n    dot(p, vec3(269.5, 183.3, 191.9)),\n    dot(p, vec3(419.2, 371.9, 514.1))\n    );\n    return fract(sin(q) * 43758.5433);\n}"],["tone","vec3 reinhard(vec3 x) {\r\n    return x / (x + vec3(1.));\r\n}\n\nvec3 reinhardExposure(vec3 x, float exposure) {\r\n    float l2 = exposure * exposure;\r\n    return (x / (x + vec3(1.))) * (1. + (x / exposure));\r\n}\n\nvec3 aces(vec3 x) {\r\n    float a = 2.51;\r\n    float b = .03;\r\n    float c = 2.43;\r\n    float d = .59;\r\n    float e = .14;\r\n    vec3 y = (x * (a * x + b)) / (x * (c * x + d) + e);\r\n    return clamp(y, 0., 1.);\r\n}\n\nvec3 degamma(vec3 color) {\r\n    return pow(color, vec3(1. / 2.2));\r\n}\n\nvec3 gamma(vec3 color) {\r\n    return pow(color, vec3(2.2));\r\n}\n\nvec4 gamma(vec4 color) {\r\n    return pow(color, vec4(2.2));\r\n}"],["depth","uniform sampler2D uDepthTexture;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat viewZToPerspectiveDepth(float viewZ, float near, float far) {\n    return((near + viewZ) * far) / ((far - near) * viewZ);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nfloat ndcZToRawDepth(float ndcZ) {\n    return ndcZ * .5 + .5;\n}\n\nfloat ndcZToLinearDepth(float ndcZ, float near, float far) {\n    float rawDepth = ndcZToRawDepth(ndcZ);\n    return perspectiveDepthToLinearDepth(rawDepth, near, far);\n}\n\nfloat clipPositionToLinearDepth(vec4 clipPosition, float near, float far) {\n    float z = clipPosition.z / clipPosition.w; \n    return ndcZToLinearDepth(z, near, far);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}"],["gbuffer","#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}"],["gbuffer_o","layout (location = 0) out vec4 outGBufferA;\nlayout (location = 1) out vec4 outGBufferB;\nlayout (location = 2) out vec4 outGBufferC;\nlayout (location = 3) out vec4 outGBufferD;"],["etex","in vec2 vUv;\n\nout vec4 outColor;\n\nuniform vec2 uResolution;\nuniform vec2 uGridSize;\nuniform float uTime;"],["raymarch_df","#define OP_ID(p, r) round(p / r)\n#define OP_RE(p, r) p - r * round(p / r)\n#define OP_LI_RE(p, r, l) p - r * clamp(round(p / r), -l, l)\n\n#define EPS .0001 \n#define OI 99 \n#define SI 80 \n\nvec2 minMat(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 opRepeat(vec3 p, float s) {\n    return p - s * round(p / s);\n}\n\nvec3 opLiRe(vec3 p, float s, vec3 l)\n{\n    return p - s * clamp(round(p / s), -l, l);\n}\n\nvec2 opRo(vec2 p, float a) {\n    return p * rot(-a);\n}\n\nvec3 opTr(vec3 p, vec3 t) {\n    return p - t;\n}\n\nvec3 opScale(vec3 p, vec3 s) {\n    return p * (1. / s);\n}\n\nvec3 opPreScale(vec3 p, vec3 s) {\n    return p / s;\n}\n\nfloat opPostScale(float d, vec3 s) {\n    return d * min(s.x, min(s.y, s.z));\n}\n\nvec2 opFoldRotate(in vec2 p, float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI * 2. / s;\n    a = floor(a / n) * n;\n    p = opRo(p, -a);\n    return p;\n}\n\nfloat opSm( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat dfSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat dfRb(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r;\n}\n\nfloat dfBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat dfRoundedCylinder(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2(length(p.xz)-2.0*ra+rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat dfCone(vec3 p, vec2 c, float h)\n{\n    \n    \n    \n    vec2 q = h*vec2(c.x/c.y, -1.0);\n\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q*clamp(dot(w, q)/dot(q, q), 0.0, 1.0);\n    vec2 b = w - q*vec2(clamp(w.x/q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k*(w.x*q.y-w.y*q.x), k*(w.y-q.y));\n    return sqrt(d)*sign(s);\n}"],["raymarch_sf","vec3 toLocal(vec3 p, mat4 WtoO, vec3 scale) {\n    \n    return (WtoO * vec4(p, 1.)).xyz * scale;\n}\n\nvec2 objectSpaceDfScene(vec3 worldPos, mat4 WtoO, vec3 scale, float useWorld) {\n    \n    vec3 p = mix(\n        toLocal(worldPos, WtoO, scale),\n        worldPos,\n        useWorld\n    );\n    return dfScene(p);\n}\n\nvec2 blendSpaceDfScene(vec3 worldPos, mat4 WtoO, vec3 scale, float blendRate) {\n    vec3 localPos = toLocal(worldPos, WtoO, scale);\n    vec3 p = mix(localPos, worldPos, blendRate);\n    return dfScene(p);\n}\n\nvec3 getNormalObjectSpaceDfScene(vec3 p, mat4 WtoO, vec3 scale, float useWorld) {\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    const float d = .0001;\n    vec3 n = vec3(0., 0., 0.);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3(\n            (((i + 3) >> 1) & 1),\n            ((i >> 1) & 1),\n            (i & 1)) - 1.\n        );\n        n += e * objectSpaceDfScene(p + e * d, WtoO, scale, useWorld).x;\n    }\n    return normalize(n);\n}\n\nvec3 getNormalDfScene(vec3 p) {\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    const float d = .0001;\n    vec3 n = vec3(0., 0., 0.);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3(\n        (((i + 3) >> 1) & 1),\n        ((i >> 1) & 1),\n        (i & 1)) - 1.\n        );\n        n += e * dfScene(p + e * d).x;\n    }\n    return normalize(n);   \n}\n\nbool isDfInnerBox(vec3 p, vec3 scale) {\n    \n    \n    const float eps = .0001;\n    return\n        abs(p.x) < scale.x * .5 + eps &&\n        abs(p.y) < scale.y * .5 + eps &&\n        abs(p.z) < scale.z * .5 + eps;\n}\n\nmat3 getCameraRayCoordinate(vec3 origin, vec3 lookAt, vec3 up) {\n    vec3 f = normalize(lookAt - origin);\n    vec3 r = cross(f, up);\n    vec3 u = cross(r, f);\n    return mat3(r, u, f);\n}\n\nvec3 getPerspectiveCameraRayDir(vec2 uv, vec3 forward, float fov, float aspect) {\n    vec2 st = uv * 2. - 1.;\n    float fovRad = fov * 3.141592 / 180.;\n    float hh = tan(fovRad * .5);\n    float hw = hh * aspect;\n    vec3 dummyUp = vec3(0., 1., 0.);\n    vec3 nf = forward;\n    vec3 right = normalize(cross(nf, dummyUp));\n    vec3 up = normalize(cross(right, nf));\n    vec3 dir = normalize(right * hw * st.x + up * hh * st.y + forward);\n    return dir;\n}"],["alpha_test","#ifdef USE_ALPHA_TEST\nuniform float uAlphaTestThreshold;\n#endif\n\nvoid checkAlphaTest(float value, float threshold) {\n    if(value < threshold) {\n        discard;\n    }\n}\n\nvoid checkAlphaTest(vec4 value, float threshold) {\n    if(value.a < threshold) {\n        discard;\n    }\n}"],["alpha_test_f","#ifdef USE_ALPHA_TEST\ncheckAlphaTest(resultColor, uAlphaTestThreshold);\n#endif"],["vcolor_vh","#ifdef USE_VERTEX_COLOR\nout vec4 vVertexColor;\nout vec4 vVertexEmissiveColor;\n#endif"],["vcolor_fh","#ifdef USE_VERTEX_COLOR\nin vec4 vVertexColor;\nin vec4 vVertexEmissiveColor;\n#endif"],["normal_map_fh","#ifdef USE_NORMAL_MAP\nin vec3 vTangent;\nin vec3 vBinormal;\nuniform sampler2D uNormalMap;\nuniform float uNormalStrength;\n#endif"],["normal_map_f","#ifdef USE_NORMAL_MAP\nworldNormal = calcNormal(vNormal, vTangent, vBinormal, uNormalMap, uv);\n#else\nworldNormal = normalize(vNormal);\n#endif"],["env_map","vec3 calcEnvMapSampleDir(vec3 reflectDir, float rotationOffset) {\n    reflectDir.x *= -1.;\n    float c = cos(3.14 + rotationOffset);\n    float s = sin(3.14 + rotationOffset);\n    reflectDir.xz *= mat2(c, s, -s, c);\n    return reflectDir;\n}"],["skybox_h","struct Skybox {\n    samplerCube cubeMap;\n    float diffuseIntensity;\n    float specularIntensity;\n    float rotationOffset;\n    float maxLodLevel;\n};\n\nuniform Skybox uSkybox;\n\nstruct SkyboxLight {\n    float diffuseIntensity;\n    float specularIntensity;\n    float rotationOffset;\n    float maxLodLevel;\n};\n\nstruct IncidentSkyboxLight {\n    \n    \n    vec3 diffuseDirection;\n    float diffuseIntensity;\n    \n    vec3 specularDirection;\n    float specularIntensity;\n    float maxLodLevel;\n};\n\nvec3 calcEnvMapSampleDir(vec3 reflectDir, float rotationOffset) {\n    reflectDir.x *= -1.;\n    float c = cos(3.14 + rotationOffset);\n    float s = sin(3.14 + rotationOffset);\n    reflectDir.xz *= mat2(c, s, -s, c);\n    return reflectDir;\n}\n\nvoid getSkyboxLightIrradiance(\n    const in SkyboxLight skyboxLight,\n    const in GeometricContext geometry,\n    out IncidentSkyboxLight directLight\n) {\n    vec3 envDir = reflect(\n        -geometry.viewDir,\n        normalize(geometry.normal)\n    );\n\n    vec3 envDiffuseDir = calcEnvMapSampleDir(geometry.normal, skyboxLight.rotationOffset);\n    vec3 envSpecularDir = calcEnvMapSampleDir(envDir, skyboxLight.rotationOffset);\n\n    \n    directLight.diffuseDirection = envDiffuseDir;\n    directLight.diffuseIntensity = skyboxLight.diffuseIntensity;\n    directLight.specularDirection = envSpecularDir;\n    directLight.specularIntensity = skyboxLight.specularIntensity;\n    directLight.maxLodLevel = skyboxLight.maxLodLevel;\n}"],["geometry_h","struct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};"],["os_raymarch_f","vec2 osRaymarch(\r\n    vec3 rayOrigin,\r\n    vec3 rayDirection,\r\n    float minDistance,\r\n    mat4 viewMatrix,\r\n    mat4 projectionMatrix,\r\n    mat4 inverseWorldMatrix,\r\n    float side,\r\n    vec3 boundsScale,\r\n    float useWorld,\r\n    bool useDiscard,\r\n    out vec3 currentRayPosition\r\n) {\r\n    vec2 result = vec2(0.);\r\n    float accLen = 0.;\r\n   \r\n    currentRayPosition = rayOrigin;\n\n    for (int i = 0; i < OI; i++) {\r\n        currentRayPosition = rayOrigin + rayDirection * accLen;\r\n        result = objectSpaceDfScene(currentRayPosition, inverseWorldMatrix, boundsScale, useWorld) * side;\r\n        accLen += result.x;\r\n        if (!isDfInnerBox(toLocal(currentRayPosition, inverseWorldMatrix, boundsScale), boundsScale)) {\r\n            break;\r\n        }\r\n        if (result.x <= minDistance) {\r\n            break;\r\n        }\r\n    }\n\n    if (result.x > minDistance && useDiscard) {\r\n        discard;\r\n    }\n\n    \n    vec4 rayClipPosition = projectionMatrix * viewMatrix * vec4(currentRayPosition, 1.);\r\n    float newDepth = (rayClipPosition.z / rayClipPosition.w) * .5 + .5;\r\n    gl_FragDepth = newDepth;\r\n    \r\n    return result;\r\n}\n\nvoid checkDiscardByCompareRayDepthAndSceneDepth(\r\n    vec3 currentRayPosition,\r\n    sampler2D depthTexture,\r\n    float nearClip,\r\n    float farClip,\r\n    mat4 viewMatrix\r\n) {\r\n    \n    float rawDepth = texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x;\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, nearClip, farClip);\r\n    vec4 currentRayViewPosition = (viewMatrix * vec4(currentRayPosition, 1.));\r\n    float currentDepth = viewZToLinearDepth(currentRayViewPosition.z, nearClip, farClip);\r\n    if(currentDepth >= sceneDepth) {\r\n        discard;\r\n    }\r\n}\n\nvec3 getOSRaymarchViewRayDirection(vec3 origin, vec3 viewPosition, float isPerspective) {\r\n    return isPerspective > .5\r\n        ? normalize(origin - viewPosition)\r\n        : normalize(-viewPosition);\r\n}"]]),Yt=e=>e.replaceAll(/#include\s?<([a-zA-Z_]*)>/g,((e,n)=>Jt.get(n)||"")),Kt=(e,n)=>{let t=e;return null===t.match(/^#version 300 es/)&&(t="#version 300 es\nprecision highp float;\n"+t),t=Yt(t),t=t.replaceAll(new RegExp(`#pragma ${w.DEFINES}`,"g"),(()=>(({receiveShadow:e,isSkinning:n,gpuSkinning:t,useNormalMap:r,useEnvMap:a,useVertexColor:o,useAlphaTest:i,isInstancing:l,useInstanceLookDirection:s})=>{const u=[];return e&&u.push("#define USE_RECEIVE_SHADOW"),n&&(t?u.push("#define USE_SKINNING_GPU"):u.push("#define USE_SKINNING_CPU")),r&&u.push("#define USE_NORMAL_MAP"),a&&u.push("#define USE_ENV_MAP"),o&&u.push("#define USE_VERTEX_COLOR"),i&&u.push("#define USE_ALPHA_TEST"),l&&u.push("#define USE_INSTANCING"),s&&u.push("#define USE_INSTANCE_LOOK_DIRECTION"),u})(n).join("\n"))),t=(e=>{const n=[...e.matchAll(/#pragma UNROLL_START\s+([\s\S]+?)\s+#pragma UNROLL_END/g)];for(let t=0;t<n.length;t++){const[r,a]=n[t],o=/^([a-zA-Z0-9_]+)([\s\S]*)/g,i=[...a.matchAll(o)];if(i.length<1)continue;const[,l,s]=i[0],u=new RegExp(`#define\\s+?${l}\\s+?(\\d+)`),c=e.match(u);let m=0;if(c){const e=c[1];m=parseInt(e)}else m=parseInt(l);let f="";for(let e=0;e<m;e++){const n=new RegExp("UNROLL_N","g");f+=s.replaceAll(n,e.toString())}e=e.replaceAll(r,f)}return e})(t),t},Zt=()=>"out vec4 outColor;\n\nvoid main() {\r\n    outColor = vec4(1., 1., 1., 1.);\r\n}";function Qt(...e){const n=[];for(let t=0;t<e.length;t++)for(let r=0;r<e[t].length;r++){const a=e[t][r],o=n.findIndex((e=>e.name===a.name));o<0?n.push(a):n[o].value=a.value}return{data:n,uniformBlocks:[]}}const er=(e,n,t,r=!1)=>{const a=((e,n)=>e.data.find((e=>e.name===n)))(e,n);a&&(a.type===y.Struct?t.forEach((e=>{const n=a.value.findIndex((n=>n.name===e.name));n>=0&&(a.value[n].value=e.value)})):a.type===y.StructArray?t.forEach(((e,n)=>{e.forEach((e=>{const t=a.value[n].findIndex((n=>n.name===e.name));t>=0&&(a.value[n][t].value=e.value)}))})):a.value=t)};function nr(e,n,t){er(e.uniforms,n,t)}function tr(e,n,t,r){((e,n,t,r)=>{e.data.push({name:n,type:t,value:r})})(e.uniforms,n,t,r)}const rr=e=>null!==e.shader;function ar(e){const{name:n="",vertexShaderGenerator:r=null,fragmentShaderGenerator:l=null,depthFragmentShaderGenerator:s=null,vertexShaderModifiers:u=[],fragmentShaderModifiers:f=[],depthFragmentShaderModifiers:p=[],skipDepthPrePass:d=!1,depthFuncType:g=a.Lequal,faceSide:h=m.Front,receiveShadow:v=!1,useNormalMap:x=!1,isSkinning:T=!1,gpuSkinning:b=!1,isInstancing:C=!1,useInstanceLookDirection:M=!1,useVertexColor:P=!1,useEnvMap:w=!1,showLog:R=!1}=e;let{depthTest:D=!0,depthWrite:F=!0,alphaTest:L=null}=e;const B=e.type??c.Misc,E=e.primitiveType??t.Triangles,I=e.blendType??o.Opaque;L="number"==typeof e.alphaTest?e.alphaTest:null;let A=e.renderQueueType??i.Opaque;if(null!==L&&(A=i.AlphaTest),A!==i.Skybox&&void 0===e.renderQueueType)switch(I){case o.Opaque:A=i.Opaque;break;case o.Transparent:case o.Additive:A=i.Transparent}i.AlphaTest;const N=e.uniformBlockNames||[];D=!!D,F=!!F;const k=e.queue||null,O="number"==typeof e.jointNum?e.jointNum:null,_=e.vertexShader||"",V=e.fragmentShader||"",U=e.depthFragmentShader||null,z=e.rawVertexShader||null,j=e.rawFragmentShader||null,G=[{name:S.InverseWorldMatrix,type:y.Matrix4,value:at()},{name:S.Time,type:y.Float,value:0},...null!==L?[{name:"uAlphaTestThreshold",type:y.Float,value:L}]:[]];return{name:n,canRender:!0,type:B,primitiveType:E,blendType:I,renderQueueType:A,uniformBlockNames:N,depthTest:D,depthWrite:F,depthFuncType:g,faceSide:h,skipDepthPrePass:d,alphaTest:L,receiveShadow:v,queue:k,useNormalMap:x,useEnvMap:w,isSkinning:T,gpuSkinning:b,jointNum:O,isInstancing:C,useInstanceLookDirection:M,useVertexColor:P,showLog:R,boundUniformBufferObjects:!1,uniforms:Qt(G,e.uniforms||[]),depthUniforms:Qt(G,e.depthUniforms||[]),shader:null,vertexShader:_,fragmentShader:V,depthFragmentShader:U,rawVertexShader:z,rawFragmentShader:j,vertexShaderGenerator:r,fragmentShaderGenerator:l,depthFragmentShaderGenerator:s,vertexShaderModifiers:u,fragmentShaderModifiers:f,depthFragmentShaderModifiers:p}}const or=(e,{gpu:n,attributeDescriptors:t})=>{!e.depthFragmentShader&&e.depthFragmentShaderGenerator&&(e.depthFragmentShader=e.depthFragmentShaderGenerator());const r={receiveShadow:e.receiveShadow,isSkinning:e.isSkinning,gpuSkinning:e.gpuSkinning,useNormalMap:e.useNormalMap,useEnvMap:e.useEnvMap,useReceiveShadow:e.receiveShadow,useVertexColor:e.useVertexColor,isInstancing:e.isInstancing,useAlphaTest:null!==e.alphaTest,useInstanceLookDirection:e.useInstanceLookDirection};if(!e.rawVertexShader){!e.vertexShader&&e.vertexShaderGenerator&&(e.vertexShader=e.vertexShaderGenerator({attributeDescriptors:t,isSkinning:e.isSkinning,jointNum:e.jointNum,gpuSkinning:e.gpuSkinning,isInstancing:e.isInstancing,useInstanceLookDirection:e.useInstanceLookDirection}));const n=((e,n,t,r)=>{let a=e;return a=Kt(a,t),a=a.replaceAll(new RegExp(`#pragma ${w.ATTRIBUTES}`,"g"),(()=>{const e=(e=>[...e].sort(((e,n)=>e.location-n.location)).map((({location:e,size:n,name:t,dataType:r})=>{let a;switch(r){case Float32Array:switch(n){case 1:a="float";break;case 2:a="vec2";break;case 3:a="vec3";break;case 4:a="vec4"}break;case Uint16Array:switch(n){case 1:a="uint";break;case 2:a="uvec2";break;case 3:a="uvec3";break;case 4:a="uvec4"}}return`layout(location = ${e}) in ${a} ${t};`})))(n);return e.join("\n")})),Object.values(M).forEach((e=>{const n=e;a=a.replaceAll(new RegExp(`#pragma ${n}`,"g"),(()=>{const e=r.findIndex((e=>e.pragma===n));return e<0?"":r[e].value||""}))})),a})(e.vertexShader,t,r,e.vertexShaderModifiers);e.rawVertexShader=n}if(!e.rawFragmentShader){!e.fragmentShader&&e.fragmentShaderGenerator&&(e.fragmentShader=e.fragmentShaderGenerator({attributeDescriptors:t}));const n=((e,n,t)=>{let r=e;return r=Kt(r,n),Object.values(P).forEach((e=>{const n=e;r=r.replaceAll(new RegExp(`#pragma ${n}`,"g"),(()=>{const e=t.findIndex((e=>e.pragma===n));return e<0?"":t[e].value||""}))})),r})(e.fragmentShader,r,e.fragmentShaderModifiers);e.rawFragmentShader=n}e.showLog,e.shader=Xt({gpu:n,vertexShader:e.rawVertexShader,fragmentShader:e.rawFragmentShader})};function ir(e=0,n=0,t=0,r=1){return{e:new Float32Array([e,n,t,r])}}function lr(e){return 255*e.e[0]}function sr(e){return 255*e.e[1]}function ur(e){return 255*e.e[2]}function cr(e,n=!0){const t=function(e){return{r:lr(e),g:sr(e),b:ur(e)}}(e),r=t.r.toString(16).padStart(2,"0"),a=t.g.toString(16).padStart(2,"0"),o=t.b.toString(16).padStart(2,"0");return n?`#${r}${a}${o}`:`${r}${a}${o}`}function mr(){return ir(1,1,1,1)}function fr(){return ir(0,0,0,1)}function pr(e){return ir(e[0],e[1],e[2],e[3]?e[3]:1)}function dr(e){const n="#"===e.slice(0,1)?e.slice(1):e,t=n.slice(0,2),r=n.slice(2,4),a=n.slice(4,6);return ir(Number.parseInt(t,16)/255,Number.parseInt(r,16)/255,Number.parseInt(a,16)/255,1)}var gr="#pragma DEFINES\n\n#pragma ATTRIBUTES\n\n#pragma APPEND_ATTRIBUTES\n\n#include <lighting>\r\n#include <ub>\r\n#include <vcolor_vh>\n\nout vec2 vUv;\r\nout vec3 vLocalPosition;\r\nout vec3 vWorldPosition;\r\nout vec3 vNormal;\r\nout mat4 vWorldMatrix;\r\nout mat4 vInverseWorldMatrix;\n\n#ifdef USE_INSTANCING\r\nout float vInstanceId;\n\nuniform float uRotMode; \nuniform vec4 uBaseColor;\r\nuniform float uBaseMixer;\r\nuniform vec4 uEmissiveColor;\r\nuniform float uEmissiveMixer;\r\n#endif\n\n#ifdef USE_NORMAL_MAP\r\nout vec3 vTangent;\r\nout vec3 vBinormal;\r\n#endif\n\n#pragma APPEND_UNIFORMS\n\nmat4 getRotationXMat(float rad) {\r\n    float c = cos(rad);\r\n    float s = sin(rad);\r\n    return mat4(\r\n        \n        \n        \n        \n        \n        \n        1., 0., 0., 0.,\r\n        0., c, s, 0.,\r\n        0., -s, c, 0.,\r\n        0., 0., 0., 1.\r\n    );\r\n}\n\nmat4 getRotationYMat(float rad) {\r\n    float c = cos(rad);\r\n    float s = sin(rad);\r\n    return mat4(\r\n        \n        \n        \n        \n        \n        \n        c, 0., -s, 0.,\r\n        0., 1., 0., 0.,\r\n        s, 0., c, 0.,\r\n        0., 0., 0., 1.\r\n    );\r\n}\n\nmat4 getRotationZMat(float rad) {\r\n    float c = cos(rad);\r\n    float s = sin(rad);\r\n    return mat4(\r\n        \n        \n        \n        \n        \n        \n        c, s, 0., 0.,\r\n        -s, c, 0., 0.,\r\n        0., 0., 1., 0.,\r\n        0., 0., 0., 1.\r\n    );\r\n}\n\nmat4 getTranslationMat(vec3 p) {\r\n    return mat4(\r\n        \n        \n        \n        \n        \n        \n        1., 0., 0., 0.,\r\n        0., 1., 0., 0.,\r\n        0., 0., 1., 0.,\r\n        p.x, p.y, p.z, 1.\r\n    );\r\n}\n\nmat4 getScalingMat(vec3 s) {\r\n    return mat4(\r\n        \n        s.x, 0., 0., 0.,\r\n        0., s.y, 0., 0.,\r\n        0., 0., s.z, 0.,\r\n        0., 0., 0., 1.\r\n    );\r\n}\n\nmat4 getLookAtMat(vec3 lookAt, vec3 p) {\r\n    vec3 f = mix(\r\n        vec3(0., 1., 0.),\n        normalize(lookAt - p),\r\n        step(.01, length(lookAt - p))\r\n    );\r\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\r\n    vec3 u = cross(f, r);\r\n    return mat4(\r\n        r.x, r.y, r.z, 0.,\r\n        u.x, u.y, u.z, 0.,\r\n        f.x, f.y, f.z, 0.,\r\n        0., 0., 0., 1.\r\n    );\r\n}\n\n#if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n\nuniform sampler2D uJointTexture;\r\nuniform int uBoneCount;\r\nuniform int uJointTextureColNum;\r\nuniform int uTotalFrameCount;\n\nmat4 calcSkinningMatrix(mat4 jointMat0, mat4 jointMat1, mat4 jointMat2, mat4 jointMat3, vec4 boneWeights) {\r\n    mat4 skinMatrix =\r\n    jointMat0 * aBoneWeights.x +\r\n    jointMat1 * aBoneWeights.y +\r\n    jointMat2 * aBoneWeights.z +\r\n    jointMat3 * aBoneWeights.w;\r\n    return skinMatrix;\r\n}\n\nmat4 getJointMatrix(sampler2D jointTexture, uint jointIndex, int colNum) {\r\n    \n    int colIndex = int(mod(float(jointIndex), float(colNum)));\r\n    \n    int rowIndex = int(floor(float(jointIndex) / float(colNum)));\r\n    mat4 jointMatrix = mat4(\r\n    \n    \n    \n    \n    \n    \n    texelFetch(jointTexture, ivec2(colIndex * 4 + 0, rowIndex), 0),\r\n    texelFetch(jointTexture, ivec2(colIndex * 4 + 1, rowIndex), 0),\r\n    texelFetch(jointTexture, ivec2(colIndex * 4 + 2, rowIndex), 0),\r\n    texelFetch(jointTexture, ivec2(colIndex * 4 + 3, rowIndex), 0)\r\n    );\r\n    return jointMatrix;\r\n}\r\nmat4 getJointMatrixGPUSkinning(\r\n    sampler2D jointTexture,\r\n    uint jointIndex,\r\n    int jointNum,\r\n    int currentSkinIndex,\r\n    int colNum,\r\n    int totalFrameCount,\r\n    float time,\r\n    float timeOffset\r\n) {\r\n    \n    \n    \n    \n    \n\n    float offset = float(int(mod(floor(time + timeOffset), float(totalFrameCount))) * jointNum);\r\n    \n    int colIndex = int(mod(float(jointIndex) + offset, float(colNum)));\r\n    \n    int rowIndex = int(floor(float(jointIndex) + offset / float(colNum)));\n\n    mat4 jointMatrix = mat4(\r\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 0, rowIndex), 0),\r\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 1, rowIndex), 0),\r\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 2, rowIndex), 0),\r\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 3, rowIndex), 0)\r\n    );\r\n    return jointMatrix;\r\n}\r\n#endif\r\n\nvoid main() {\n\n    #pragma BEGIN_MAIN\n\n    vec4 localPosition = vec4(aPosition, 1.);\n\n    \n    #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\r\n        mat4 skinMatrix = mat4(\r\n            1., 0., 0., 0.,\r\n            0., 1., 0., 0.,\r\n            0., 0., 1., 0.,\r\n            0., 0., 0., 1.\r\n        );\r\n        #ifdef USE_SKINNING_GPU\r\n            float fps = 30.;\r\n            mat4 jointMatrix0 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[0], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\r\n            mat4 jointMatrix1 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[1], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\r\n            mat4 jointMatrix2 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[2], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\r\n            mat4 jointMatrix3 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[3], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\r\n            skinMatrix = calcSkinningMatrix(\r\n                jointMatrix0,\r\n                jointMatrix1,\r\n                jointMatrix2,\r\n                jointMatrix3,\r\n                aBoneWeights\r\n            );\r\n        #endif\r\n        #ifdef USE_SKINNING_CPU\r\n            mat4 jointMatrix0 = getJointMatrix(uJointTexture, aBoneIndices[0], uJointTextureColNum);\r\n            mat4 jointMatrix1 = getJointMatrix(uJointTexture, aBoneIndices[1], uJointTextureColNum);\r\n            mat4 jointMatrix2 = getJointMatrix(uJointTexture, aBoneIndices[2], uJointTextureColNum);\r\n            mat4 jointMatrix3 = getJointMatrix(uJointTexture, aBoneIndices[3], uJointTextureColNum);\r\n            skinMatrix = calcSkinningMatrix(\r\n                jointMatrix0,\r\n                jointMatrix1,\r\n                jointMatrix2,\r\n                jointMatrix3,\r\n                aBoneWeights\r\n            );\r\n        #endif\r\n        localPosition = skinMatrix * localPosition;\r\n    #endif\r\n    \n\n    #pragma LOCAL_POSITION_POST_PROCESS\n\n    \n    vUv = aUv;\r\n    vLocalPosition = aPosition;\n\n    mat4 worldMatrix = uWorldMatrix;\r\n    \r\n#ifdef USE_INSTANCING\r\n    mat4 instanceTranslation = getTranslationMat(aInstancePosition);\r\n    mat4 instanceScaling = getScalingMat(aInstanceScale.xyz);\r\n    mat4 instanceRotationX = getRotationXMat(aInstanceRotation.x);\r\n    mat4 instanceRotationY = getRotationYMat(aInstanceRotation.y);\r\n    mat4 instanceRotationZ = getRotationZMat(aInstanceRotation.z);\r\n    mat4 instanceRotation =\r\n        instanceRotationY *\r\n        instanceRotationX *\r\n        instanceRotationZ;\r\n    \r\n    \n    \n    #ifdef USE_INSTANCE_LOOK_DIRECTION\r\n        \n        instanceRotation = getLookAtMat(aInstancePosition + aInstanceVelocity * 1000., aInstancePosition);\r\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    #endif\r\n   \r\n    #pragma INSTANCE_TRANSFORM_PRE_PROCESS\r\n   \r\n    \n    \n    worldMatrix = uWorldMatrix * instanceTranslation * instanceRotation * instanceScaling;\r\n    \r\n    vInstanceId = float(gl_InstanceID);\n\n    \n    \n    vVertexEmissiveColor = mix(aInstanceEmissiveColor, uEmissiveColor, uEmissiveMixer);\r\n#endif\n\n    vec4 worldPosition = worldMatrix * localPosition;\n\n    #pragma WORLD_POSITION_POST_PROCESS\n\n    vWorldPosition = worldPosition.xyz;\r\n    vInverseWorldMatrix = inverse(worldMatrix);\r\n    \r\n    vWorldMatrix = worldMatrix;\n\n    \n    mat3 normalMatrix;\r\n    #ifdef USE_NORMAL_MAP\r\n        #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\r\n            #ifdef USE_INSTANCING\r\n                normalMatrix = mat3(transpose(inverse(worldMatrix))) * mat3(skinMatrix);\r\n            #else\r\n                normalMatrix = mat3(uNormalMatrix) * mat3(skinMatrix);\r\n            #endif\r\n        #else\r\n            #ifdef USE_INSTANCING\r\n                normalMatrix = mat3(transpose(inverse(worldMatrix)));\r\n            #else\r\n                normalMatrix = mat3(uNormalMatrix);\r\n            #endif\r\n        #endif\r\n        vNormal = normalMatrix * aNormal;\r\n        vTangent = normalMatrix * aTangent;\r\n        vBinormal = normalMatrix * aBinormal;\r\n    #else\r\n        #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\r\n            #ifdef USE_INSTANCING\r\n                normalMatrix = mat3(transpose(inverse(worldMatrix))) * mat3(skinMatrix);\r\n            #else\r\n                normalMatrix = mat3(uNormalMatrix);\r\n            #endif\r\n        #else\r\n            #ifdef USE_INSTANCING\r\n                normalMatrix = mat3(transpose(inverse(worldMatrix)));\r\n            #else\r\n                normalMatrix = mat3(uNormalMatrix);\r\n            #endif\r\n        #endif\r\n        vNormal = normalMatrix * aNormal;\r\n    #endif\n\n    \n    \n    \n    \n    \n    \n    \r\n\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\r\n    \r\n#if defined(USE_INSTANCING) && defined(USE_VERTEX_COLOR)\r\n    \n    vVertexColor = mix(aInstanceVertexColor, uBaseColor, uBaseMixer);\r\n    #if defined(USE_INSTANCING)\r\n        vVertexEmissiveColor = mix(aInstanceEmissiveColor, uEmissiveColor, uEmissiveMixer);\r\n    #else\r\n        vVertexEmissiveColor = mix(aVertexEmissiveColor, uEmissiveColor, uEmissiveMixer);\r\n    #endif\r\n#endif\n\n    #pragma END_MAIN\r\n}",hr="#pragma DEFINES\n\n#include <lighting>\r\n#include <ub>\r\n#include <tone>\r\n#include <gbuffer>\r\n#include <alpha_test>\r\n#include <vcolor_fh>\r\n#include <normal_map_fh>\n\nuniform vec4 uBaseColor;\r\nuniform sampler2D uBaseMap; \r\nuniform vec4 uBaseMapTiling;\r\nuniform float uSpecularAmount;\r\nuniform samplerCube uEnvMap;\r\nuniform float uAmbientAmount;\r\nuniform float uMetallic;\r\nuniform sampler2D uMetallicMap;\r\nuniform vec4 uMetallicMapTiling;\r\nuniform float uRoughness;\r\nuniform sampler2D uRoughnessMap;\r\nuniform vec4 uRoughnessMapTiling;\r\nuniform vec4 uEmissiveColor;\r\nuniform int uShadingModelId;\n\n#pragma APPEND_UNIFORMS\n\nin vec2 vUv;\r\nin vec3 vNormal;\n\nin vec3 vWorldPosition;\n\n#ifdef USE_NORMAL_MAP\r\nvec3 calcNormal(vec3 normal, vec3 tangent, vec3 binormal, sampler2D normalMap, vec2 uv) {\r\n    vec3 n = normalize(normal);\r\n    vec3 t = normalize(tangent);\r\n    vec3 b = normalize(binormal);\r\n    mat3 tbn = mat3(t, b, n);\r\n    vec3 nt = texture(normalMap, uv).xyz;\r\n    nt = nt * 2. - 1.;\n\n    \n    vec3 resultNormal = normalize(tbn * nt);\r\n    \n    \n    \n\n    return resultNormal;\r\n}\r\n#endif\n\n#include <gbuffer_o>\n\nvoid main() {\r\n    vec2 uv = vUv * uBaseMapTiling.xy + uBaseMapTiling.zw;\r\n  \r\n    vec4 baseMapColor = texture(uBaseMap, uv);\r\n    vec4 baseColor = baseMapColor;\r\n   \r\n    vec3 worldNormal = vNormal;\r\n    \r\n    vec4 emissiveColor = vec4(0.);\n\n    \n    #ifdef USE_NORMAL_MAP\nworldNormal = calcNormal(vNormal, vTangent, vBinormal, uNormalMap, uv);\n#else\nworldNormal = normalize(vNormal);\n#endif\n\n#ifdef USE_VERTEX_COLOR\r\n    \n    baseColor *= vVertexColor;\r\n    emissiveColor = vVertexEmissiveColor;\r\n#else\r\n    baseColor *= uBaseColor;\r\n    emissiveColor = uEmissiveColor;\r\n#endif\n\n    \n\n    Surface surface;\r\n    surface.worldPosition = vWorldPosition;\r\n    surface.worldNormal = worldNormal;\r\n    surface.baseColor = baseColor;\r\n    \r\n    \n    #ifdef USE_ALPHA_TEST\ncheckAlphaTest(resultColor, uAlphaTestThreshold);\n#endif\n\n    baseColor.rgb = gamma(baseColor.rgb);\r\n   \r\n    \n    float metallic = uMetallic;\r\n    metallic *= texture(uMetallicMap, uv * uMetallicMapTiling.xy).r;\r\n    float roughness = uRoughness;\r\n    roughness *= texture(uRoughnessMap, uv * uRoughnessMapTiling.xy).r;\r\n    \r\n    emissiveColor.rgb = gamma(emissiveColor.rgb);\r\n    \r\n    #pragma BEFORE_OUT\n\n    outGBufferA = EncodeGBufferA(baseColor.rgb);\r\n    outGBufferB = EncodeGBufferB(worldNormal, uShadingModelId);\r\n    outGBufferC = EncodeGBufferC(metallic, roughness);\r\n    outGBufferD = EncodeGBufferD(emissiveColor.rgb);\r\n}",vr="#pragma DEFINES\n\nuniform vec4 uColor; \nuniform sampler2D uBaseMap; \r\nuniform vec4 uBaseMapTiling;\n\n#ifdef USE_ALPHA_TEST\r\nuniform float uAlphaTestThreshold;\r\n#endif\n\nin vec2 vUv;\n\n#ifdef USE_VERTEX_COLOR\r\nin vec4 vVertexColor;\r\n#endif\n\nout vec4 outColor;\n\n#include <alpha_test>\n\nvoid main() {\r\n    vec2 uv = vUv * uBaseMapTiling.xy + uBaseMapTiling.zw;\r\n  \r\n    \n    vec4 baseMapColor = texture(uBaseMap, uv);\r\n    \r\n    vec4 baseColor = vec4(0.);\n\n#ifdef USE_VERTEX_COLOR\r\n    baseColor = vVertexColor * uColor * baseMapColor;\r\n#else\r\n    baseColor = uColor * baseMapColor;\r\n#endif   \n\n    \n    vec4 resultColor = baseColor;\n\n    \n    #ifdef USE_ALPHA_TEST\ncheckAlphaTest(resultColor, uAlphaTestThreshold);\n#endif\n\n    outColor = vec4(1., 1., 1., 1.);\r\n}";function xr(e,n,t,r){return{e:new Float32Array([e,n,t,r])}}function Tr(e){const{vertexShaderModifiers:n=[],uniforms:t=[],...o}=e,i=e.baseColor||mr(),l=e.baseMap||null,s=e.baseMapTiling||xr(1,1,0,0),u=e.metallic||0,c=e.metallicMap||null,m=e.metallicMapTiling||xr(1,1,0,0),f=void 0!==e.roughness?e.roughness:0,p=e.roughnessMap||null,d=e.roughnessMapTiling||xr(1,1,0,0),g=e.normalMap||null,h=e.normalMapTiling||xr(1,1,0,0),v=e.emissiveColor||fr(),x=e.shadingModelId||r.Lit,T=[{name:S.BaseColor,type:y.Color,value:i||mr()},{name:S.BaseMap,type:y.Texture,value:l||null},{name:S.BaseMapTiling,type:y.Vector4,value:s},{name:S.Metallic,type:y.Float,value:u},{name:S.MetallicMap,type:y.Texture,value:c},{name:S.MetallicMapTiling,type:y.Vector4,value:m},{name:S.Roughness,type:y.Float,value:f},{name:S.RoughnessMap,type:y.Texture,value:p},{name:S.RoughnessMapTiling,type:y.Vector4,value:d},{name:S.MetallicMap,type:y.Texture,value:c},{name:S.MetallicMapTiling,type:y.Vector4,value:m},{name:S.NormalMap,type:y.Texture,value:g},{name:S.NormalMapTiling,type:y.Vector4,value:h},{name:S.EmissiveColor,type:y.Color,value:v},{name:S.ShadingModelId,type:y.Int,value:x},...t||[]],C=[{name:S.BaseMap,type:y.Texture,value:l},{name:S.BaseMapTiling,type:y.Vector4,value:s}];return{...ar({...o,name:"GBufferMaterial",vertexShader:gr,fragmentShader:e.fragmentShader||hr,depthFragmentShader:e.depthFragmentShader||vr,vertexShaderModifiers:n,uniforms:T,depthUniforms:C,useNormalMap:!!g,depthTest:!0,depthWrite:!1,depthFuncType:a.Equal,uniformBlockNames:[b.Common,b.Transformations,b.Camera]}),baseColor:i,baseMap:l,baseMapTiling:s,metallic:u,metallicMap:c,metallicMapTiling:m,roughness:f,roughnessMap:p,roughnessMapTiling:d,normalMap:g,normalMapTiling:h,emissiveColor:v,vertexShaderModifiers:n}}async function yr(e){return new Promise(((n,t)=>{const r=new Image;r.onload=()=>{n(r)},r.onerror=()=>{t(r)},r.src=e}))}function Sr({name:e,meshType:n,geometry:t,material:r,materials:a=[],depthMaterial:o,depthMaterials:i=[],type:l,castShadow:c=!1,instanced:m=!1,autoGenerateDepthMaterial:f=!0,renderEnabled:p=!0}){return a=r?[r]:a||[],i=o?[o]:i||[],c=!!c,m=!!m,f=!!f,p=!!p,{...Tl({name:e,type:void 0!==l?l:s.Mesh}),meshType:n??u.Default,geometry:t,materials:a,depthMaterials:i,castShadow:c,instanced:m,autoGenerateDepthMaterial:f,renderEnabled:p}}function br({name:e,cameraType:n,clearColor:t=xr(0,0,0,1),postProcess:r=null}){return{...Tl({name:e,type:s.Camera}),clearColor:t,postProcess:r,cameraType:n,viewMatrix:at(),projectionMatrix:at(),viewProjectionMatrix:at(),inverseViewProjectionMatrix:at(),inverseViewMatrix:at(),inverseProjectionMatrix:at(),renderTarget:null,near:1,far:10,visibleFrustum:!1,visibleFrustumMesh:null}}function Cr(e){const n=e;n.projectionMatrix=function(e,n,t,r){const a=1/Math.tan(e/2),o=at();if(zn(o,a/n),Hn(o,0),Jn(o,0),Qn(o,0),jn(o,0),$n(o,a),Yn(o,0),et(o,0),Gn(o,0),Xn(o,0),nt(o,-1),Wn(o,0),qn(o,0),tt(o,0),null!=r&&r!==1/0){const e=1/(t-r);Kn(o,(r+t)*e),Zn(o,2*r*t*e)}else Kn(o,-1),Zn(o,-2*t);return o}(n.fov*Math.PI/180,n.aspect,n.near,n.far)}function Mr({gpu:e,name:n,renderTargetKind:t,type:r,width:a,height:o,useDepthBuffer:i,writeDepthTexture:s,minFilter:u,magFilter:c,wrapT:m,wrapS:g,mipmap:x,depthPrecision:T}){n=n??"",t=t??h.Default,r=r??v.RGBA,a=a??1,o=o??1,i=i??!1,s=s??!1,u=u??d.Linear,c=c??d.Linear,m=m??p.ClampToEdge,g=g??p.ClampToEdge,x=x??!1;const y=e.gl,S=Ve({gpu:e});let b=null,C=null,M=null;ze(S),i&&(b=function(e,n,t,r){const a=e.gl,o=a.createRenderbuffer();return a.bindRenderbuffer(a.RENDERBUFFER,o),n===l.Depth&&a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,t,r),a.bindRenderbuffer(a.RENDERBUFFER,null),{...Ie(e,o),type:n}}(e,l.Depth,a,o)),b&&y.framebufferRenderbuffer(B,xe,Te,b.glObject);const P=`${n}/texture`;switch(r){case v.RGBA:C=ke({gpu:e,name:P,width:a,height:o,mipmap:x,type:f.RGBA,minFilter:u,magFilter:c,wrapS:g,wrapT:m}),y.framebufferTexture2D(B,Le.COLOR_ATTACHMENT0,D,C.glObject,0);break;case v.RGBA16F:Qe(e,R),C=ke({gpu:e,name:P,width:a,height:o,mipmap:x,type:f.RGBA16F,minFilter:u,magFilter:c,wrapS:g,wrapT:m}),y.framebufferTexture2D(B,Le.COLOR_ATTACHMENT0,D,C.glObject,0);break;case v.R11F_G11F_B10F:Qe(e,R),C=ke({gpu:e,name:P,width:a,height:o,mipmap:x,type:f.R11F_G11F_B10F,minFilter:u,magFilter:c,wrapS:g,wrapT:m}),y.framebufferTexture2D(B,Le.COLOR_ATTACHMENT0,D,C.glObject,0);break;case v.R16F:C=ke({gpu:e,name:P,width:a,height:o,mipmap:x,type:f.R16F,minFilter:u,magFilter:c,wrapS:g,wrapT:m}),y.framebufferTexture2D(B,Le.COLOR_ATTACHMENT0,D,C.glObject,0)}return C&&(y.checkFramebufferStatus(B),Ue(S,Le.COLOR_ATTACHMENT0)),(r===v.Depth||s)&&(M=ke({gpu:e,name:P,width:a,height:o,mipmap:!1,type:f.Depth,minFilter:u,magFilter:c,wrapS:g,wrapT:m,depthPrecision:T}),y.framebufferTexture2D(B,xe,D,M.glObject,0)),y.bindTexture(D,null),b&&y.bindRenderbuffer(Te,null),je(S),{...Pr(t,!1),gpu:e,name:n,type:r,width:a,height:o,framebuffer:S,depthRenderbuffer:b,texture:C,depthTexture:M}}function Pr(e,n){return{renderTargetKind:e,isSwappable:n}}const wr=(e,n,t)=>{const r=e,a=Math.floor(n),o=Math.floor(t);r.width=a,r.height=o,r.texture&&Oe(r.texture,a,o),r.depthTexture&&Oe(r.depthTexture,a,o),r.depthRenderbuffer&&function(e,n,t){const r=e.gpu.gl;r.bindRenderbuffer(r.RENDERBUFFER,e.glObject),e.type===l.Depth&&r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,n,t),r.bindRenderbuffer(r.RENDERBUFFER,null)}(r.depthRenderbuffer,a,o)};function Rr(e,n){const t=e.gpu.gl;e.texture=n,t.bindFramebuffer(B,e.framebuffer.glObject),t.framebufferTexture2D(B,Le.COLOR_ATTACHMENT0,D,e.texture.glObject,0),t.bindFramebuffer(B,null)}function Dr(e,n){const t=e.gpu.gl;e.depthTexture=n,ze(e.framebuffer),t.framebufferTexture2D(B,xe,D,e.depthTexture.glObject,0),je(e.framebuffer)}const Fr=(e,n,t)=>{const r=e;r.width=n,r.height=t,r.gBufferTextures.forEach((e=>Oe(e,n,t))),r.depthTexture&&Oe(r.depthTexture,n,t)};function Lr({gpu:e,...n}){const{attributes:t,indices:r,drawCount:a}=function(e){const n=function({calculateTangent:e,calculateBinormal:n,flipUvY:t,width:r=2,height:a=2,offset:o=Rt()}){const i=[0,0,1,0,0,1,0,0,1,0,0,1],l=r/2,s=a/2,u=new Float32Array([-l+pt(o),s+dt(o),0+gt(o),-l+pt(o),-s+dt(o),0+gt(o),l+pt(o),s+dt(o),0+gt(o),l+pt(o),-s+dt(o),0+gt(o)]),c=new Float32Array(t?[0,0,0,1,1,0,1,1]:[0,1,0,0,1,1,1,0]),m=new Float32Array(i);let f=new Float32Array,p=new Float32Array;if(e||n){const t=Ht(i);e&&(f=new Float32Array(t.tangents)),n&&(p=new Float32Array(t.binormals))}return{positions:u,uvs:c,normals:m,tangents:f,binormals:p,indices:[0,1,2,2,1,3],drawCount:6}}(e),t=[Ee({name:T.Position,data:n.positions,size:3}),Ee({name:T.Uv,data:n.uvs,size:2}),Ee({name:T.Normal,data:n.normals,size:3})];return e.calculateTangent&&t.push(Ee({name:T.Tangent,data:n.tangents,size:3})),e.calculateBinormal&&t.push(Ee({name:T.Binormal,data:n.binormals,size:3})),{attributes:t,indices:[0,1,2,2,1,3],drawCount:6}}(n);return{...$t({gpu:e,attributes:t,indices:r,drawCount:a})}}var Br="#pragma DEFINES\n\n#pragma ATTRIBUTES\r\n\nout vec2 vUv;\n\nvoid main() {\r\n    vUv = aUv;\r\n    gl_Position = vec4(aPosition, 1);\r\n}";function Er(e){return{gpu:e.gpu,name:e.name,type:e.type,width:void 0!==e.width?e.width:1,height:void 0!==e.height?e.height:1,geometry:e.geometry,materials:e.materials,enabled:void 0===e.enabled||e.enabled}}function Ir(e){const{gpu:n,type:r,vertexShader:a=Br,fragmentShader:o,rawVertexShader:i,rawFragmentShader:l,uniforms:s=[],uniformBlockNames:u=[],useEnvMap:c=!1,receiveShadow:m=!1,name:f="",renderTargetType:g=v.RGBA,minFilter:h=d.Linear,magFilter:x=d.Linear,wrapT:T=p.ClampToEdge,wrapS:b=p.ClampToEdge,srcTextureEnabled:C=!0,enabled:M}=e,P=[],w=Lr({gpu:n}),R=ar({name:f,vertexShader:a,fragmentShader:o,rawVertexShader:i,rawFragmentShader:l,uniforms:[{name:S.BlendRate,type:y.Float,value:1},...s,...Nr(),...C?[{name:S.SrcTexture,type:y.Texture,value:null}]:[]],uniformBlockNames:u,useEnvMap:!!c,receiveShadow:!!m,primitiveType:t.Triangles});P.push(R);const D=Sr({geometry:w,material:R});return{gpu:n,name:f,type:r,width:1,height:1,renderTarget:Mr({gpu:n,width:1,height:1,type:g,minFilter:h,magFilter:x,wrapS:b,wrapT:T}),mesh:D,geometry:w,material:R,materials:P,enabled:void 0===M||M}}function Ar(){return Br}function Nr(){return[{name:S.TexelSize,type:y.Float,value:1},{name:S.TargetWidth,type:y.Float,value:1},{name:S.TargetHeight,type:y.Float,value:1},{name:S.Time,type:y.Float,value:0}]}function kr(e,...n){const t=[...e];for(let r=0;r<e.length;r++)t.push(n[r]);return t}function Or(e,n=!1){const t=new Array(e).fill(0);return n?t.map(((e,n)=>n)):t}function _r(e){return[...e].filter(Boolean)}const Vr=(e=[])=>function(e){const n=e;return{value:()=>n,fill:function(...e){return kr(n,...e),this},range:function(e){return Or(e),this},compact:function(){return _r(n),this}}}(e);Vr.fill=kr,Vr.range=Or,Vr.compact=_r;const Ur="cubeMap",zr="baseIntensity",jr="specularIntensity",Gr="rotationOffset",Wr="maxLodLevel";function Hr(){return[{name:S.Skybox,type:y.Struct,value:[{name:Ur,type:y.CubeMap,value:null},{name:zr,type:y.Float,value:0},{name:jr,type:y.Float,value:0},{name:Gr,type:y.Float,value:0},{name:Wr,type:y.Float,value:0}]}]}function $r(e,n){nr(e,S.Skybox,[{name:Ur,type:y.CubeMap,value:n.cubeMap},{name:zr,type:y.Float,value:n.baseIntensity},{name:jr,type:y.Float,value:n.specularIntensity},{name:Gr,type:y.Float,value:n.rotationOffset},{name:Wr,type:y.Float,value:n.cubeMap.maxLodLevel}])}function Xr(e,n,t){return Math.min(t,Math.max(e,n))}function qr(e){const{gpu:n,fragmentShader:t,uniforms:r=[],uniformBlockNames:a=[],name:o,renderTargetType:i,srcTextureEnabled:l,enabled:s}=e;return{...Ir({gpu:n,type:17,fragmentShader:t,uniforms:r,uniformBlockNames:a,name:o,renderTargetType:i,srcTextureEnabled:l,enabled:s})}}var Jr="in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uTargetWidth;\r\nuniform float uTargetHeight;\r\nuniform float[7] uBlurWeights;\r\nuniform float uIsHorizontal;\n\nvoid main() {\r\n    vec4 textureColor = texture(uSrcTexture, vUv);\r\n    vec4 sampleColor = vec4(0.);\r\n    vec2 texelSize = vec2(1. / uTargetWidth, 1. / uTargetHeight);\n\n    const int pixelNum = 7;\r\n    float width = floor(float(pixelNum) / 2.);\r\n    for(int i = 0; i < pixelNum; i++) {\r\n        float index = float(i) - width;\r\n        float weight = uBlurWeights[i];\r\n        \n        sampleColor += texture(\r\n            uSrcTexture,\r\n            vUv + vec2(\r\n                step(.5, uIsHorizontal) > .5 ? index : 0.,\r\n                step(.5, uIsHorizontal) > .5 ? 0. : index\r\n            ) * texelSize\r\n        ) * weight;\r\n    }\r\n    \r\n    outColor = sampleColor;\r\n    \r\n    \n    \n}";const Yr="uBlurWeights",Kr="uIsHorizontal",Zr="uBlur4Texture",Qr="uBlur8Texture",ea="uBlur16Texture",na="uBlur32Texture",ta="uBlur64Texture",ra="uTone",aa="uBloomAmount",oa="uThreshold",ia="uExtractTexture";function la(e,n,t,r,a,o){const i=e.width/o,l=e.height/o;mi(n,t,!0),nr(e.horizontalBlurMaterial,S.SrcTexture,a.texture),nr(e.horizontalBlurMaterial,S.TargetWidth,i),nr(e.horizontalBlurMaterial,S.TargetHeight,i),fi(n,e.geometry,e.horizontalBlurMaterial),mi(n,r,!0),nr(e.verticalBlurMaterial,S.SrcTexture,t.texture),nr(e.verticalBlurMaterial,S.TargetWidth,i),nr(e.verticalBlurMaterial,S.TargetHeight,l),fi(n,e.geometry,e.verticalBlurMaterial)}const sa="uScale",ua="uPower";function ca(e,n){return{e:new Float32Array([e,n])}}const ma=e=>e.e[0],fa=e=>e.e[1],pa=(e,n)=>e.e[0]=n,da=(e,n)=>e.e[1]=n,ga=(e,n,t)=>{pa(e,n),da(e,t)};function ha(){return ca(0,0)}function va(e,n){return pa(e,ma(n)),da(e,fa(n)),e}const xa="uCocTexture",Ta="uDofTexture",ya="uFogColor",Sa="uFogStrength",ba="uFogDensity",Ca="uFogDensityAttenuation",Ma="uFogEndHeight",Pa="uDistanceFogStart",wa="uDistanceFogEnd",Ra="uDistanceFogPower",Da="uSSSFogRate",Fa="uSSSFogColor",La="uNoiseTexture",Ba="uLightShaftTexture",Ea="uVolumetricLightTexture",Ia="uSSSTexture",Aa=S.BlendRate;var Na="in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform vec2 uRadialBlurOrigin; \nuniform float uRadialBlurPassScaleBase;\r\nuniform float uRadialBlurPassIndex;\r\nuniform float uRadialBlurRayStepStrength;\n\nconst int sampleCount = 12;\n\nvoid main() {\r\n    vec4 resultColor = texture(uSrcTexture, vUv);\r\n    outColor = resultColor;\r\n        \r\n    \n    \n    vec2 blurCenter = uRadialBlurOrigin;\r\n   \r\n    \n    float passScale = pow(uRadialBlurPassScaleBase * float(sampleCount), uRadialBlurPassIndex);\n\n    vec2 currentToCenter = (blurCenter - vUv) * passScale;\r\n    float totalWeight = 0.;\r\n    vec4 destColor = vec4(0.);\n\n    \n    float strength = uRadialBlurRayStepStrength;\r\n    vec2 currentToCenterStep = currentToCenter * strength;\r\n    \n        \r\n    for(int i = 0; i <= sampleCount; i++) {\r\n        float fi = float(i);\r\n        float weight = (float(sampleCount) - float(i)) / float(sampleCount);\r\n        vec2 currentStep = currentToCenterStep * fi;\r\n        vec2 uv = vUv + currentStep;\r\n        uv = vec2(\r\n            clamp(uv.x, 0., 1.),\r\n            clamp(uv.y, 0., 1.)\r\n        );\r\n        \n        \n        \n        \n        destColor += texture(uSrcTexture, uv);\r\n        totalWeight += 1.;\r\n    }\r\n    \r\n    destColor /= totalWeight;\r\n  \r\n    outColor = destColor;\r\n    \r\n    \n    \r\n    \n}";const ka="uRadialBlurOrigin",Oa="uRadialBlurPassScaleBase",_a="uRadialBlurPassIndex",Va="uRadialBlurRayStepStrength";function Ua(e){return e.compositePass.renderTarget}const za="uBias",ja="uJitterSize",Ga="uSharpness",Wa="uStrength",Ha="uRayStepMultiplier",$a="uVignetteRadiusFrom",Xa="uVignetteRadiusTo",qa="uVignettePower",Ja="uBlendRate",Ya="uPrevTexture",Ka="uDownSampleTexture",Za="uStretch",Qa="uHorizontalScale",eo="uStreakTexture",no="uColor",to="uIntensity",ro="uVolumetricDepthTexture",ao="uRayStep",oo="uDensityMultiplier",io="uRayJitterSize";var lo="#include <common>\r\n#include <buffer_visualizer_h>\n\nuniform vec2 uTiling;\r\nuniform sampler2D uTextureCol0;\r\nuniform vec2 uTextureCol0UvOffset;\r\nuniform sampler2D uTextureCol1;\r\nuniform vec2 uTextureCol1UvOffset;\r\nuniform sampler2D uTextureCol2;\r\nuniform vec2 uTextureCol2UvOffset;\r\nuniform sampler2D uTextureCol3;\r\nuniform vec2 uTextureCol3UvOffset;\r\nuniform sampler2D uTextureCol4;\r\nuniform vec2 uTextureCol4UvOffset;\r\nuniform sampler2D uTextureCol5;\r\nuniform vec2 uTextureCol5UvOffset;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\r\n    vec2 tiling = uTiling;\r\n    vec4 color0 = calcTextureAreaColor(uTextureCol0, vUv, tiling, uTextureCol0UvOffset);\r\n    vec4 color1 = calcTextureAreaColor(uTextureCol1, vUv, tiling, uTextureCol1UvOffset);\r\n    vec4 color2 = calcTextureAreaColor(uTextureCol2, vUv, tiling, uTextureCol2UvOffset);\r\n    vec4 color3 = calcTextureAreaColor(uTextureCol3, vUv, tiling, uTextureCol3UvOffset);\r\n    vec4 color4 = calcTextureAreaColor(uTextureCol4, vUv, tiling, uTextureCol4UvOffset);\r\n    vec4 color5 = calcTextureAreaColor(uTextureCol5, vUv, tiling, uTextureCol5UvOffset);\r\n    outColor = color0 + color1 + color2 + color3 + color4 + color5;\r\n}";const so="depthTexture",uo="gBufferATexture",co="gBufferBTexture",mo="gBufferCTexture",fo="gBufferDTexture",po="directionalLightShadowMap",go="spotLightShadowMap",ho="screenSpaceShadowTexture",vo="ambientOcclusionTexture",xo="deferredShadingTexture",To="ssrTexture",yo="lightShaftTexture",So="volumetricLightTexture",bo="fogTexture",Co="depthOfFieldTexture",Mo="bloomBlurMip4Texture",Po="bloomBlurMip8Texture",wo="bloomBlurMip16Texture",Ro="bloomBlurMip32Texture",Do="bloomBlurMip64Texture",Fo="bloomTexture",Lo="streakPrefilterTexture",Bo="streakDownSampleMip2Texture",Eo="streakDownSampleMip4Texture",Io="streakDownSampleMip8Texture",Ao="streakDownSampleMip16Texture",No="streakDownSampleMip32Texture",ko="streakUpSample0Texture",Oo="streakUpSample1Texture",_o="streakUpSample2Texture",Vo="streakUpSample3Texture",Uo="streakUpSample4Texture",zo="streakTexture";function jo(e){e.dom.classList.remove("hidden")}function Go(e){e.dom.classList.add("hidden")}const Wo=(e,n,t)=>{const r=e;r.width=n,r.height=t;const a=Qo(r);wr(a,n,t),nr(r.material,S.TargetWidth,r.width),nr(r.material,S.TargetHeight,r.height),nr(r.material,S.TexelSize,r.width/r.height),nr(r.material,S.Aspect,r.width/r.height)},Ho={0:(e,n,t)=>{const r=e;r.width=n,r.height=t,$o(r.extractBrightnessPass,n,t),wr(r.renderTargetBlurMip4_Horizontal,n/4,t/4),wr(r.renderTargetBlurMip4_Vertical,n/4,t/4),wr(r.renderTargetBlurMip8_Horizontal,n/8,t/8),wr(r.renderTargetBlurMip8_Vertical,n/8,t/8),wr(r.renderTargetBlurMip16_Horizontal,n/16,t/16),wr(r.renderTargetBlurMip16_Vertical,n/16,t/16),wr(r.renderTargetBlurMip32_Horizontal,n/32,t/32),wr(r.renderTargetBlurMip32_Vertical,n/32,t/32),wr(r.renderTargetBlurMip64_Horizontal,n/64,t/64),wr(r.renderTargetBlurMip64_Vertical,n/64,t/64),$o(r.compositePass,n,t)},2:function(e,n,t){const r=e;r.rowPasses.forEach((({pass:e})=>{$o(e,n,t/7)})),$o(r.compositePass,n,t),r.width=n,r.height=t},1:function(e,n,t){const r=e,a=Math.floor(n),o=Math.floor(t);r.width=a,r.height=o;const i=Math.floor(a/2),l=Math.floor(o/2);$o(r.circleOfConfusionPass,i,l),$o(r.preFilterPass,i,l),$o(r.dofBokehPass,i,l),$o(r.bokehBlurPass,i,l),$o(r.compositePass,n,t)},8:function(e,n,t){const r=e,a=n*r.ratio,o=t*r.ratio;$o(r.lightShaftDownSamplePass,a,o),$o(r.blur1Pass,a,o),$o(r.blur2Pass,a,o),$o(r.blur3Pass,a,o),$o(r.compositePass,a,o),r.width=a,r.height=o},13:function(e,n,t){const r=e;r.width=n,r.height=t,r.halfHeight=Math.floor(r.height/2),$o(r.prefilterPass,r.width,r.halfHeight),$o(r.compositePass,r.width,r.height)},10:function(e,n,t){const r=e;Wo(r,n*r.ratio,t*r.ratio)},16:function(e,n,t){const r=e;r.rawWidth=n,r.rawHeight=t,r.width=Math.floor(n*r.ratio),r.height=Math.floor(t*r.ratio),Wo(r,r.width,r.height),wr(r.renderTarget,r.rawWidth,r.rawHeight),nr(r.spotLightFrustumMaterial,S.TargetWidth,r.width),nr(r.spotLightFrustumMaterial,S.TargetHeight,r.height)}};function $o(e,n,t){Ho[e.type]?Ho[e.type]?.(e,n,t):Wo(e,n,t)}const Xo={2:function(e){const n=e;n.enabled?jo(n):Go(n)}},qo={},Jo=(e,{gpu:n,targetCamera:t,renderer:r,prevRenderTarget:a,isLastPass:o})=>{const i=e;!function(e,n,t,r){mi(n,r?t.renderTarget:Qo(e),!0)}(e,r,t,o),Yi(i.mesh),e.materials.forEach((t=>{rr(t)||(or(t,{gpu:n,attributeDescriptors:on(e.geometry)}),ci(r,t))})),a&&nr(i.material,S.SrcTexture,a.texture),function(e){qo[e.type]?.(e)}(e),fi(r,e.geometry,i.material)},Yo={0:(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,gBufferRenderTargets:i,targetCamera:l,time:s})=>{const u=e;rr(u.horizontalBlurMaterial)||or(u.horizontalBlurMaterial,{gpu:n,attributeDescriptors:on(u.geometry)}),rr(u.verticalBlurMaterial)||or(u.verticalBlurMaterial,{gpu:n,attributeDescriptors:on(u.geometry)}),nr(u.extractBrightnessPass.material,oa,u.threshold),nr(u.compositePass.material,ra,u.tone),nr(u.compositePass.material,aa,u.bloomAmount),Ko(u.extractBrightnessPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:l,time:s}),la(u,r,u.renderTargetBlurMip4_Horizontal,u.renderTargetBlurMip4_Vertical,u.extractBrightnessPass.renderTarget,4),la(u,r,u.renderTargetBlurMip8_Horizontal,u.renderTargetBlurMip8_Vertical,u.renderTargetBlurMip4_Vertical,8),la(u,r,u.renderTargetBlurMip16_Horizontal,u.renderTargetBlurMip16_Vertical,u.renderTargetBlurMip8_Vertical,16),la(u,r,u.renderTargetBlurMip32_Horizontal,u.renderTargetBlurMip32_Vertical,u.renderTargetBlurMip16_Vertical,32),la(u,r,u.renderTargetBlurMip64_Horizontal,u.renderTargetBlurMip64_Vertical,u.renderTargetBlurMip32_Vertical,64),a&&nr(u.compositePass.material,S.SrcTexture,a.texture),nr(u.compositePass.material,Zr,u.renderTargetBlurMip4_Vertical.texture),nr(u.compositePass.material,Qr,u.renderTargetBlurMip8_Vertical.texture),nr(u.compositePass.material,ea,u.renderTargetBlurMip16_Vertical.texture),nr(u.compositePass.material,na,u.renderTargetBlurMip32_Vertical.texture),nr(u.compositePass.material,ta,u.renderTargetBlurMip64_Vertical.texture),nr(u.compositePass.material,ia,u.extractBrightnessPass.renderTarget.texture),Ko(u.compositePass,{gpu:n,camera:t,renderer:r,prevRenderTarget:null,isLastPass:o,targetCamera:l,gBufferRenderTargets:i,time:s})},2:function(e,n){const t=e,{gpu:r,renderer:a,lightActors:o}=n,i=a.realWidth,l=a.realHeight;t.rowPasses.forEach((({pass:n,tiles:t})=>{o?.directionalLight&&t.has(po)&&nr(n.material,t.get(po).uniformNameTexture,o.directionalLight.castShadow?o.directionalLight.shadowMap.depthTexture:e.gpu.dummyTextureBlack),o?.spotLights&&o.spotLights.forEach(((e,r)=>{const a=`${go}${r}`;t.has(a)&&e.shadowMap&&nr(n.material,t.get(a).uniformNameTexture,e.shadowMap.depthTexture)})),t.has(so)&&nr(n.material,t.get(so).uniformNameTexture,a.depthPrePassRenderTarget.depthTexture),t.has(uo)&&nr(n.material,t.get(uo).uniformNameTexture,a.gBufferRenderTargets.gBufferATexture),t.has(co)&&nr(n.material,t.get(co).uniformNameTexture,a.gBufferRenderTargets.gBufferBTexture),t.has(mo)&&nr(n.material,t.get(mo).uniformNameTexture,a.gBufferRenderTargets.gBufferCTexture),t.has(fo)&&nr(n.material,t.get(fo).uniformNameTexture,a.gBufferRenderTargets.gBufferDTexture),t.has(ho)&&nr(n.material,t.get(ho).uniformNameTexture,a.screenSpaceShadowPass.renderTarget.texture),t.has(vo)&&nr(n.material,t.get(vo).uniformNameTexture,a.ambientOcclusionPass.renderTarget.texture),t.has(xo)&&nr(n.material,t.get(xo).uniformNameTexture,a.deferredShadingPass.renderTarget.texture),t.has(To)&&nr(n.material,t.get(To).uniformNameTexture,a.ssrPass.renderTarget.texture),t.has(yo)&&nr(n.material,t.get(yo).uniformNameTexture,Qo(a.lightShaftPass).texture),t.has(So)&&nr(n.material,t.get(So).uniformNameTexture,a.volumetricLightPass.renderTarget.texture),t.has(Co)&&nr(n.material,t.get(Co).uniformNameTexture,Qo(a.depthOfFieldPass).texture),t.has(bo)&&nr(n.material,t.get(bo).uniformNameTexture,a.fogPass.renderTarget.texture),t.has(Lo)&&nr(n.material,t.get(Lo).uniformNameTexture,a.streakPass.prefilterPass.renderTarget.texture),t.has(Bo)&&nr(n.material,t.get(Bo).uniformNameTexture,a.streakPass.downSamplePasses[0].pass.renderTarget.texture),t.has(Eo)&&nr(n.material,t.get(Eo).uniformNameTexture,a.streakPass.downSamplePasses[1].pass.renderTarget.texture),t.has(Io)&&nr(n.material,t.get(Io).uniformNameTexture,a.streakPass.downSamplePasses[2].pass.renderTarget.texture),t.has(Ao)&&nr(n.material,t.get(Ao).uniformNameTexture,a.streakPass.downSamplePasses[3].pass.renderTarget.texture),t.has(No)&&nr(n.material,t.get(No).uniformNameTexture,a.streakPass.downSamplePasses[4].pass.renderTarget.texture),t.has(ko)&&nr(n.material,t.get(ko).uniformNameTexture,a.streakPass.upSamplePasses[0].pass.renderTarget.texture),t.has(Oo)&&nr(n.material,t.get(Oo).uniformNameTexture,a.streakPass.upSamplePasses[1].pass.renderTarget.texture),t.has(_o)&&nr(n.material,t.get(_o).uniformNameTexture,a.streakPass.upSamplePasses[2].pass.renderTarget.texture),t.has(Vo)&&nr(n.material,t.get(Vo).uniformNameTexture,a.streakPass.upSamplePasses[3].pass.renderTarget.texture),t.has(Uo)&&nr(n.material,t.get(Uo).uniformNameTexture,a.streakPass.upSamplePasses[4].pass.renderTarget.texture),t.has(zo)&&nr(n.material,t.get(zo).uniformNameTexture,Qo(a.streakPass).texture),t.has(Mo)&&nr(n.material,t.get(Mo).uniformNameTexture,a.bloomPass.renderTargetBlurMip4_Vertical.texture),t.has(Po)&&nr(n.material,t.get(Po).uniformNameTexture,a.bloomPass.renderTargetBlurMip8_Vertical.texture),t.has(wo)&&nr(n.material,t.get(wo).uniformNameTexture,a.bloomPass.renderTargetBlurMip16_Vertical.texture),t.has(Ro)&&nr(n.material,t.get(Ro).uniformNameTexture,a.bloomPass.renderTargetBlurMip32_Vertical.texture),t.has(Do)&&nr(n.material,t.get(Do).uniformNameTexture,a.bloomPass.renderTargetBlurMip64_Vertical.texture),t.has(Fo)&&nr(n.material,t.get(Fo).uniformNameTexture,Qo(a.bloomPass).texture)})),nr(t.rowPasses[0].pass.material,"uInverseViewProjectionMatrix",n.targetCamera.inverseViewProjectionMatrix),Ke(r,0,0,t.width,t.height/7),t.rowPasses.forEach((({pass:e,tiles:r},a)=>{r.size>0&&(Ko(e,{...n,isLastPass:!1}),nr(t.compositePass.material,`uRow${a}Texture`,e.renderTarget.texture))})),nr(t.compositePass.material,"uFullViewTexture",a.gBufferRenderTargets.gBufferATexture),nr(t.compositePass.material,"uFullViewTextureEnabled",t.fullViewTextureEnabled?1:0),Ke(r,0,0,i,l),Ko(t.compositePass,{...n})},3:function(e,n){const t=e;nr(t.material,sa,t.scale),nr(t.material,ua,t.power),Jo(t,n)},18:function(e,n){const t=e;nr(t.material,ya,t.fogColor),nr(t.material,Sa,t.fogStrength),nr(t.material,ba,t.fogDensity),nr(t.material,Ca,t.fogDensityAttenuation),nr(t.material,Ma,t.fogEndHeight),nr(t.material,Pa,t.distanceFogStart),nr(t.material,wa,t.distanceFogEnd),nr(t.material,Ra,t.distanceFogPower),nr(t.material,Da,t.sssFogRate),nr(t.material,Fa,t.sssFogColor),nr(t.material,S.BlendRate,t.blendRate),Jo(t,n)},1:function(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,gBufferRenderTargets:i,targetCamera:l,time:s}){const u=e;nr(u.circleOfConfusionPass.material,"uFocusDistance",u.focusDistance),nr(u.circleOfConfusionPass.material,"uFocusRange",u.focusRange),nr(u.circleOfConfusionPass.material,"uBokehRadius",u.bokehRadius),Ko(u.circleOfConfusionPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),nr(u.preFilterPass.material,xa,u.circleOfConfusionPass.renderTarget.texture),nr(u.preFilterPass.material,S.TexelSize,ca(1/u.preFilterPass.width,1/u.preFilterPass.height)),Ko(u.preFilterPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),nr(u.dofBokehPass.material,"uTexelSize",ca(1/u.preFilterPass.width,1/u.preFilterPass.height)),nr(u.dofBokehPass.material,"uBokehRadius",u.bokehRadius),Ko(u.dofBokehPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:u.preFilterPass.renderTarget,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),nr(u.bokehBlurPass.material,"uTexelSize",ca(1/u.dofBokehPass.width,1/u.dofBokehPass.height)),nr(u.bokehBlurPass.material,"uBokehRadius",u.bokehRadius),Ko(u.bokehBlurPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:u.dofBokehPass.renderTarget,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),nr(u.compositePass.material,xa,u.circleOfConfusionPass.renderTarget.texture),nr(u.compositePass.material,Ta,u.bokehBlurPass.renderTarget.texture),Ko(u.compositePass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,targetCamera:l,gBufferRenderTargets:i,time:s})},5:function(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,targetCamera:i,gBufferRenderTargets:l,time:s}){const u=e;Ko(u.horizontalBlurPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:i,gBufferRenderTargets:l,time:s}),Ko(u.verticalBlurPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,targetCamera:i,gBufferRenderTargets:l,time:s})},4:function(e,n){const t=e;nr(t.material,Aa,t.blendRate),Jo(t,n)},8:function(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,gBufferRenderTargets:i,targetCamera:l,time:s}){const u=e;Ko(u.lightShaftDownSamplePass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s});const c=Bi(l,Mt(Pt(u.directionalLight.transform.position),1e4)),m=ca(.5*pt(c)+.5,.5*dt(c)+.5);nr(u.blur1Pass.material,ka,m),nr(u.blur1Pass.material,Oa,u.passScaleBase),nr(u.blur1Pass.material,Va,u.rayStepStrength),nr(u.blur2Pass.material,ka,m),nr(u.blur2Pass.material,Oa,u.passScaleBase),nr(u.blur2Pass.material,Va,u.rayStepStrength),nr(u.blur3Pass.material,ka,m),nr(u.blur3Pass.material,Oa,u.passScaleBase),nr(u.blur3Pass.material,Va,u.rayStepStrength),Ko(u.blur1Pass,{gpu:n,camera:t,renderer:r,prevRenderTarget:u.lightShaftDownSamplePass.renderTarget,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),Ko(u.blur2Pass,{gpu:n,camera:t,renderer:r,prevRenderTarget:u.blur1Pass.renderTarget,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),Ko(u.blur3Pass,{gpu:n,camera:t,renderer:r,prevRenderTarget:u.blur2Pass.renderTarget,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),nr(u.compositePass.material,"uLightShaftTexture",u.blur3Pass.renderTarget.texture),nr(u.compositePass.material,S.BlendRate,u.blendRate),Ko(u.compositePass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,targetCamera:l,gBufferRenderTargets:i,time:s})},10:function(e,n){const t=e;nr(t.material,za,t.bias),nr(t.material,ja,t.jitterSize),nr(t.material,Ga,t.sharpness),nr(t.material,Wa,t.strength),nr(t.material,Ha,t.rayStepMultiplier),Jo(t,n)},11:function(e,n){const t=e;nr(t.material,"uOcclusionSampleLength",t.occlusionSampleLength),nr(t.material,"uOcclusionBias",t.occlusionBias),nr(t.material,"uOcclusionMinDistance",t.occlusionMinDistance),nr(t.material,"uOcclusionMaxDistance",t.occlusionMaxDistance),nr(t.material,"uOcclusionColor",t.occlusionColor),nr(t.material,"uOcclusionPower",t.occlusionPower),nr(t.material,"uOcclusionStrength",t.occlusionStrength),nr(t.material,"uBlendRate",t.blendRate),nr(t.material,"uSamplingTexture",t.samplingTexture),Jo(t,n)},12:function(e,n){const t=e;nr(t.material,"uRayDepthBias",t.rayDepthBias),nr(t.material,"uRayNearestDistance",t.rayNearestDistance),nr(t.material,"uRayMaxDistance",t.rayMaxDistance),nr(t.material,"uReflectionRayThickness",t.reflectionRayThickness),nr(t.material,"uReflectionRayJitterSizeX",t.reflectionRayJitterSizeX),nr(t.material,"uReflectionRayJitterSizeY",t.reflectionRayJitterSizeY),nr(t.material,"uReflectionFadeMinDistance",t.reflectionFadeMinDistance),nr(t.material,"uReflectionFadeMaxDistance",t.reflectionFadeMaxDistance),nr(t.material,"uReflectionScreenEdgeFadeFactorMinX",t.reflectionScreenEdgeFadeFactorMinX),nr(t.material,"uReflectionScreenEdgeFadeFactorMaxX",t.reflectionScreenEdgeFadeFactorMaxX),nr(t.material,"uReflectionScreenEdgeFadeFactorMinY",t.reflectionScreenEdgeFadeFactorMinY),nr(t.material,"uReflectionScreenEdgeFadeFactorMaxY",t.reflectionScreenEdgeFadeFactorMaxY),nr(t.material,"uReflectionAdditionalRate",t.reflectionAdditionalRate),nr(t.material,"uReflectionRoughnessPower",t.reflectionRoughnessPower),nr(t.material,"uBlendRate",t.blendRate),Jo(t,n)},13:function(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,gBufferRenderTargets:i,targetCamera:l,time:s}){const u=e;nr(u.prefilterPass.material,"uTexelSize",ca(1/u.width,1/u.height)),nr(u.prefilterPass.material,"uThreshold",u.threshold),nr(u.prefilterPass.material,"uVerticalScale",u.verticalScale),Ko(u.prefilterPass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s}),u.downSamplePasses.forEach((({pass:e,prevPass:a,downScale:o})=>{const c=Math.floor(u.width/o);$o(e,c,u.halfHeight),nr(e.material,S.TexelSize,ca(1/c,1/u.halfHeight)),nr(e.material,Ya,a.renderTarget.texture),nr(e.material,Qa,u.horizontalScale),Ko(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:null,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s})})),u.upSamplePasses.forEach((({pass:e,prevPass:a,downSamplePass:o})=>{$o(e,o.width,o.height),nr(e.material,Ya,a.renderTarget.texture),nr(e.material,Ka,o.renderTarget.texture),nr(e.material,Za,u.stretch),Ko(e,{gpu:n,camera:t,renderer:r,prevRenderTarget:null,isLastPass:!1,targetCamera:l,gBufferRenderTargets:i,time:s})})),nr(u.compositePass.material,eo,u.upSamplePasses[u.upSamplePasses.length-1].pass.renderTarget.texture),nr(u.compositePass.material,no,u.color),nr(u.compositePass.material,to,u.intensity),Ko(u.compositePass,{gpu:n,camera:t,renderer:r,prevRenderTarget:a,isLastPass:o,targetCamera:l,gBufferRenderTargets:i,time:s})},15:function(e,n){const t=e;nr(t.material,$a,t.vignetteRadiusFrom),nr(t.material,Xa,t.vignetteRadiusTo),nr(t.material,qa,t.vignettePower),nr(t.material,Ja,t.blendRate),Jo(e,n)},16:function(e,n){const t=e,{gpu:r,renderer:a}=n;if(!rr(t.spotLightFrustumMaterial)&&t.spotLights.length>0){const e=t.spotLights[0].shadowCamera?.visibleFrustumMesh?.geometry;or(t.spotLightFrustumMaterial,{gpu:r,attributeDescriptors:on(e)})}mi(a,t.renderTargetSpotLightFrustum,!1,!0),nr(t.spotLightFrustumMaterial,S.ViewMatrix,n.targetCamera.viewMatrix),nr(t.spotLightFrustumMaterial,S.ProjectionMatrix,n.targetCamera.projectionMatrix),t.spotLights.forEach((e=>{e.shadowCamera&&null!==e.shadowCamera.visibleFrustumMesh&&(nr(t.spotLightFrustumMaterial,S.WorldMatrix,e.shadowCamera.transform.worldMatrix),fi(a,e.shadowCamera.visibleFrustumMesh.geometry,t.spotLightFrustumMaterial))})),nr(t.material,S.SpotLightShadowMap,t.spotLights.map((e=>e.shadowMap?e.shadowMap?.depthTexture:null))),nr(t.material,ro,t.renderTargetSpotLightFrustum.depthTexture),nr(t.material,ao,t.rayStep),nr(t.material,oo,t.densityMultiplier),nr(t.material,io,t.rayJitterSize),nr(t.material,S.BlendRate,t.blendRate),Jo(t,n)}};function Ko(e,n){Yo[e.type]?Yo[e.type]?.(e,n):Jo(e,n)}const Zo={0:function(e){return e.compositePass.renderTarget},2:function(e){return e.compositePass.renderTarget},1:function(e){return e.compositePass.renderTarget},8:Ua,13:function(e){return e.compositePass.renderTarget}};function Qo(e){return Zo[e.type]?(0,Zo[e.type])(e):e.renderTarget}function ei(e){return Math.cos(e*n)}function ni(e){return ei(e.coneAngle)}function ti(e){return ei(e.penumbraAngle)}var ri="#include <common>\r\n#include <rand>\r\n#include <etex>\n\nuniform float uTiling;\r\nuniform float uIsImproved;\n\nfloat smooth5(float t) {\r\n    float t3 = t * t * t;\r\n    float t4 = t * t * t * t;\r\n    float t5 = t * t * t * t * t;\r\n    return 6. * t5 - 15. * t4 + 10. * t3;\r\n}\n\nfloat perlinNoise(vec2 p, float isImproved) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\n\n    \n    vec2 i00 = i;\r\n    vec2 i10 = i + vec2(1., 0.);\r\n    vec2 i01 = i + vec2(0., 1.);\r\n    vec2 i11 = i + vec2(1., 1.);\r\n   \r\n    \n    \n    vec2 p00 = f;\r\n    vec2 p10 = f - vec2(1., 0.);\r\n    vec2 p01 = f - vec2(0., 1.);\r\n    vec2 p11 = f - vec2(1., 1.);\r\n    \r\n    \n    \n    vec2 g00 = normalize(rand2(i00));\r\n    vec2 g10 = normalize(rand2(i10));\r\n    vec2 g01 = normalize(rand2(i01));\r\n    vec2 g11 = normalize(rand2(i11));\n\n    \n    float n00 = dot(g00, p00);\r\n    float n10 = dot(g10, p10);\r\n    float n01 = dot(g01, p01);\r\n    float n11 = dot(g11, p11);\r\n   \r\n    \n    isImproved = step(.5, isImproved);\r\n    float sx = mix(smooth(f.x), smooth5(f.x), isImproved);\r\n    float sy = mix(smooth(f.y), smooth5(f.y), isImproved);\r\n   \r\n    \n    float mx0 = mix(n00, n10, sx);\r\n    \r\n    \n    float mx1 = mix(n01, n11, sx);\r\n   \r\n    \n    return mix(mx0, mx1, sy);\r\n}\n\nvoid main() {\r\n    vec2 resolution = uResolution;\r\n    vec2 gridSize = uGridSize;\r\n    vec2 uv = vUv;\n\n    float result = perlinNoise(uv * gridSize + uTime, uIsImproved);\n\n    outColor = vec4(vec3(result), 1.);\r\n}";const ai="uGridSize",oi=1024,ii=[{key:4,width:oi,height:oi,effectFragmentShader:"#include <common>\r\n#include <rand>\r\n#include <etex>\r\n\nfloat noise(vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\n\n    \n    float a = rand(i);\r\n    float b = rand(i + vec2(1.0, 0.0));\r\n    float c = rand(i + vec2(0.0, 1.0));\r\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\r\n    (c - a)* u.y * (1.0 - u.x) +\r\n    (d - b) * u.x * u.y;\r\n}\n\nuniform float uOctaves;\r\nuniform float uAmplitude;\r\nuniform float uFrequency;\r\nuniform float uFactor;\r\n\nfloat fbmNoise(in vec2 p) {\r\n    float g = exp2(-uFactor);\r\n    float f = uFrequency;\r\n    float a = uAmplitude;\r\n    float t = 0.;\r\n    int octaves = int(uOctaves);\r\n    for(int i = 0; i < octaves; i++) {\r\n        t += a * noise(p * f);\r\n        f *= 2.;\r\n        a *= g;\r\n    }\r\n    return t;\r\n}\n\nvoid main() {\r\n    vec2 resolution = uResolution;\r\n    vec2 gridSize = uGridSize;\r\n    vec2 uv = vUv;\n\n    float result = fbmNoise(uv * gridSize + uTime);\n\n    outColor = vec4(vec3(result), 1.);\r\n}",effectUniforms:[{name:S.Time,type:y.Float,value:0},{name:ai,type:y.Vector2,value:ca(4.4,4.4)},{name:"uOctaves",type:y.Float,value:8},{name:"uAmplitude",type:y.Float,value:.307},{name:"uFrequency",type:y.Float,value:1.357},{name:"uFactor",type:y.Float,value:.597}],tilingEnabled:!0,edgeMaskMix:1,remapMin:0,remapMax:1},{key:0,width:oi,height:oi,effectFragmentShader:"#include <common>\r\n#include <rand>\r\n#include <etex>\n\nuniform float uTiling;\r\n\nconst float PHI = 1.61803398874989484820459; \n\nfloat goldNoise(in vec2 xy, in float seed) {\r\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\r\n}\r\n\nvoid main() {\r\n    vec2 resolution = uResolution;\r\n    vec2 gridSize = uGridSize;\r\n    vec2 uv = vUv;\n\n    \n    float result = goldNoise(floor(uv * gridSize) + uTime, 1.);\r\n    \r\n    outColor = vec4(vec3(result), 1.);\r\n}",effectUniforms:[{name:S.Time,type:y.Float,value:0},{name:ai,type:y.Vector2,value:ca(oi,oi)}],tilingEnabled:!0,edgeMaskMix:1,remapMin:0,remapMax:1},{key:1,width:oi,height:oi,effectFragmentShader:ri,effectUniforms:[{name:S.Time,type:y.Float,value:0},{name:ai,type:y.Vector2,value:ca(4,4)},{name:"uIsImproved",type:y.Float,value:0}],tilingEnabled:!0,edgeMaskMix:1,remapMin:0,remapMax:1},{key:2,width:oi,height:oi,effectFragmentShader:ri,effectUniforms:[{name:S.Time,type:y.Float,value:0},{name:ai,type:y.Vector2,value:ca(4,4)},{name:"uIsImproved",type:y.Float,value:1}],tilingEnabled:!0,edgeMaskMix:1,remapMin:0,remapMax:1},{key:3,width:oi,height:oi,effectFragmentShader:"#include <common>\r\n#include <rand>\r\n#include <etex>\n\nuniform float uTiling;\n\nfloat snoise(vec2 v) {\n\n    \n    const vec4 C = vec4(\r\n        0.211324865405187,\r\n        \n        0.366025403784439,\r\n        \n        -0.577350269189626,\r\n        \n        0.024390243902439\r\n    );\r\n    \n\n    \n    vec2 i  = floor(v + dot(v, C.yy));\r\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    \n    vec2 i1 = vec2(0.0);\r\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\r\n    vec2 x1 = x0.xy + C.xx - i1;\r\n    vec2 x2 = x0.xy + C.zz;\n\n    \n    \n    i = mod289(i);\r\n    vec3 p = permute(\r\n        permute( i.y + vec3(0.0, i1.y, 1.0))\r\n        + i.x + vec3(0.0, i1.x, 1.0)\r\n    );\n\n    vec3 m = max(\r\n    0.5 - vec3(\r\n        dot(x0,x0),\r\n        dot(x1,x1),\r\n        dot(x2,x2)\r\n    ),\r\n    0.0\r\n    );\n\n    m = m * m;\r\n    m = m * m;\n\n    \n    \n    \n    \n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\n\n    \n    \n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    \n    vec3 g = vec3(0.0);\r\n    g.x  = a0.x * x0.x + h.x * x0.y;\r\n    g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);\n\n    return 130.0 * dot(m, g);\r\n}\n\nvoid main() {\r\n    vec2 resolution = uResolution;\r\n    vec2 gridSize = uGridSize;\r\n    vec2 uv = vUv;\n\n    float result = snoise(uv * gridSize + uTime);\n\n    outColor = vec4(vec3(result), 1.);\r\n}",effectUniforms:[{name:S.Time,type:y.Float,value:0},{name:ai,type:y.Vector2,value:ca(4,4)}],tilingEnabled:!0,edgeMaskMix:1,remapMin:0,remapMax:1}],li=(e,n,t,r)=>{mi(e,t,!0),fi(e,n,r),mi(e,null)},si=(e,n,t)=>{er(n.effectMaterial.uniforms,S.Time,t),li(e,n.planeGeometry,n.effectRenderTarget,n.effectMaterial),li(e,n.planeGeometry,n.compositeRenderTarget,n.compositeMaterial)};function ui(n,t,r){nr(n,S.DirectionalLightShadowMap,t.directionalLight&&t.directionalLight.shadowMap?t.directionalLight.shadowMap.depthTexture:r);const a=Vr.range(e).map(((e,n)=>{const a=t.spotLights[n];return a&&a.shadowMap?a.shadowMap.depthTexture:r}));nr(n,S.SpotLightShadowMap,a)}function ci(e,n){n.boundUniformBufferObjects||(n.boundUniformBufferObjects=!0,n.uniformBlockNames.forEach((t=>{const r=e.globalUniformBufferObjects.find((({uniformBufferObject:e})=>e.blockName===t));if(!r)return;const a=function(e,n,t,r){const a=e.gl.getUniformBlockIndex(t.glObject,r);return e.gl.uniformBlockBinding(t.glObject,a,n.bindingPoint),a}(e.gpu,r.uniformBufferObject,n.shader,t);((e,n,t,r)=>{e.uniformBlocks.push({blockIndex:n,uniformBufferObject:t,data:[]})})(n.uniforms,a,r.uniformBufferObject)})))}function mi(e,n,t=!1,r=!1){n?(e.renderTarget=n,Ze(e.gpu,n.framebuffer),Ke(e.gpu,0,0,n.width,n.height)):(e.renderTarget=null,Ze(e.gpu,null),Ke(e.gpu,0,0,e.realWidth,e.realHeight)),t?(function(e,n,t,r,a){const o=e.gl;o.depthMask(!1),o.colorMask(!0,!0,!0,!0),o.clearColor(0,0,0,0),o.clear(I)}(e.gpu),e.clearColorDirtyFlag=!0):e.clearColorDirtyFlag=!1,r&&function(e,n,t,r,a){const o=e.gl;o.depthMask(!0),o.colorMask(!1,!1,!1,!1),o.clearColor(1,1,1,1),o.clear(E)}(e.gpu)}function fi(e,n,r){if(e.stats&&(sn(e.stats,n),un(e.stats)),function(e,n){e.vao=n}(e.gpu,n.vertexArrayObject),!r.shader)return;let i;if(function(e,n){e.shader=n}(e.gpu,r.shader),function(e,n){e.uniforms=n}(e.gpu,r.uniforms),null!==r.depthWrite)i=r.depthWrite;else switch(r.blendType){case o.Opaque:i=!0;break;case o.Transparent:case o.Additive:i=!1;break;default:return}!function(e,n,r,i,l,s,u,c,f,p=0){const d=function(e){switch(e){case t.Points:return A;case t.Lines:return N;case t.LineLoop:return k;case t.LineStrip:return O;case t.Triangles:return _;default:return-1}}(r),g=e.gl;if(e.shader&&e.vao){switch(c){case m.Front:g.enable(V),g.cullFace(U),g.frontFace(z);break;case m.Back:g.enable(V),g.cullFace(j),g.frontFace(z);break;case m.Double:g.disable(V),g.frontFace(z)}if(g.depthMask(l),i)switch(g.enable(g.DEPTH_TEST),s){case a.Never:g.depthFunc(G);break;case a.Less:g.depthFunc(W);break;case a.Equal:g.depthFunc(H);break;case a.Lequal:g.depthFunc($);break;case a.Greater:g.depthFunc(X);break;case a.NotEqual:g.depthFunc(q);break;case a.Gequal:g.depthFunc(J);break;case a.Always:g.depthFunc(Y)}else g.disable(K);switch(u){case o.Opaque:g.disable(Z);break;case o.Transparent:g.enable(Z),g.blendFunc(Q,ee);break;case o.Additive:g.enable(Z),g.blendFunc(Q,ne)}g.useProgram(e.shader.glObject),function(e){const n=e.gl;let t=0;if(!e.shader)return;const r=(r,a,o)=>{const i=n.getUniformLocation(e.shader.glObject,a);switch(r){case y.Int:n.uniform1i(i,o);break;case y.Float:n.uniform1f(i,o);break;case y.FloatArray:n.uniform1fv(i,o);break;case y.Vector2:n.uniform2fv(i,o.e);break;case y.Vector2Array:n.uniform2fv(i,o.map((e=>[...e.e])).flat());break;case y.Vector3:n.uniform3fv(i,o.e);break;case y.Vector3Array:n.uniform3fv(i,o.map((e=>[...e.e])).flat());break;case y.Vector4:n.uniform4fv(i,o.e);break;case y.Vector4Array:n.uniform4fv(i,o.map((e=>[...e.e])).flat());break;case y.Matrix4:n.uniformMatrix4fv(i,!1,o.e);break;case y.Matrix4Array:o&&n.uniformMatrix4fv(i,!1,o.map((e=>[...e.e])).flat());break;case y.Color:n.uniform4fv(i,o.e);break;case y.ColorArray:o&&n.uniform4fv(i,o.map((e=>[...e.e])).flat());break;case y.Texture:n.activeTexture(L+t),n.bindTexture(D,o?o.glObject:e.dummyTexture.glObject),n.uniform1i(i,t),t++;break;case y.TextureArray:const r=[];o.forEach((a=>{r.push(t),n.activeTexture(L+t),n.bindTexture(D,a?a.glObject:e.dummyTexture.glObject),t++})),r.length,n.uniform1iv(i,r);break;case y.CubeMap:n.activeTexture(L+t),n.bindTexture(F,o?o.glObject:e.dummyCubeTexture.glObject),n.uniform1i(i,t),t++}};e.uniforms&&e.uniforms.data.forEach((e=>{e.type===y.Struct?e.value.forEach((n=>{const t=`${e.name}.${n.name}`;r(n.type,t,n.value)})):e.type===y.StructArray?e.value.forEach(((n,t)=>{n.forEach((n=>{const a=`${e.name}[${t}].${n.name}`;r(n.type,a,n.value)}))})):r(e.type,e.name,e.value)}))}(e),g.bindVertexArray(e.vao.glObject),e.vao.ibo?null!==f?f>0&&g.drawElementsInstanced(d,n,te,p,f):g.drawElements(d,n,te,p):null!==f?f>0&&g.drawArraysInstanced(d,p,n,f):g.drawArrays(d,p,n),g.bindTexture(D,null),g.bindTexture(F,null)}}(e.gpu,n.drawCount,r.primitiveType,!!r.depthTest,i,r.depthFuncType,r.blendType,r.faceSide,n.instanceCount)}function pi(e,n,t=0){return{actor:e,queue:n,materialIndex:t}}function di(e,n,t,r){const a=e.globalUniformBufferObjects.find((({uniformBufferObject:e})=>e.blockName===n));if(!a)return;const o=a.uniformBufferObject,i=a.data.find((e=>e.name===t));i&&qe(o,t,i.type,r)}function gi(e){Dr(e.copyDepthSourceRenderTarget,e.depthPrePassRenderTarget.depthTexture),function(e,n,t,r,a){const o=e.gl;o.bindFramebuffer(ye,n.framebuffer.glObject),o.bindFramebuffer(Se,t.framebuffer.glObject),o.clear(E),o.blitFramebuffer(0,0,r,a,0,0,r,a,E,we.NEAREST),o.bindFramebuffer(ye,null),o.bindFramebuffer(Se,null)}(e.gpu,e.copyDepthSourceRenderTarget,e.copyDepthDestRenderTarget,e.realWidth,e.realHeight)}function hi(e,n){di(e,b.Transformations,S.WorldMatrix,n.transform.worldMatrix),di(e,b.Transformations,S.InverseWorldMatrix,n.transform.worldMatrix),di(e,b.Transformations,S.NormalMatrix,n.transform.normalMatrix)}function vi(e,n){di(e,b.Transformations,S.ViewMatrix,n.viewMatrix),di(e,b.Transformations,S.ProjectionMatrix,n.projectionMatrix),di(e,b.Camera,S.ViewPosition,rt(n.transform.worldMatrix)),di(e,b.Camera,S.ViewDirection,Ri(n)),di(e,b.Camera,S.CameraNear,n.near),di(e,b.Camera,S.CameraFar,n.far),di(e,b.Camera,S.CameraAspect,(Li(n),n.aspect)),di(e,b.Camera,S.CameraFov,Li(n)?n.fov:0),di(e,b.Transformations,S.ViewProjectionMatrix,n.viewProjectionMatrix),di(e,b.Transformations,S.InverseViewMatrix,n.inverseViewMatrix),di(e,b.Transformations,S.InverseProjectionMatrix,n.inverseProjectionMatrix),di(e,b.Transformations,S.InverseViewProjectionMatrix,n.inverseViewProjectionMatrix),di(e,b.Transformations,S.TransposeInverseViewMatrix,ut(ct(st(n.viewMatrix))))}function xi(e,n,t,r,a=!1){const o=e.globalUniformBufferObjects.find((({uniformBufferObject:e})=>e.blockName===n));if(!o)return;const i=o.uniformBufferObject,l=o.data.find((e=>e.name===t));if(!l)return;const s=(e,n)=>{const t=[];switch(e){case y.Float:case y.Int:t.push(n),t.push(0),t.push(0),t.push(0);break;case y.Bool:t.push(n?1:0),t.push(0),t.push(0),t.push(0);break;case y.Vector2:case y.Vector3:t.push(...n.e),t.push(0);break;case y.Vector4:case y.Matrix4:case y.Color:t.push(...n.e)}return t};switch(l.type){case y.Struct:r.forEach((e=>{const n=`${t}.${e.name}`,r=s(e.type,e.value);Xe(i,n,new Float32Array(r))}));break;case y.StructArray:r.forEach(((e,n)=>{e.forEach((e=>{const r=`${t}[${n}].${e.name}`,o=s(e.type,e.value);Xe(i,r,new Float32Array(o),a)}))}));break;default:if(Array.isArray(r)){const e=[];r.forEach((n=>{"number"==typeof n?(e.push(n),e.push(0),e.push(0),e.push(0)):"boolean"==typeof n?(e.push(n?1:0),e.push(0),e.push(0),e.push(0)):e.push(...n.e)})),Xe(i,t,new Float32Array(e))}else Xe(i,t,"number"==typeof r?new Float32Array([r]):r.e)}}function Ti(e,n){return{basePass:[i.Opaque,i.AlphaTest].map((t=>[...e[t]].sort(((e,t)=>yt(bt(n.transform.position,e.actor.transform.position))<yt(bt(n.transform.position,t.actor.transform.position))?-1:1)))).flat(),skyboxPass:[...e[i.Skybox]].sort(((e,t)=>yt(bt(n.transform.position,e.actor.transform.position))<yt(bt(n.transform.position,t.actor.transform.position))?-1:1)),transparentPass:[...e[i.Transparent]].sort(((e,t)=>yt(bt(n.transform.position,e.actor.transform.position))>=yt(bt(n.transform.position,t.actor.transform.position))?-1:1))}}function yi(e){return{passes:[],postProcessCamera:e=e||_i(),selfEnabled:!0}}function Si(e){for(let n=0;n<e.passes.length;n++)if(e.passes[n].enabled)return!0;return!1}function bi(e,n){e.passes.push(n)}function Ci(e){e.passes.forEach((e=>{var n;n=e,Xo[n.type]?.(n)}))}function Mi({pass:e,gpu:n,renderer:t,camera:r,prevRenderTarget:a,targetCamera:o,gBufferRenderTargets:i,time:l,isLastPass:s,lightActors:u}){!function({pass:e,renderer:n,targetCamera:t,lightActors:r,fallbackTextureBlack:a}){e.materials.forEach((e=>{r&&ui(e,r,a),nr(e,S.ViewProjectionMatrix,t.viewProjectionMatrix),nr(e,S.InverseViewProjectionMatrix,t.inverseViewProjectionMatrix),nr(e,S.InverseViewMatrix,t.inverseViewMatrix),nr(e,S.InverseProjectionMatrix,t.inverseProjectionMatrix),nr(e,S.TransposeInverseViewMatrix,ut(ct(st(t.viewMatrix)))),nr(e,S.GBufferATexture,n.gBufferRenderTargets.gBufferATexture),nr(e,S.GBufferBTexture,n.gBufferRenderTargets.gBufferBTexture),nr(e,S.GBufferCTexture,n.gBufferRenderTargets.gBufferCTexture),nr(e,S.GBufferDTexture,n.gBufferRenderTargets.gBufferDTexture),nr(e,S.DepthTexture,n.depthPrePassRenderTarget.depthTexture)}))}({pass:e,renderer:t,targetCamera:o,lightActors:u,fallbackTextureBlack:n.dummyTextureBlack}),vi(t,o),Ko(e,{gpu:n,renderer:t,camera:r,prevRenderTarget:a,isLastPass:s,targetCamera:o,gBufferRenderTargets:i,time:l,lightActors:u})}function Pi(e,{gpu:n,renderer:t,prevRenderTarget:r,gBufferRenderTargets:a,targetCamera:o,time:i,isCameraLastPass:l,lightActors:s}){Yi(e.postProcessCamera);const u=e.passes.filter((e=>e.enabled));u.forEach(((c,m)=>{const f=l&&m===u.length-1;Mi({pass:c,gpu:n,renderer:t,camera:e.postProcessCamera,prevRenderTarget:r,isLastPass:f,targetCamera:o,gBufferRenderTargets:a,time:i,lightActors:s}),r=Qo(c)}))}const wi={[h.Default]:wr,[h.GBuffer]:Fr},Ri=e=>Ct(_t(e.transform)),Di=e=>!!(e=>!!e.postProcess&&function(e){if(!e.selfEnabled)return!1;for(let n=0;n<e.passes.length;n++)if(e.passes[n].enabled)return!0;return!1}(e.postProcess))(e)&&Si(e.postProcess),Fi=(e,n,t)=>{e.renderTarget&&function(e,n,t){wi[e.renderTargetKind]?.(e,n,t)}(e.renderTarget,n,t),e.postProcess&&function(e,n,t){Fi(e.postProcessCamera,n,t),e.passes.forEach((e=>$o(e,n,t)))}(e.postProcess,n,t)},Li=e=>0===e.cameraType,Bi=(e,n)=>{const t=lt(e.projectionMatrix,e.viewMatrix,ot(n)),r=rt(t),a=0===Un(t)?1e-4:Un(t);return ft(pt(r)/a,dt(r)/a,gt(r)/a)},Ei={0:function(e,n,t){const r=e;Fi(e,n,t),r.fixedAspect||(r.aspect=n/t,Cr(e))},1:function(e,n,t){Fi(e,n,t),ki(e)}},Ii={1:ki,0:Cr},Ai=e=>{Ii[e.cameraType]?.(e)},Ni={0:function(e){const n=e,t=Bt(),r=Et(),a=Ft(),o=n.fov/2*Math.PI/180,i=e.near*o,l=i*n.aspect,s=e.far*o,u=s*n.aspect,c=Mt(Pt(t),e.near),m=Mt(Pt(t),e.far),f=Mt(Pt(r),l),p=Mt(Pt(a),i),d=Mt(Pt(r),u),g=Mt(Pt(a),s);return{nlt:It(c,Ct(Pt(f)),p),nrt:It(c,f,p),nlb:It(c,Ct(Pt(f)),Ct(Pt(p))),nrb:It(c,f,Ct(Pt(p))),flt:It(m,Ct(Pt(d)),g),frt:It(m,d,g),flb:It(m,Ct(Pt(d)),Ct(Pt(g))),frb:It(m,d,Ct(Pt(g)))}},1:function(e){const n=e,t=Bt(),r=Et(),a=Ft(),o=(Math.abs(n.left)+Math.abs(n.right))/2,i=(Math.abs(n.top)+Math.abs(n.right))/2,l=Mt(Pt(t),e.near),s=Mt(Pt(t),e.far),u=Mt(Pt(r),o),c=Mt(Pt(a),i);return{nlt:It(l,Ct(Pt(u)),c),nrt:It(l,u,c),nlb:It(l,Ct(Pt(u)),Ct(Pt(c))),nrb:It(l,u,Ct(Pt(c))),flt:It(s,Ct(Pt(u)),c),frt:It(s,u,c),flb:It(s,Ct(Pt(u)),Ct(Pt(c))),frb:It(s,u,Ct(Pt(c)))}}};function ki(e){const n=e;var t,r,a,o,i,l;e.projectionMatrix=(t=n.left,r=n.right,a=n.bottom,o=n.top,i=n.near,wn(2/(r-t),0,0,-(r+t)/(r-t),0,2/(o-a),0,-(o+a)/(o-a),0,0,-2/((l=n.far)-i),-(l+i)/(l-i),0,0,0,1))}const Oi=(e,n,t,r,a,o,i)=>{r&&a&&i&&o&&(e.left=r,e.right=a,e.bottom=o,e.top=i),null!==n&&null!==t&&Fi(e,n,t),e.aspect=(a-r)/(i-o)},_i=()=>{const e=Vi(-1,1,-1,1,0,2);return Ut(e.transform,ft(0,0,1)),e};function Vi(e,n,t,r,a,o){const i={...br({cameraType:1}),left:e,right:n,bottom:t,top:r,near:a,far:o,aspect:1};return Oi(i,1,1,e,n,t,r),i}const Ui={0:e=>{zi(e)},1:e=>{const n=e;n.shadowCamera&&(n.shadowCamera.fov=Math.acos(ni(n))*(180/Math.PI)*2,n.shadowCamera.far=n.distance,Ai(n.shadowCamera),zi(n))}},zi=e=>{if(null===e.shadowCamera)return;const n=wn(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);e.lightViewProjectionMatrix=lt(st(e.shadowCamera.projectionMatrix),st(e.shadowCamera.viewMatrix)),e.shadowMapProjectionMatrix=lt(n,st(e.lightViewProjectionMatrix))},ji=(e,{gpu:n,scene:t})=>{e.isStarted||(e.isStarted=!0,Hi(e,{gpu:n,scene:t}))};function Gi(e,{gpu:n,scene:t}){e.components.forEach((e=>{e.start({gpu:n,scene:t})})),e.onStart.forEach((e=>{e({gpu:n,scene:t})}))}const Wi={[s.Mesh]:tl,[s.Skybox]:tl},Hi=(e,{gpu:n,scene:t})=>{(Wi[e.type]??Gi)(e,{gpu:n,scene:t})},$i={[s.Camera]:function(e,n,t){const r=e;Ei[r.cameraType]?.(r,n,t)},[s.Mesh]:function(e,n,t){const r=e;rl[r.type]?.(r,n,t)}},Xi={[s.Light]:(e,n)=>{const t=e;Ui[t.lightType]?.(t,n)},[s.Mesh]:function(e,n){const t=e;al[t.meshType]?.(e,n)},[s.Camera]:(e,n)=>{const r=e,{gpu:a}=n;if(r.visibleFrustumMesh||(r.visibleFrustumMesh=Sr({geometry:$t({gpu:a,attributes:[Ee({name:T.Position,data:new Float32Array(Vr.range(144).fill(0)),size:3,usageType:x.DynamicDraw})],drawCount:48,indices:[...Vr.range(48,!0)]}),material:ar({vertexShader:`\nlayout (location = 0) in vec3 ${T.Position};\n#include <lighting>\n#include <ub>\nvoid main() {gl_Position=${S.ProjectionMatrix} * ${S.ViewMatrix} * ${S.WorldMatrix} * vec4(${T.Position}, 1.);}\n`,fragmentShader:"\nout vec4 o; void main() {o=vec4(0,1.,0,1.);}\n                    ",primitiveType:t.Lines,blendType:o.Transparent,faceSide:m.Double,depthWrite:!1})}),Sl(r,r.visibleFrustumMesh)),r.visibleFrustumMesh){const e=(e=>Ni[e.cameraType]?.(e)||null)(r);if(!e)return;const n=e.nlt.e,t=e.nlb.e,a=e.nrt.e,o=e.nrb.e,i=e.flt.e,l=e.flb.e,s=e.frt.e,u=e.frb.e;rn(r.visibleFrustumMesh.geometry,T.Position,new Float32Array([...i,...s,...s,...u,...u,...l,...l,...i,...n,...a,...a,...o,...o,...t,...t,...n,...i,...n,...n,...t,...t,...l,...l,...i,...s,...a,...a,...n,...n,...i,...i,...s,...u,...o,...o,...a,...a,...s,...s,...u,...l,...t,...t,...o,...o,...u,...u,...l])),r.visibleFrustumMesh.enabled=r.visibleFrustum}}},qi=e=>{(e=>{if(e.transform.lookAtTarget||e.transform.lookAtTargetActor){const n=e.transform.lookAtTargetActor?e.transform.lookAtTargetActor.transform.position:e.transform.lookAtTarget,t=e?.type===s.Camera?mt(e.transform.position,n,Ft(),!0):mt(e.transform.position,n),r=it(e.transform.scale);e.transform.localMatrix=lt(t,r)}else{const n=ot(e.transform.position),t=function(e){const n=fn(e),t=pn(e),r=dn(e),a=gn(e);return wn(2*a*a+2*n*n-1,2*n*t-2*r*a,2*n*r+2*t*a,0,2*n*t+2*r*a,2*a*a+2*t*t-1,2*t*r-2*n*a,0,2*n*r-2*t*a,2*t*r+2*n*a,2*a*a+2*r*r-1,0,0,0,0,1)}(e.transform.rotation.quaternion),r=it(e.transform.scale);e.transform.localMatrix=lt(n,t,r)}e.transform.worldMatrix=e?.parent?lt(e?.parent.transform.worldMatrix,e.transform.localMatrix):e.transform.localMatrix,e.transform.inverseWorldMatrix=ct(st(e.transform.worldMatrix)),e.transform.normalMatrix=ut(ct(st(e.transform.worldMatrix)))})(e)},Ji={[s.Skybox]:(e,n)=>{const t=e;n&&(Ut(t.transform,n.transform.position),Vt(t.transform,Ot(n.far/1.733))),qi(e)},[s.Camera]:e=>{const n=e;qi(e),n.viewMatrix=ct(st(n.transform.worldMatrix)),n.inverseProjectionMatrix=ct(st(n.projectionMatrix)),n.inverseViewMatrix=ct(st(n.viewMatrix)),n.viewProjectionMatrix=lt(n.projectionMatrix,n.viewMatrix),n.inverseViewProjectionMatrix=ct(st(n.viewProjectionMatrix))}},Yi=(e,n)=>{(Ji[e.type]??qi)(e,n)},Ki="uIsPerspective",Zi={[c.GBuffer]:e=>{const n=e;nr(e,S.RoughnessMap,n.roughnessMap),nr(e,S.Roughness,n.roughnessMap?1:n.roughness),nr(e,S.RoughnessMapTiling,n.roughnessMapTiling),nr(e,S.MetallicMap,n.metallicMap),nr(e,S.Metallic,n.metallicMap?1:n.metallic),nr(e,S.MetallicMapTiling,n.metallicMapTiling)}},Qi=e=>{Zi[e.type]?.(e)};function el(e,n){Gi(e,n);const{gpu:t}=n;e.materials.forEach((n=>{rr(n)||or(n,{gpu:t,attributeDescriptors:on(e.geometry)})})),e.materials.forEach(((n,t)=>{!e.depthMaterials[t]&&e.autoGenerateDepthMaterial&&(e.depthMaterials[t]=ar({name:`${n.name}/depth`,vertexShader:n.rawVertexShader,fragmentShader:n.depthFragmentShader||Zt(),fragmentShaderModifiers:n.depthFragmentShaderModifiers,uniforms:n.depthUniforms.data,faceSide:n.faceSide,depthTest:!0,depthWrite:!0,depthFuncType:a.Lequal,alphaTest:n.alphaTest,skipDepthPrePass:n.skipDepthPrePass,isInstancing:n.isInstancing,useInstanceLookDirection:n.useInstanceLookDirection,useVertexColor:n.useVertexColor,uniformBlockNames:n.uniformBlockNames}))})),e.depthMaterials.forEach((n=>{rr(n)||or(n,{gpu:t,attributeDescriptors:on(e.geometry)})}))}const nl={[u.Skinned]:function(e,n){const t=e,{gpu:r}=n;if(jt(t.bones),t.boneOffsetMatrices=fl(t),t.gpuSkinning=!!ul(t).gpuSkinning,t.jointTexture=ke({gpu:r,width:1,height:1,type:f.RGBA32F}),t.materials.forEach((e=>{e.uniforms=Qt(e.uniforms.data,ml(t)),e.isSkinning=!0,e.gpuSkinning=!!t.gpuSkinning,e.jointNum=t.boneCount})),ul(t).depthUniforms=Qt(ul(t).depthUniforms.data,ml(t)),el(t,n),t.debugBoneView&&dl(t,{gpu:r}),t.animationClips&&t.gpuSkinning){const e=[];t.animationClips.forEach(((n,t)=>{const r=function(e){return new Array(e.frameCount).fill(0).map(((n,t)=>e.keyframes.map((e=>({target:e.target,key:e.key,frameValue:xl(e,t)})))))}(n);e[t]=[],r.forEach(((n,r)=>{e[t][r]=[],n.forEach((n=>{const a=n.target.index;switch(e[t][r][a]||(e[t][r][a]={bone:n.target}),n.key){case hl.translation:case hl.rotation:case hl.scale:e[t][r][a][n.key]=n.frameValue}}))}))}));const n=[];e.forEach(((e,r)=>{n[r]=[],e.forEach((e=>{e.forEach((e=>{const{translation:n,rotation:r,scale:a,bone:o}=e,i=t.boneOrderedIndex[o.index];n&&(i.position=n),r&&(i.rotation=Pn(xn(r))),a&&(i.scale=a)})),Gt(t.bones);const a=t.boneOffsetMatrices,o=pl(t),i=a.map(((e,n)=>lt(o[n].matrix,e)));n[r].push(...i)}))}));const r=[...n].flat(2),a=t.animationClips.reduce(((e,n)=>e+n.frameCount),0),o=t.jointTextureColNum,i=t.boneCount*a,l=Math.ceil(i/o),s=new Float32Array([...r,...new Array(o*l-i).fill(0).map((()=>at()))].map((e=>[...e.e])).flat()),u=4;_e(t.jointTexture,{width:o*u,height:l,data:s}),t.materials.forEach((e=>nr(e,S.TotalFrameCount,a))),t.depthMaterials.forEach((e=>{nr(e,S.TotalFrameCount,a)}))}}};function tl(e,n){const t=e;(nl[t.meshType]??el)(t,n)}const rl={[u.ScreenSpaceRaymarch]:(e,n,t)=>{const r=e;nr(ul(r),S.TargetWidth,n),nr(sl(r),S.TargetHeight,t)}},al={[u.Skinned]:function(e,n){const t=e,{time:r}=n;if(Gt(t.bones),t.boneLines&&t.bonePoints){const e=t.boneOrderedIndex.map((e=>[...rt(e.jointMatrix).e]));rn(t.boneLines.geometry,T.Position,new Float32Array(e.flat())),rn(t.bonePoints.geometry,T.Position,new Float32Array(e.flat()))}if(t.gpuSkinning)t.materials.forEach((e=>nr(e,S.Time,r))),t.depthMaterials.forEach((e=>{nr(e,S.Time,r)})),t.materials.forEach((e=>nr(e,S.JointTexture,t.jointTexture))),t.depthMaterials.forEach((e=>{nr(e,S.JointTexture,t.jointTexture)}));else{const e=t.boneOffsetMatrices,n=pl(t),r=e.map(((e,t)=>lt(n[t].matrix,e))),a=t.jointTextureColNum,o=Math.ceil(t.boneCount/a),i=a*o-t.boneCount,l=new Float32Array([...r,...new Array(i).fill(0).map((()=>at()))].map((e=>[...e.e])).flat()),s=4;t.jointTexture&&_e(t.jointTexture,{width:a*s,height:o,data:l}),t.materials.forEach((e=>nr(e,S.JointTexture,t.jointTexture))),t.depthMaterials.forEach((e=>{nr(e,S.JointTexture,t.jointTexture)}))}},[u.ObjectSpaceRaymarch]:function(e){const n=e;n.materials.forEach((e=>{nr(e,S.ObjectSpaceRaymarchBoundsScale,n.transform.scale)})),n.depthMaterials.forEach((e=>{nr(e,S.ObjectSpaceRaymarchBoundsScale,n.transform.scale)}))}},ol={[u.ObjectSpaceRaymarch]:(e,{camera:n,skybox:t})=>{e.materials.forEach((e=>{t&&$r(e,t),nr(e,Ki,Li(n)?1:0)}))}},il=(e,n)=>{e.materials.forEach((e=>Qi(e))),ol[e.meshType]?.(e,n)},ll={[u.ObjectSpaceRaymarch]:(e,{camera:n})=>{e.depthMaterials.forEach((e=>{nr(e,Ki,Li(n)?1:0)}))}},sl=e=>(cl(e),ul(e)),ul=e=>e.materials[0],cl=e=>e.materials.length>1,ml=e=>[{name:S.JointTexture,type:y.Texture,value:null},{name:S.JointTextureColNum,type:y.Int,value:e.jointTextureColNum},...e.gpuSkinning?[{name:S.BoneCount,type:y.Int,value:e.boneCount},{name:S.TotalFrameCount,type:y.Int,value:0}]:[]],fl=e=>{const n=[];return Wt(e.bones,(e=>{const t=st(e.boneOffsetMatrix);n.push(t)})),n},pl=e=>{const n=[];return Wt(e.bones,(e=>{const t=st(e.jointMatrix);n.push({bone:e,matrix:t})})),n},dl=(e,{gpu:n})=>{const r=n=>{n.children.length>0&&n.children.forEach((t=>{const a=t;e.boneIndicesForLines.push(n.index,a.index),r(a)}))};r(e.bones),e.boneLines=Sr({geometry:$t({gpu:n,attributes:[Ee({name:T.Position,data:new Float32Array(new Array(3*e.boneOrderedIndex.length).fill(0)),size:3,usageType:x.DynamicDraw})],indices:e.boneIndicesForLines,drawCount:e.boneIndicesForLines.length}),material:ar({vertexShader:`\n                layout (location = 0) in vec3 ${T.Position};\n                \n                uniform mat4 ${S.WorldMatrix};\n                uniform mat4 ${S.ViewMatrix};\n                uniform mat4 ${S.ProjectionMatrix};\n                \n                void main() {\n                    gl_Position = ${S.ProjectionMatrix} * ${S.ViewMatrix} * ${S.WorldMatrix} * vec4(${T.Position}, 1.);\n                }\n                `,fragmentShader:"\n                out vec4 outColor;\n                \n                void main() {\n                    outColor = vec4(0, 1., 0, 1.);\n                }\n                ",primitiveType:t.Lines,blendType:o.Transparent,depthWrite:!1,depthTest:!1})}),e.bonePoints=Sr({geometry:$t({gpu:n,attributes:[Ee({name:T.Position.toString(),data:new Float32Array(new Array(3*e.boneOrderedIndex.length).fill(0)),size:3,usageType:x.DynamicDraw})],drawCount:e.boneOrderedIndex.length}),material:ar({vertexShader:`\n                layout (location = 0) in vec3 ${T.Position};\n                \n                uniform mat4 ${S.WorldMatrix};\n                uniform mat4 ${S.ViewMatrix};\n                uniform mat4 ${S.ProjectionMatrix};\n                \n                void main() {\n                    gl_Position = ${S.ProjectionMatrix} * ${S.ViewMatrix} * ${S.WorldMatrix} * vec4(${T.Position}, 1.);\n                    gl_PointSize = 6.;\n                }\n                `,fragmentShader:"\n                out vec4 outColor;\n                \n                void main() {\n                    outColor = vec4(1, 0., 0, 1.);\n                }\n                ",primitiveType:t.Points,blendType:o.Transparent,depthWrite:!1,depthTest:!1})}),Sl(e,e.boneLines),Sl(e,e.bonePoints)},gl={LINEAR:"LINEAR",STEP:"STEP",CATMULLROMSPLINE:"CATMULLROMSPLINE",CUBICSPLINE:"CUBICSPLINE"},hl={translation:"translation",rotation:"rotation",scale:"scale"};async function vl({gpu:e,dir:n="",path:t}){const r=e=>n+e,a=r(t),o=await fetch(a),i=await o.json(),l=Tl({}),s={KHR_materials_emissive_strength:!1};i.extensionsUsed&&i.extensionsUsed.forEach((e=>{"KHR_materials_emissive_strength"===e&&(s.KHR_materials_emissive_strength=!0)}));const c=[];i.textures&&await Promise.all(i.textures.map((async({source:e,sampler:n})=>{const t=i.images[e].uri,a=i.samplers[n].minFilter,o=i.samplers[n].magFilter,l=i.samplers[n].wrapS,s=i.samplers[n].wrapT,u=a?Ae(a):void 0,c=o?Ae(o):void 0,m=l?Ne(l):void 0,f=s?Ne(s):void 0;return{img:await yr(r(t)),minFilter:u,magFilter:c,wrapS:m,wrapT:f}}))).then((n=>{n.forEach((({img:n,minFilter:t,magFilter:r,wrapS:a,wrapT:o})=>{const i=ke({gpu:e,img:n,minFilter:t,magFilter:r,wrapS:a,wrapT:o});c.push(i)}))}));const m=[],f=await Promise.all(i.buffers.map((async e=>{const n=e.uri.match("^data:application/octet-stream;base64.*")?e.uri:r(e.uri),t=await fetch(n),a=await t.arrayBuffer();return{byteLength:e.byteLength,binBufferData:a}}))),p=e=>{const n=i.bufferViews[e.bufferView],{binBufferData:t}=f[n.buffer];return t.slice(n.byteOffset,n.byteOffset+n.byteLength)},d=(e,n=null)=>{const t=i.nodes[e],r=function({index:e,name:n}){const t=function({name:e}){return{name:e,parent:null,children:[]}}({name:n}),r=at(),a=at(),o=at(),i=at();return{...t,index:e,position:Rt(),rotation:Cn(),scale:Dt(),offsetMatrix:r,poseMatrix:a,boneOffsetMatrix:o,jointMatrix:i}}({name:t.name,index:e});m[e]=r;const a=lt(ot(t.translation?ft(t.translation[0],t.translation[1],t.translation[2]):Rt()),t.rotation?xn(mn(t.rotation[0],t.rotation[1],t.rotation[2],t.rotation[3])):xn(Tn()),it(t.scale?ft(t.scale[0],t.scale[1],t.scale[2]):Dt()));var o,l;return r.offsetMatrix=a,n&&(function(e,n){e.children.push(n)}(o=n,l=r),function(e,n){e.parent=n}(l,o)),t.children&&t.children.forEach((e=>d(e,r))),r},g=(n,t)=>{const r=i.nodes[n],a=void 0!==r.children;if(void 0!==r.mesh){const o=(({meshIndex:n,skinIndex:t=null})=>{let r=new Float32Array,a=new Float32Array,o=null,l=new Float32Array,m=new Float32Array,f=new Uint16Array,g=new Uint16Array,h=new Float32Array,v=null;const x=i.meshes[n],T=[];if(x.primitives.forEach((e=>{const n={attributes:[],indices:null};if(Object.keys(e.attributes).forEach((t=>{const r=t,a=e.attributes[r];null!=a&&n.attributes.push({attributeName:r,accessor:i.accessors[a]})})),Object.hasOwn(e,"material")&&T.push(e.material),e.indices&&(n.indices={accessor:i.accessors[e.indices]}),n.attributes.forEach((e=>{const{attributeName:n,accessor:t}=e,i=p(t);switch(n){case"POSITION":r=new Float32Array(i);break;case"NORMAL":a=new Float32Array(i);break;case"TANGENT":o=new Float32Array(i);break;case"TEXCOORD_0":m=new Float32Array(i);break;case"JOINTS_0":g=new Uint16Array(new Uint8Array(i));break;case"WEIGHTS_0":h=new Float32Array(i)}})),n.indices){const{accessor:e}=n.indices,t=p(e);f=new Uint16Array(t)}})),null!==t){const e=i.skins[t];v=d(e.joints[0])}const y=m.map(((e,n)=>n%2==0?e:1-e));if(o)l=new Float32Array(function(e,n){const t=[];for(let r=0;r<e.length/3;r++){const a=ft(e[3*r+0],e[3*r+1],e[3*r+2]),o=kt(ft(n[3*r+0],n[3*r+1],n[3*r+2]),a);t.push(...o.e)}return t}(Array.from(a),Array.from(o)));else{const e=Ht(Array.from(a));o=new Float32Array(e.tangents),l=new Float32Array(e.binormals)}const S=$t({gpu:e,attributes:[Ee({name:"aPosition",data:r,size:3}),Ee({name:"aUv",data:y,size:2}),Ee({name:"aNormal",data:a,size:3}),...v?[Ee({name:"aBoneIndices",data:g,size:4}),Ee({name:"aBoneWeights",data:h,size:4})]:[],Ee({name:"aTangent",data:new Float32Array(o),size:3}),Ee({name:"aBinormal",data:new Float32Array(l),size:3})],indices:Array.from(f),drawCount:f.length}),b=T.map((e=>{const n=i.materials[e],t=!!n.pbrMetallicRoughness.baseColorTexture,r=!!n.normalTexture,a=t?c[n.pbrMetallicRoughness.baseColorTexture.index]:null,o=r?c[n.normalTexture.index]:null;let l=fr();if(n.hasOwnProperty("emissiveFactor"))if(s.KHR_materials_emissive_strength){const e=n.extensions.KHR_materials_emissive_strength.emissiveStrength;l=function(e,n,t=!1){return e.e[0]*=n,e.e[1]*=n,e.e[2]*=n,t&&(e.e[3]*=n),e}(pr(n.emissiveFactor),e)}else l=pr(n.emissiveFactor);return Tr({baseMap:a,baseColor:n.pbrMetallicRoughness.baseColorFactor?pr(n.pbrMetallicRoughness.baseColorFactor):mr(),normalMap:o,metallic:n.pbrMetallicRoughness.metallicFactor,roughness:n.pbrMetallicRoughness.roughnessFactor,emissiveColor:l})}));return v?function({bones:e,debugBoneView:n,...t}){const r={...Sr({...t,meshType:u.Skinned,autoGenerateDepthMaterial:!0}),bones:e,boneOffsetMatrices:[],boneIndicesForLines:[],jointTexture:null,gpuSkinning:null,animationClips:[],jointTextureColNum:1,boneLines:null,bonePoints:null,debugBoneView:!!n};let a=0;const o=[];return Wt(r.bones,(e=>{a++,o[e.index]=e})),{...r,boneCount:a,boneOrderedIndex:o}}({geometry:S,bones:v}):Sr({geometry:S,materials:b})})({meshIndex:r.mesh,skinIndex:null!==r.skin&&void 0!==r.skin?r.skin:null});return m[n]=o,Sl(t,o),void(a&&r.children.forEach((e=>g(e,o))))}if(a)if(m[n])r.children.forEach((e=>g(e,t)));else{const e=Tl({});Sl(t,e),m[n]=e,r.children.forEach((n=>g(n,e)))}};if(i.scenes.forEach((e=>{e.nodes.forEach((e=>{g(e,l)}))})),i.animations&&i.animations.length>0){const e=i.animations.map((e=>{const n=e.channels.map((n=>{const t=e.samplers[n.sampler],r=i.accessors[t.input],a=p(r),o=new Float32Array(a),l=i.accessors[t.output],s=p(l),u=new Float32Array(s);switch(n.target.path){case hl.translation:case hl.scale:case hl.rotation:}let c=0;switch(n.target.path){case hl.rotation:c=1;break;case hl.translation:case hl.scale:c=0}return function({target:e,type:n,key:t,interpolation:r,data:a,start:o,end:i,frameCount:l,frames:s}){let u=-1;switch(n){case 0:u=3;break;case 1:u=4}return{type:n,target:e,key:t,data:a,start:o,elementSize:u,end:i,frameCount:l,frames:s,interpolation:r}}({target:m[n.target.node],key:n.target.path,interpolation:t.interpolation,data:u,start:Math.min(...r.min),end:Math.min(...r.max),frames:o,frameCount:r.count,type:c})})),t=function({name:e,keyframes:n}){const t=Math.max(...n.map((e=>e.frameCount)));return{name:e,keyframes:n,frameCount:t,currentTime:0,currentFrame:0,loop:!1,isPlaying:!1,speed:1,fps:30}}({name:e.name,keyframes:n});return t}));l.animator&&function(e,n){e.animationClips=n}(l.animator,e)}return l}function xl(e,n){const t=Vr(new Array(e.elementSize).fill(0).map(((t,r)=>{switch(e.interpolation){case gl.LINEAR:return e.data[n*e.elementSize+r];case gl.STEP:return e.data[r]}}))).compact().value();switch(e.type){case 0:return ft(t[0],t[1],t[2]);case 1:return mn(t[0],t[1],t[2],t[3]);default:return null}}const Tl=({name:e="",type:n=s.Null}={})=>({name:e,type:n,uuid:"10000000-1000-4000-8000-100000000000".replace(/[018]/g,(e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))),isStarted:!1,transform:{inverseWorldMatrix:at(),worldMatrix:at(),localMatrix:at(),position:Rt(),rotation:Cn(),scale:Dt(),lookAtTarget:null,lookAtTargetActor:null,normalMatrix:at()},parent:null,children:[],components:[],animator:function(e=[]){return{animationClips:e,playingAnimationClip:null}}(),onStart:[],onFixedUpdate:null,onUpdate:[],onLastUpdate:null,onBeforeRender:null,onProcessPropertyBinder:null,onPreProcessTimeline:null,onPostProcessTimeline:null,enabled:!0}),yl=e=>(e=>e.children.length)(e)>0,Sl=(e,n)=>{e.children.push(n),n.parent=e},bl=(e,n)=>{e.onStart.push(n)};function Cl(e,n){e.children.push(n)}function Ml(e,n){if(n(e),yl(e))for(let t=0;t<e.children.length;t++)Ml(e.children[t],n)}function Pl(e,n){for(let t=0;t<e.children.length;t++)Ml(e.children[t],n)}function wl(e,n=!1){e.cameraAngle.azimuth=Xr(e.cameraAngle.azimuth,e.minAzimuth,e.maxAzimuth),e.cameraAngle.altitude=Xr(e.cameraAngle.altitude,e.minAltitude,e.maxAltitude);const t=function(e,n){const t=pt(e),r=dt(e),a=gt(e),o=n/180*Math.PI,i=Math.cos(o),l=Math.sin(o);return ft(t*i+a*l,r,t*-l+a*i)}(function(e,n){const t=pt(e),r=dt(e),a=gt(e),o=n/180*Math.PI,i=Math.cos(o),l=Math.sin(o);return ft(t,r*i+a*-l,r*l+a*i)}(ft(0,0,1),e.cameraAngle.altitude),e.cameraAngle.azimuth);e.targetCameraPosition=It(e.lookAtTarget,Mt(t,e.distance)),e.currentCameraPosition=function(e,n,t){return ft(pt(e)+(pt(n)-pt(e))*t,dt(e)+(dt(n)-dt(e))*t,gt(e)+(gt(n)-gt(e))*t)}(e.currentCameraPosition,e.targetCameraPosition,n?1:e.dampingFactor),e.camera&&e.enabledUpdateCamera&&(Ut(e.camera.transform,e.currentCameraPosition),zt(e.camera.transform,e.lookAtTarget))}function Rl(e,n,t){pa(e.tmpInputPosition,n),da(e.tmpInputPosition,t)}function Dl(e,n,t){pa(e.tmpInputPosition,n),da(e.tmpInputPosition,t)}const Fl={0:function(e){window.addEventListener("mousedown",(n=>{e.tmpIsDown=!0,Dl(e,n.clientX,n.clientY)})),window.addEventListener("mousemove",(n=>{Dl(e,n.clientX,n.clientY)})),window.addEventListener("mouseup",(n=>{e.tmpIsDown=!1,Dl(e,n.clientX,n.clientY)}))},1:function(e){window.addEventListener("touchstart",(n=>{e.tmpIsDown=!0;const t=n.touches[0];Rl(e,t.clientX,t.clientY)})),window.addEventListener("touchmove",(n=>{const t=n.touches[0];Rl(e,t.clientX,t.clientY)})),window.addEventListener("touchend",(n=>{e.tmpIsDown=!1;const t=n.touches[0];Rl(e,t.clientX,t.clientY)}))}};var Ll="#pragma DEFINES\n\n#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <depth>\r\n#include <alpha_test>\r\n#include <vcolor_fh>\n\n#ifdef USE_INSTANCING\r\nin float vInstanceId;\r\nin vec4 vInstanceState;\r\n#endif\n\n#pragma BLOCK_BEFORE_RAYMARCH_CONTENT\n\n#include <raymarch_df>\n\n#pragma RAYMARCH_SCENE\n\n#include <raymarch_sf>\r\n#include <os_raymarch_f>\n\nuniform vec4 uBaseColor;\r\nuniform sampler2D uBaseMap;\r\nuniform vec4 uBaseMapTiling;\r\nuniform float uIsPerspective;\r\nuniform float uUseWorld;\r\nuniform vec3 uBoundsScale;\n\nin vec2 vUv;\r\nin vec3 vLocalPosition;\r\nin mat4 vWorldMatrix;\r\nin vec3 vWorldPosition;\r\nin mat4 vInverseWorldMatrix;\n\nout vec4 outColor;\n\nvoid main() {\r\n    vec2 uv = vUv * uBaseMapTiling.xy + uBaseMapTiling.zw;\n\n    vec4 baseMapColor = texture(uBaseMap, uv);\n\n    vec4 baseColor = uBaseColor * baseMapColor;\n\n#ifdef USE_VERTEX_COLOR\r\n    baseColor *= vVertexColor;\r\n#endif\n\n    \n    \n    \n\n    vec3 wp = vWorldPosition;\r\n    vec3 currentRayPosition = wp;\r\n    vec3 rayDirection = getOSRaymarchViewRayDirection(currentRayPosition, uViewPosition, uIsPerspective);\r\n    \r\n    osRaymarch(\r\n        wp,\r\n        rayDirection,\r\n        EPS,\r\n        uViewMatrix,\r\n        uProjectionMatrix,\r\n        vInverseWorldMatrix,\r\n        1.,\r\n        uBoundsScale,\r\n        uUseWorld,\r\n        true,\r\n        currentRayPosition\r\n    );\n\n    \n    \n\n    float alpha = baseColor.a; \n    #include <alpha_test_f>\n\n    outColor = vec4(1., 1., 1., 1.);\r\n}";function Bl(){return[{name:"uIsPerspective",type:y.Float,value:0},{name:"uUseWorld",type:y.Float,value:0}]}function El({fragmentShaderTemplate:e,fragmentShaderContent:n,depthFragmentShaderTemplate:o,depthFragmentShaderContent:l,materialArgs:s}){const{shadingModelId:u=r.Lit,uniforms:f=[],uniformBlockNames:p}=s,d=s.baseMap??null,g=s.baseColor??mr(),h=s.baseMapTiling??xr(1,1,0,0),v=s.roughnessMap??null,x=s.roughnessMapTiling??xr(1,1,0,0),T=s.roughness??0,C=s.metallic??0,M=s.metallicMap??null,w=s.metallicMapTiling??xr(1,1,0,0),R=s.emissiveColor??fr(),D=[{name:S.ObjectSpaceRaymarchBoundsScale,type:y.Vector3,value:Dt()},{name:S.DepthTexture,type:y.Texture,value:null},{name:S.BaseMap,type:y.Texture,value:d},{name:S.BaseColor,type:y.Color,value:g},{name:S.BaseMapTiling,type:y.Vector4,value:h},{name:S.Metallic,type:y.Float,value:C},{name:S.MetallicMap,type:y.Texture,value:M},{name:S.MetallicMapTiling,type:y.Vector4,value:w},{name:S.Roughness,type:y.Float,value:T},{name:S.RoughnessMap,type:y.Texture,value:v},{name:S.RoughnessMapTiling,type:y.Vector4,value:x},{name:S.EmissiveColor,type:y.Color,value:R},...Bl(),{name:S.ShadingModelId,type:y.Int,value:u},...f||[]];return ar({...s,name:"ObjectSpaceRaymarchMaterial",type:c.ObjectSpaceRaymarch,vertexShader:gr,fragmentShader:e||"#pragma DEFINES\n\n#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <tone>\r\n#include <depth>\r\n#include <gbuffer>\r\n#include <alpha_test>\r\n#include <vcolor_fh>\r\n#include <normal_map_fh>\n\n#ifdef USE_INSTANCING\r\nin float vInstanceId;\r\nin vec4 vInstanceColor;\r\nin vec4 vInstanceEmissiveColor;\r\nin vec4 vInstanceState;\r\n#endif\n\n#pragma BLOCK_BEFORE_RAYMARCH_CONTENT\n\n#include <raymarch_df>\n\n#pragma RAYMARCH_SCENE\n\n#include <raymarch_sf>\r\n#include <os_raymarch_f>\n\nuniform vec4 uBaseColor;\r\nuniform sampler2D uBaseMap;\r\nuniform vec4 uBaseMapTiling;\r\nuniform float uSpecularAmount;\r\nuniform float uAmbientAmount;\r\nuniform float uMetallic;\r\nuniform sampler2D uMetallicMap;\r\nuniform vec4 uMetallicMapTiling;\r\nuniform float uRoughness;\r\nuniform sampler2D uRoughnessMap;\r\nuniform vec4 uRoughnessMapTiling;\r\nuniform vec4 uEmissiveColor;\r\nuniform int uShadingModelId;\n\n#pragma APPEND_UNIFORMS\n\nuniform float uIsPerspective;\r\nuniform float uUseWorld;\r\nuniform vec3 uBoundsScale;\n\nin vec2 vUv;\r\nin vec3 vNormal;\n\nin vec3 vLocalPosition;\r\nin mat4 vWorldMatrix;\r\nin vec3 vWorldPosition;\r\nin mat4 vInverseWorldMatrix;\n\n#ifdef USE_NORMAL_MAP\r\nvec3 calcNormal(vec3 normal, vec3 tangent, vec3 binormal, sampler2D normalMap, vec2 uv) {\r\n    vec3 n = normalize(normal);\r\n    vec3 t = normalize(tangent);\r\n    vec3 b = normalize(binormal);\r\n    mat3 tbn = mat3(t, b, n);\r\n    vec3 nt = texture(normalMap, uv).xyz;\r\n    nt = nt * 2. - 1.;\n\n    \n    vec3 resultNormal = normalize(tbn * nt);\r\n    \n    \n    \n\n    return resultNormal;\r\n}\r\n#endif\n\n#include <gbuffer_o>\n\nvoid main() {\r\n    vec4 resultColor = vec4(0, 0, 0, 1);\n\n    vec2 uv = vUv * uBaseMapTiling.xy + uBaseMapTiling.zw;\n\n    vec4 baseMapColor = texture(uBaseMap, uv);\r\n    vec4 baseColor = uBaseColor * baseMapColor;\n\n    vec3 worldNormal = vNormal;\n\n    \n    #ifdef USE_NORMAL_MAP\nworldNormal = calcNormal(vNormal, vTangent, vBinormal, uNormalMap, uv);\n#else\nworldNormal = normalize(vNormal);\n#endif\n\n    #ifdef USE_VERTEX_COLOR\r\n    baseColor *= vVertexColor;\r\n    #endif\r\n    \r\n    \n\n    \n\n    vec3 emissiveColor = uEmissiveColor.rgb;\r\n#ifdef USE_INSTANCING\r\n    emissiveColor = vInstanceEmissiveColor.xyz; \n#endif\n\n    \n    \n    \n\n    vec3 wp = vWorldPosition;\r\n    vec3 currentRayPosition = wp;\r\n    mat4 inverseWorldMatrix = vInverseWorldMatrix;\r\n    vec3 rayDirection = getOSRaymarchViewRayDirection(currentRayPosition, uViewPosition, uIsPerspective);\n\n    vec2 result = osRaymarch(\r\n        wp,\r\n        rayDirection,\r\n        EPS,\r\n        uViewMatrix,\r\n        uProjectionMatrix,\r\n        vInverseWorldMatrix,\r\n        1.,\r\n        uBoundsScale,\r\n        uUseWorld,\r\n        true,\r\n        currentRayPosition\r\n    );\n\n    checkDiscardByCompareRayDepthAndSceneDepth(\r\n        currentRayPosition,\r\n        uDepthTexture,\r\n        uNearClip,\r\n        uFarClip,\r\n        uViewMatrix\r\n    );\n\n    if(result.x > 0.) {\r\n        worldNormal = getNormalObjectSpaceDfScene(\r\n            currentRayPosition,\r\n            inverseWorldMatrix,\r\n            uBoundsScale,\r\n            uUseWorld\r\n        );\r\n    }\r\n \r\n    \n    \n    \n\n    resultColor = baseColor;\n\n    float alpha = resultColor.a;\r\n    #include <alpha_test_f>\n\n    resultColor.rgb = gamma(resultColor.rgb);\n\n    \n    float metallic = uMetallic;\r\n    metallic *= texture(uMetallicMap, uv * uMetallicMapTiling.xy).r;\r\n    float roughness = uRoughness;\r\n    roughness *= texture(uRoughnessMap, uv * uRoughnessMapTiling.xy).r;\n\n    outGBufferA = EncodeGBufferA(resultColor.rgb);\r\n    outGBufferB = EncodeGBufferB(worldNormal, uShadingModelId);\r\n    outGBufferC = EncodeGBufferC(metallic, roughness);\r\n    outGBufferD = EncodeGBufferD(emissiveColor.rgb);\r\n}",depthFragmentShader:o||Ll,primitiveType:t.Triangles,faceSide:m.Double,uniforms:D,depthUniforms:D,depthTest:!0,depthWrite:!0,depthFuncType:a.Lequal,skipDepthPrePass:!0,renderQueueType:i.Opaque,uniformBlockNames:[b.Common,b.Transformations,b.Camera,...p||[]],fragmentShaderModifiers:[{pragma:P.RAYMARCH_SCENE,value:n},...s.fragmentShaderModifiers??[]],depthFragmentShaderModifiers:[{pragma:P.RAYMARCH_SCENE,value:l},...s.depthFragmentShaderModifiers??[]]})}function Il(e=!0){const n=document.createElement("div"),t=document.createElement("div");return e&&(n.style.cssText="\n                background-color: rgb(200 200 255 / 70%);\n                position: absolute;\n                top: 0px;\n                right: 0px;\n                box-sizing: border-box;\n                padding: 0px 10px 10px 10px;\n                display: grid;\n                justify-items: start;\n                \n                font-size: 9px;\n                font-weight: bold;\n                line-height: 1.2em;\n                min-width: 200px;\n                opacity: 0.5;\n        "),t.style.cssText="\n            width: 100%;\n        ",n.appendChild(t),{rootElement:n,containerElement:t}}const Al=e=>{const n=document.createElement("div");n.style.cssText="\n            box-sizing: border-box;\n            padding-top: 8px;\n        ";const t=document.createElement("div");if(n.appendChild(t),e){const n=document.createElement("span");n.style.cssText="\n                padding-right: 1em;\n            ",n.textContent=e,t.appendChild(n)}const r=document.createElement("div");return n.appendChild(r),{wrapperElement:n,headerElement:t,contentElement:r}},Nl=(e,n,t=!0)=>{const r=Il(!1),a=document.createElement("p");a.textContent=n,a.style.cssText="\n            font-size: 11px;\n            font-style: italic;\n            box-sizing: border-box;\n            padding: 4px 0 0 0;\n            cursor: pointer;\n        ",r.rootElement.insertBefore(a,r.containerElement);const o=()=>{r.containerElement.classList.remove("is-hidden"),r.containerElement.style.cssText="",a.textContent=` ${n}`},i=()=>{r.containerElement.classList.add("is-hidden"),r.containerElement.style.cssText="display: none;",a.textContent=` ${n}`};return a.addEventListener("click",(()=>{r.containerElement.classList.contains("is-hidden")?o():i()})),t?o():i(),e.containerElement.appendChild(r.rootElement),r},kl=(e,{label:n,onChange:t,onInput:r=null,initialValue:a=null,initialExec:o=!0})=>{const{wrapperElement:i,contentElement:l}=Al(n),s=document.createElement("input");s.type="color",s.addEventListener("change",(()=>{t(s.value)})),s.addEventListener("input",(()=>{r?r(s.value):t(s.value)})),null!==a&&(s.value=a),o&&t(s.value),l.appendChild(s),e.containerElement.appendChild(i)},Ol=(e,{label:n,onChange:t,initialValue:r=null,initialExec:a=!0})=>{const{wrapperElement:o,contentElement:i}=Al(n),l=document.createElement("input");l.type="checkbox",l.checked=!!r,l.addEventListener("change",(()=>{t(l.checked)})),a&&t(l.checked),i.appendChild(l),e.containerElement.appendChild(o)},_l=(e,{label:n,onChange:t,onInput:r,initialValue:a,initialExec:o=!0,minValue:i,maxValue:l,stepValue:s})=>{const{wrapperElement:u,headerElement:c,contentElement:m}=Al(n),f=document.createElement("span"),p=document.createElement("input"),d=()=>{f.textContent=`value: ${p.value}`},g=()=>(d(),Number.parseFloat(p.value));p.type="range",p.min=i.toString(),p.max=l.toString(),null!==s&&(p.step=s.toString()),p.addEventListener("change",(()=>g())),p.addEventListener("input",(()=>{r?r(g()):t(g())})),null!==a&&(p.value=a.toString()),o?t(g()):d(),c.appendChild(f),m.appendChild(p),e.containerElement.appendChild(u)},Vl=e=>{const n=document.createElement("hr");n.style.cssText="\n            width: 100%;\n            height: 1px;\n            border: none;\n            border-top: 1px solid #777;\n            margin: 0.5em 0 0.25em 0;\n        ",e.containerElement.appendChild(n)};var Ul="uniform float uMorphRate;\n\nfloat blend(float a, float b, float c, float d, float t1, float t2, float t) {\n    float segTime = t1 + t2;\n    float totalTime = 3.0 * segTime;\n\n    float localT = mod(t, totalTime);\n\n    if (localT < t2) {\n        return a;\n    } else if (localT < segTime * 1.0) {\n        float st = (localT - t2) / t1;\n        return mix(a, b, smoothstep(0.0, 1.0, st));\n    } else if (localT < segTime * 1.0 + t2) {\n        return b;\n    } else if (localT < segTime * 2.0) {\n        float st = (localT - segTime * 1.0 - t2) / t1;\n        return mix(b, c, smoothstep(0.0, 1.0, st));\n    } else if (localT < segTime * 2.0 + t2) {\n        return c;\n    } else {\n        float st = (localT - segTime * 2.0 - t2) / t1;\n        return mix(c, d, smoothstep(0.0, 1.0, st));\n    }\n}\n\nfloat jewelry(vec3 p, float t) {\n    float d = 10000.;\n\n    vec3 scale = vec3(.8);\n    \n    p = opPreScale(p, scale);\n    \n    p.xy = opRo(p.xy, t * .3);\n\n    p.xy = opFoldRotate(p.xy, 5.);\n    \n    p = opTr(p, vec3(0., 2.2, 0.));\n\n    \n    p.yz = opRo(p.yz, t * .25);\n\n    float c = cos(PI / 4.);\n    float s = sqrt(.75 - c * c);\n    vec3 n = vec3(-.5, -c, s);\n    \n    float o = 2.;\n    \n    p = abs(p);\n    p -= o * min(0., dot(p, n)) * n;\n\n    p.xz = abs(p.xz);\n    p -= o * min(0., dot(p, n)) * n;\n    \n    p.xz = abs(p.xz);\n    p -= o * min(0., dot(p, n)) * n;    \n    \n    d = p.z - 1.2;\n\n    d = opPostScale(d, scale);\n    \n    return d;\n}\n\nfloat ring(vec3 p, float t) {\n    float d = 10000.;\n    \n    \n    \n    p.xy = opRo(p.xy, -t * .3);\n    \n    vec3 scale = vec3(.8);\n    \n    p = opPreScale(p, scale);\n    \n    p.xy = opFoldRotate(p.xy, 6.);\n\n    for(int i = 0; i < 2; i++) {\n        float fi = float(i);\n        p = opTr(p, vec3(0., fi * .6 + 1.2, 0.));\n        vec3 _p = p;\n        _p.yz = opRo(_p.yz, PI * .25 * sin(t + fi * 10.));\n        d = min(d, dfBox(_p, vec3(8., .5, .5)));\n    }\n    \n    d = opPostScale(d, scale);\n    \n    return d;\n}\n\nfloat box(vec3 p, float t) {\n    p.xz = opRo(p.xz, t * .25);\n    p.xy = opRo(p.xy, t * .25);\n    float d = dfBox(p, vec3(1.6));\n    return d;\n}\n\nvec2 dfScene(vec3 p) {\n    float d = 10000.;\n    \n    vec3 q = p;\n\n    float t = uMorphRate;\n\n    vec3 scale = vec3(1.);\n    \n    p = opPreScale(p, scale);\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n  \n    float d1 = jewelry(p1, t);\n\n    float d2 = box(p2, t);\n    \n    float d3 = ring(p3, t);\n\n    d = blend(d1, d2, d3, d1, 1.8, 1.8, t);\n\n    return vec2(d, 0.);\n}";function zl(e){const{fragmentShaderTemplate:n,fragmentShaderContent:t,depthFragmentShaderTemplate:o,depthFragmentShaderContent:i,shadingModelId:l=r.Unlit,uniforms:s=[],uniformBlockNames:u}=e,m=e.baseMap??null,f=e.baseColor??mr(),p=e.baseMapTiling??xr(1,1,0,0),d=e.emissiveColor??fr(),g=[{name:S.ObjectSpaceRaymarchBoundsScale,type:y.Vector3,value:Dt()},{name:S.DepthTexture,type:y.Texture,value:null},{name:S.BaseMap,type:y.Texture,value:m},{name:S.BaseColor,type:y.Color,value:f},{name:S.BaseMapTiling,type:y.Vector4,value:p},{name:S.EmissiveColor,type:y.Color,value:d},...Bl(),...Hr(),{name:S.ShadingModelId,type:y.Int,value:l},...s||[]];return ar({...e,name:"ObjectSpaceRaymarchGlassMaterial",type:c.ObjectSpaceRaymarch,vertexShader:gr,fragmentShader:n||"#pragma DEFINES\n\n#include <common>\n#include <lighting>\n#include <ub>\n#include <tone>\n#include <depth>\n#include <alpha_test>\n#include <vcolor_fh>\n\n#ifdef USE_INSTANCING\nin float vInstanceId;\nin vec4 vInstanceColor;\nin vec4 vInstanceEmissiveColor;\nin vec4 vInstanceState;\n#endif\n\n#pragma BLOCK_BEFORE_RAYMARCH_CONTENT\n\n#include <raymarch_df>\n\n#pragma RAYMARCH_SCENE\n\n#include <raymarch_sf>\n#include <os_raymarch_f>\n#include <geometry_h>\n#include <skybox_h>\n\nuniform vec4 uBaseColor;\nuniform sampler2D uBaseMap;\nuniform vec4 uBaseMapTiling;\nuniform vec4 uEmissiveColor;\nuniform int uShadingModelId;\n\n#pragma APPEND_UNIFORMS\n\nuniform float uIsPerspective;\nuniform float uUseWorld;\nuniform vec3 uBoundsScale;\n\nuniform sampler2D uSceneTexture;\n\nin vec2 vUv;\n\nin vec3 vLocalPosition;\nin mat4 vWorldMatrix;\nin vec3 vWorldPosition;\nin mat4 vInverseWorldMatrix;\n\nout vec4 outColor;\n\nmat2 rot2(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat signedAngle(vec3 a, vec3 b, vec3 axis) {\n    vec3 na = normalize(a);\n    vec3 nb = normalize(b);\n    float angle = acos(clamp(dot(na, nb), -1.0, 1.0)); \n    float sign = dot(axis, cross(na, nb));\n    return sign < 0.0 ? -angle : angle;\n}\n\nvec2 shiftReflUv(\n    vec2 uv,\n    vec3 rdIn,\n    vec3 rdOut,\n    vec3 n,\n    float ior,\n    float offsetPower,\n    float offsetBase\n) {\n    \n    float angleInOut = signedAngle(rdIn, rdOut, vec3(0., 0., 1.));\n    \n    \n    uv -= .5;\n    \n    uv *= rot2(offsetPower * ior * angleInOut);\n    uv += .5;\n    uv += offsetBase;\n    return uv;\n}\n\nvoid main() {\n    vec4 resultColor = uBaseColor * vec4(0.);\n\n    vec2 uv = vUv * uBaseMapTiling.xy + uBaseMapTiling.zw;\n\n    vec4 baseMapColor = texture(uBaseMap, uv);\n    vec4 baseColor = uBaseColor * baseMapColor;\n\n#ifdef USE_VERTEX_COLOR\n    baseColor *= vVertexColor;\n#endif\n    \n    vec3 emissiveColor = uEmissiveColor.rgb;\n#ifdef USE_INSTANCING\n    emissiveColor = vInstanceEmissiveColor.xyz; \n#endif\n\n    \n    \n    \n\n    vec3 wp = vWorldPosition;\n    vec3 currentRayPosition = wp;\n    vec3 rayDirection = getOSRaymarchViewRayDirection(currentRayPosition, uViewPosition, uIsPerspective);\n\n    vec2 result = osRaymarch(\n        wp,\n        rayDirection,\n        EPS,\n        uViewMatrix,\n        uProjectionMatrix,\n        vInverseWorldMatrix,\n        1.,\n        uBoundsScale,\n        uUseWorld,\n        true,\n        currentRayPosition\n    );\n   \n    \n    \n    \n    \n    \n    \n    \n    \n\n    resultColor = baseColor;\n   \n    vec2 screenUv = gl_FragCoord.xy / uViewport.xy;\n    resultColor = texture(uSceneTexture, screenUv);\n    \n    vec3 resultBackBufferColor = vec3(0.);\n    vec3 reflTex = vec3(0.);\n    \n    float ior = 1.45;\n    float rayIORShift = .005;\n    float uvIORShiftBase = .002;\n    float uvIORShiftPower = .05;\n    float specBlendRate = .85;\n    \n    if(result.x > 0.) {\n        \n        vec3 p = currentRayPosition;\n        \n        vec3 n = getNormalObjectSpaceDfScene(\n            p,\n            vInverseWorldMatrix,\n            uBoundsScale,\n            uUseWorld\n        );\n        \n        \n        \n        vec3 rdIn = refract(rayDirection, n, 1. / ior);\n     \n        \n        vec3 pEnter = p - n * EPS * 3.;\n        \n        vec2 dIn = osRaymarch(\n            pEnter,\n            rdIn,\n            EPS,\n            uViewMatrix,\n            uProjectionMatrix,\n            vInverseWorldMatrix,\n            -1.,\n            uBoundsScale,\n            uUseWorld,\n            false,\n            p\n        );\n       \n        \n        vec3 pExit = p;\n        \n        \n        vec3 nExit = -getNormalObjectSpaceDfScene(\n            pExit,\n            vInverseWorldMatrix,\n            uBoundsScale,\n            uUseWorld\n        );\n       \n        vec2 reflUv = screenUv;\n        vec3 envSpecularDir = vec3(0.);\n        vec3 rdOut = vec3(0.);\n\n        \n        \n        rdOut = refract(rdIn, nExit, ior - rayIORShift);\n        \n        if(dot(rdOut, rdOut) == 0.) {\n            rdOut = reflect(rdIn, nExit);\n        }\n        \n        reflUv = shiftReflUv(screenUv, rdIn, rdOut, n, ior, uvIORShiftPower, -uvIORShiftBase);\n        \n        envSpecularDir = calcEnvMapSampleDir(rdOut, uSkybox.rotationOffset);\n        resultBackBufferColor.r = texture(uSceneTexture, reflUv).r;\n        reflTex.r = textureLod(uSkybox.cubeMap, envSpecularDir, 0.).r;\n\n        \n        \n        rdOut = refract(rdIn, nExit, ior);\n        \n        if(dot(rdOut, rdOut) == 0.) {\n            rdOut = reflect(rdIn, nExit);\n        }\n        \n        reflUv = shiftReflUv(screenUv, rdIn, rdOut, n, ior, uvIORShiftPower, 0.);\n        \n        envSpecularDir = calcEnvMapSampleDir(rdOut, uSkybox.rotationOffset);\n        resultBackBufferColor.g = texture(uSceneTexture, reflUv).g;\n        reflTex.g = textureLod(uSkybox.cubeMap, envSpecularDir, 0.).g;\n\n        \n        \n        rdOut = refract(rdIn, nExit, ior + rayIORShift);\n        \n        if(dot(rdOut, rdOut) == 0.) {\n            rdOut = reflect(rdIn, nExit);\n        }\n        \n        reflUv = shiftReflUv(screenUv, rdIn, rdOut, n, ior, uvIORShiftPower, uvIORShiftBase);\n        \n        envSpecularDir = calcEnvMapSampleDir(rdOut, uSkybox.rotationOffset);\n        resultBackBufferColor.b = texture(uSceneTexture, reflUv).b;\n        reflTex.b = textureLod(uSkybox.cubeMap, envSpecularDir, 0.).b;\n\n        resultColor.xyz = vec3(dIn.x) * 0.; \n    }\n\n    float alpha = resultColor.a;\n    #include <alpha_test_f>\n\n    resultColor.rgb = mix(\n        resultBackBufferColor,\n        gamma(reflTex),\n        specBlendRate\n    );\n    \n    #pragma BEFORE_OUT\n    \n    outColor = resultColor;\n\n    #pragma AFTER_OUT\n}",depthFragmentShader:o||Ll,uniforms:g,depthUniforms:g,depthTest:e.depthTest??!0,depthWrite:e.depthWrite??!1,depthFuncType:e.depthFuncType??a.Lequal,uniformBlockNames:[b.Common,b.Transformations,b.Camera,...u||[]],fragmentShaderModifiers:[{pragma:P.RAYMARCH_SCENE,value:t},...e.fragmentShaderModifiers??[]],depthFragmentShaderModifiers:[{pragma:P.RAYMARCH_SCENE,value:i},...e.depthFragmentShaderModifiers??[]]})}const jl="/labs/morph-glass/assets/models/",Gl=document.createElement("style");let Wl,Hl,$l,Xl,ql,Jl,Yl;Gl.innerText="\n:root {\n  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;\n  line-height: 1.5;\n  font-weight: 400;\n  color-scheme: light dark;\n  font-synthesis: none;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-text-size-adjust: 100%;\n}\n\nbody {\n  overflow: hidden;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  font-family: sans-serif;\n} \n\n#wrapper {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\ncanvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: black;\n}\n",document.head.appendChild(Gl);const Kl={morphRate:0,morphingEnabled:!0},Zl=(window.navigator.userAgent.match(/(iPhone|iPad|iPod|Android)/i),{type:0,beforeInputPosition:ha(),currentInputPosition:ha(),deltaInputPosition:ha(),deltaNormalizedInputPosition:ha(),normalizedInputPosition:ha(),isPressed:!1,isDown:!1,isReleased:!1,tmpIsDown:!1,tmpInputPosition:ha(),width:0,height:0});(e=>{Fl[e.type](e)})(Zl);const Ql=document.createElement("div");document.body.appendChild(Ql),Ql.setAttribute("id","wrapper");const es=document.createElement("canvas");Ql.appendChild(es);const ns=es.getContext("webgl2",{antialias:!1,preserveDrawingBuffer:!0});if(!ns)throw"invalid gl";const ts=function(e){let n=null,t=null,r=null;const a={gl:e,shader:null,vao:null,uniforms:null,dummyTexture:n,dummyTextureBlack:t,dummyCubeTexture:r,validExtensions:[],invalidExtensions:[],uboBindingPoint:0};return n=ke({gpu:a,img:Je("white"),wrapS:p.Repeat,wrapT:p.Repeat}),a.dummyTexture=n,t=ke({gpu:a,img:Je("black"),wrapS:p.Repeat,wrapT:p.Repeat}),a.dummyTextureBlack=t,r=Ge(a,Je(),Je(),Je(),Je(),Je(),Je()),a.dummyCubeTexture=r,a}(ns),rs={children:[]},as=Math.min(window.devicePixelRatio,1.5),os=function({gpu:n,canvas:r,pixelRatio:i=1.5}){const l=[],s=_i(),u=yi(s),c=Mr({gpu:n,type:v.Depth,width:1,height:1,name:"depth pre-pass render target",depthPrecision:g.High}),x=function({gpu:e,name:n,width:t=1,height:r=1}){const a=[],o=d.Linear,i=d.Linear,l=e.gl,s=Ve({gpu:e});ze(s);const u=Le.COLOR_ATTACHMENT0,c=ke({gpu:e,width:t,height:r,mipmap:!1,type:f.RGBA,minFilter:o,magFilter:i});l.framebufferTexture2D(B,u,D,c.glObject,0),a.push(c),Ue(s,u);const m=Le.COLOR_ATTACHMENT1,p=ke({gpu:e,width:t,height:r,mipmap:!1,type:f.RGBA,minFilter:o,magFilter:i});l.framebufferTexture2D(B,m,D,p.glObject,0),Ue(s,m),a.push(p);const g=Le.COLOR_ATTACHMENT2,v=ke({gpu:e,width:t,height:r,mipmap:!1,type:f.RGBA,minFilter:o,magFilter:i});l.framebufferTexture2D(B,g,D,v.glObject,0),Ue(s,g),a.push(v);const x=Le.COLOR_ATTACHMENT3,T=ke({gpu:e,width:t,height:r,mipmap:!1,type:f.R11F_G11F_B10F,minFilter:o,magFilter:i});return l.framebufferTexture2D(B,x,D,T.glObject,0),Ue(s,x),a.push(T),l.bindTexture(D,null),je(s),{...Pr(h.GBuffer,!1),gpu:e,name:n,width:t,height:r,framebuffer:s,gBufferTextures:a,gBufferATexture:c,gBufferBTexture:p,gBufferCTexture:v,gBufferDTexture:T,depthTexture:null}}({gpu:n,width:1,height:1,name:"g-buffer render target"}),C=Mr({gpu:n,type:v.Empty,width:1,height:1,name:"after g-buffer render target"}),M=Mr({gpu:n,type:v.Empty,width:1,height:1,name:"copy depth source render target",depthPrecision:g.High}),P=Mr({gpu:n,type:v.Depth,width:1,height:1,name:"copy depth dest render target",depthPrecision:g.High}),w=Mr({gpu:n,type:v.Empty,width:1,height:1,name:"copy scene source render target"}),R=Mr({gpu:n,type:v.R11F_G11F_B10F,width:1,height:1,name:"copy scene dest render target"}),F=function(e){const{gpu:n,enabled:t}=e,r=e.bias??0,a=e.jitterSize??ft(.025,.025,.025),o=e.sharpness??2,i=e.strength??1,l=e.ratio??.5,s=e.rayStepMultiplier??1;return{...Ir({gpu:n,type:10,fragmentShader:"#pragma DEFINES\n\n#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <rand>\r\n#include <depth>\n\nconst int MARCH_COUNT = 48;\n\nin vec2 vUv;\n\nout vec4 outColor;\r\n\nuniform sampler2D uGBufferBTexture;\r\nuniform float uBias;\r\nuniform vec3 uJitterSize;\r\nuniform float uSharpness;\r\nuniform float uStrength;\r\nuniform float uRayStepMultiplier;\n\nvoid calcOcclusion(PointLight pointLight, vec3 worldPosition, vec3 viewPosition, vec3 jitterOffset, out float occlusion) {\r\n    vec3 rawLightPos = pointLight.position;\r\n    vec3 rawLightPosInView = (uViewMatrix * vec4(pointLight.position, 1.)).xyz;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vec3 rayOriginInView = rawLightPosInView + jitterOffset * uJitterSize;\r\n    vec3 lightPosInView = rawLightPosInView;\r\n    vec3 diffInView = viewPosition - rayOriginInView;\n\n    vec3 rayDirInView = normalize(diffInView);\r\n    float stepLength = (length(diffInView) / float(MARCH_COUNT)) * uRayStepMultiplier;\r\n    float sharpness = uSharpness / float(MARCH_COUNT);\n\n    \n\n    vec3 debugValue = vec3(0.);\n\n    for(int i = 0; i < MARCH_COUNT; i++) {\r\n        \n        float currentStepLength = stepLength * float(i);\r\n        vec3 currentRayInView = rayOriginInView + rayDirInView * currentStepLength;\r\n        vec4 currentRayInClip = uProjectionMatrix * vec4(currentRayInView, 1.);\r\n        currentRayInClip /= currentRayInClip.w;\r\n        float currentRayRawDepth = ndcZToRawDepth(currentRayInClip.z);\n\n        \n        vec2 rayUv = currentRayInClip.xy * .5 + .5;\r\n        \n        float currentRawDepthInPixel = textureLod(uDepthTexture, rayUv, 0.).x;\r\n        vec3 currentViewPositionInPixel = reconstructViewPositionFromDepth(\r\n            rayUv,\r\n            currentRawDepthInPixel,\r\n            uInverseProjectionMatrix\r\n        );\r\n        \r\n        \n        \n        \n        \n        \n        \n        \n\n        \n        \n        \n        float dz = abs(currentRayInView.z);\r\n        if(\r\n            dz > abs(currentViewPositionInPixel.z)\r\n        ) {\r\n            \n            \n            occlusion += sharpness * saturate(pointLight.intensity) * (1. - smoothstep(60., 80., dz));\r\n        }\r\n    }\r\n}\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    float rawDepth = texture(uDepthTexture, uv).x;\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n    \r\n    if(sceneDepth > .9999) {\r\n        outColor = vec4(0., 0., 0., 1.);\r\n        return;\r\n    }\r\n    \r\n    vec3 worldPosition = reconstructWorldPositionFromDepth(\r\n        uv,\r\n        texture(uDepthTexture, uv).x,\r\n        uInverseViewProjectionMatrix\r\n    );\r\n    vec3 viewPosition = (uViewMatrix * vec4(worldPosition, 1.)).xyz;\r\n    viewPosition = reconstructViewPositionFromDepth(\r\n        uv,\r\n        texture(uDepthTexture, uv).x,\r\n        uInverseProjectionMatrix\r\n    );\n\n    float jitterSpeed = 1.;\r\n    vec3 jitterOffset = normalize(vec3(\r\n        rand(uv + uTime * jitterSpeed + .1),\r\n        rand(uv + uTime * jitterSpeed + .2),\r\n        \n        rand(uv + uTime * jitterSpeed + .3)\r\n    ) * 2. - 1.);\n\n    float occlusion = 0.;\r\n   \r\n    \n    \n    #pragma UNROLL_START 1\r\n        calcOcclusion(uPointLight[UNROLL_N], worldPosition, viewPosition, jitterOffset, occlusion);\r\n    #pragma UNROLL_END\n\n    occlusion *= uStrength;\n\n    outColor = vec4(vec3(occlusion), 1.);\r\n    \r\n    \n    \n}",uniforms:[{name:S.GBufferBTexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:za,type:y.Float,value:0},{name:ja,type:y.Vector3,value:Rt()},{name:Ga,type:y.Float,value:0},{name:Wa,type:y.Float,value:0},{name:Ha,type:y.Float,value:0}],uniformBlockNames:[b.Common,b.Transformations,b.Camera,b.PointLight],enabled:t}),bias:r,jitterSize:a,sharpness:o,strength:i,ratio:l,rayStepMultiplier:s}}({gpu:n}),L=function(e){const{gpu:n,enabled:t}=e,r=e.occlusionSampleLength??.121,a=e.occlusionBias??1e-4,o=e.occlusionMinDistance??.006,i=e.occlusionMaxDistance??.2,l=e.occlusionColor??fr(),s=e.occlusionPower??1.85,u=e.occlusionStrength??.448,c=e.blendRate??1,{samplingRotations:m,samplingDistances:d,samplingTexture:g}=(e=>{const n=[.1*Math.PI,Math.PI*(1/3*4+.1),Math.PI*(1/3*2+.1),Math.PI*(1/3*1+.1),1.1*Math.PI,Math.PI*(1/3*5+.1)],t=1/16*Math.PI*2,r=new Array(16).fill(0).map(((e,n)=>{return[(r=t*(4*n),a=t*(4*n+4),(r+(a-r)*Math.random())%(2*Math.PI)),1+.0625*n,1,1];var r,a})).flat(),a=ke({gpu:e,width:4,height:4,type:f.RGBA32F,wrapS:p.Repeat,wrapT:p.Repeat});return _e(a,{width:4,height:4,data:new Float32Array(r)}),{samplingRotations:n,samplingDistances:[.1,.8/6*4+.1,.8/6*2+.1,.8/6*1+.1,.5,.8/6*5+.1],samplingTexture:a}})(n);return{...Ir({gpu:n,enabled:t,type:11,fragmentShader:"#pragma DEFINES\n\n#include <lighting>\r\n#include <ub>\r\n#include <depth>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uGBufferBTexture;\r\nuniform float[6] uSamplingRotations;\r\nuniform float[6] uSamplingDistances;\r\nuniform mat4 uSamplingTableMatrix;\r\nuniform sampler2D uSamplingTexture;\r\nuniform float uOcclusionSampleLength;\r\nuniform float uOcclusionBias;\r\nuniform float uOcclusionMinDistance;\r\nuniform float uOcclusionMaxDistance;\r\nuniform vec4 uOcclusionColor;\r\nuniform float uOcclusionPower;\r\nuniform float uOcclusionStrength;\r\nuniform float uBlendRate;\n\nmat2 getRotationMatrix(float rad) {\r\n    float c = cos(rad);\r\n    float s = sin(rad);\r\n    return mat2(\r\n        c, -s,\r\n        s, c\r\n    );\r\n}\n\nvoid main() {\n\n    float occludedAcc = 0.;\r\n    int samplingCount = 6;\n\n    float eps = .0001;\n\n    vec2 uv = vUv;\r\n    \r\n    \n    vec4 baseColor = vec4(1., 1., 1., 0.);\r\n    \r\n    \n    \n\n    float rawDepth = texture(uDepthTexture, uv).x;\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n    \r\n    vec3 worldNormal = normalize(texture(uGBufferBTexture, uv).xyz * 2. - 1.);\r\n    vec3 viewNormal = normalize((uTransposeInverseViewMatrix * vec4(worldNormal, 1.)).xyz);\r\n    \r\n    vec3 viewPosition = reconstructViewPositionFromDepth(\r\n        uv,\r\n        texture(uDepthTexture, uv).x,\r\n        uInverseProjectionMatrix\r\n    );\r\n   \r\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    vec2 samplingTableCoord = gl_FragCoord.xy / 4.; \n    vec4 samplingTable = texture(uSamplingTexture, samplingTableCoord);\r\n    float samplingOffsetRad = samplingTable.x;\r\n    float samplingOffsetLen = samplingTable.y;\r\n   \r\n    \n    \n    \n\n    if (sceneDepth > 1. - eps) {\r\n        outColor = baseColor;\r\n        return;\r\n    }\n\n    for (int i = 0; i < samplingCount; i++) {\r\n        mat2 rot = getRotationMatrix(uSamplingRotations[i] + samplingOffsetRad);\n\n        float offsetLen = uSamplingDistances[i] * samplingOffsetLen * uOcclusionSampleLength;\r\n        vec3 offsetA = vec3(rot * vec2(1., 0.), 0.) * offsetLen;\r\n        vec3 offsetB = -offsetA;\r\n    \r\n        float rawDepthA = sampleRawDepthByViewPosition(uDepthTexture, viewPosition, uProjectionMatrix, offsetA);\r\n        float rawDepthB = sampleRawDepthByViewPosition(uDepthTexture, viewPosition, uProjectionMatrix, offsetB);\n\n        float depthA = perspectiveDepthToLinearDepth(rawDepthA, uNearClip, uFarClip);\r\n        float depthB = perspectiveDepthToLinearDepth(rawDepthB, uNearClip, uFarClip);\n\n        vec3 viewPositionA = reconstructViewPositionFromDepth(\r\n            uv,\r\n            rawDepthA,\r\n            uInverseProjectionMatrix\r\n        );\r\n        vec3 viewPositionB = reconstructViewPositionFromDepth(\r\n            uv,\r\n            rawDepthB,\r\n            uInverseProjectionMatrix\r\n        );\n\n        float distA = distance(viewPositionA, viewPosition);\r\n        float distB = distance(viewPositionB, viewPosition);\n\n        \n        \n        \n        \n        \n        \n        \n        if (distA < uOcclusionMinDistance || uOcclusionMaxDistance < distA) {\r\n            continue;\r\n        }\r\n        if (distB < uOcclusionMinDistance || uOcclusionMaxDistance < distB) {\r\n            continue;\r\n        }\n\n        vec3 surfaceToCameraDir = -normalize(viewPosition);\r\n        \r\n        vec3 angleDirA = normalize(viewPositionA - viewPosition);\r\n        vec3 angleDirB = normalize(viewPositionB - viewPosition);\r\n        \r\n        float cameraDirDotA = dot(angleDirA, surfaceToCameraDir);\r\n        float cameraDirDotB = dot(angleDirB, surfaceToCameraDir);\r\n        \r\n        float normalDotA = dot(viewNormal, angleDirA);\r\n        float normalDotB = dot(viewNormal, angleDirB);\r\n        \r\n        float clampedDotA = cameraDirDotA - min(normalDotA, 0.);\r\n        float clampedDotB = cameraDirDotB - min(normalDotB, 0.);\r\n        \r\n        \n        \n        \n        \n        \n        float ao = max(0., clampedDotA + clampedDotB);\r\n        \n\n        occludedAcc += ao;\r\n    }\r\n    \r\n    float aoRate = occludedAcc / float(samplingCount);\r\n  \r\n    aoRate = clamp(aoRate, 0., 1.);\r\n    \r\n    aoRate = pow(aoRate, uOcclusionPower);\n\n    vec4 color = mix(\r\n        baseColor,\r\n        uOcclusionColor,\r\n        clamp(aoRate * uBlendRate * uOcclusionStrength, 0., 1.)\r\n    );\n\n    color.a = 1.;\r\n    \r\n    outColor = color;\n\n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:S.GBufferBTexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:"uSamplingRotations",type:y.FloatArray,value:new Float32Array(m)},{name:"uSamplingDistances",type:y.FloatArray,value:new Float32Array(d)},{name:"uSamplingTexture",type:y.Texture,value:g},{name:"uOcclusionSampleLength",type:y.Float,value:1},{name:"uOcclusionBias",type:y.Float,value:1},{name:"uOcclusionMinDistance",type:y.Float,value:1},{name:"uOcclusionMaxDistance",type:y.Float,value:1},{name:"uOcclusionColor",type:y.Color,value:fr()},{name:"uOcclusionPower",type:y.Float,value:1},{name:"uOcclusionStrength",type:y.Float,value:1},{name:"uBlendRate",type:y.Float,value:1}],uniformBlockNames:[b.Transformations,b.Camera]}),occlusionSampleLength:r,occlusionBias:a,occlusionMinDistance:o,occlusionMaxDistance:i,occlusionColor:l,occlusionPower:s,occlusionStrength:u,blendRate:c,samplingTexture:g}}({gpu:n}),E=function(n){const{gpu:t}=n;return{...Ir({gpu:t,type:9,name:"DeferredShadingPass",fragmentShader:"#pragma DEFINES\n\n#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <depth>\r\n#include <gbuffer>\r\n#include <geometry_h>\r\n#include <skybox_h>\r\n\nstruct IncidentLight {\r\n    vec3 color;\r\n    vec3 direction; \n    bool visible;\r\n    float intensity;\r\n};\n\nstruct ReflectedLight {\r\n    vec3 directBase;\r\n    vec3 directSpecular;\r\n    vec3 indirectBase;\r\n    vec3 indirectSpecular;\r\n};\n\nstruct Material {\r\n    vec3 baseColor;\r\n    vec3 specularColor;\r\n    float roughness;\r\n    float metallic;\r\n};\n\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\r\n    return any(bvec2(cutoffDistance == 0., lightDistance < cutoffDistance));\r\n}\n\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float attenuationComponent) {\r\n    if (attenuationComponent > 0.) {\r\n        return pow(saturate(-lightDistance / cutoffDistance + 1.), attenuationComponent);\r\n    }\n\n    return 1.;\r\n}\r\n\nvoid getDirectionalLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n    directLight.color = directionalLight.color.xyz;\r\n    directLight.direction = -directionalLight.direction; \n    directLight.visible = true;\r\n    directLight.intensity = directionalLight.intensity;\r\n}\r\n\nvoid getSpotLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n    \n    vec3 surfaceToLight = spotLight.position - geometry.position;\r\n    vec3 PtoL = normalize(surfaceToLight);\r\n    vec3 LtoP = -PtoL;\r\n    directLight.direction = PtoL;\r\n    directLight.intensity = spotLight.intensity;\n\n    float lightDistance = length(surfaceToLight);\r\n    \n    float angleCos = dot(LtoP, spotLight.direction);\n\n    \n    \n    \n\n    \n    float coneCos = spotLight.coneCos;\r\n    float penumbraCos = spotLight.penumbraCos;\n\n    if (all(\r\n    bvec2(\r\n    angleCos > coneCos,\r\n    testLightInRange(lightDistance, spotLight.distance)\r\n    )\r\n    )) {\r\n        float spotEffect = smoothstep(coneCos, penumbraCos, angleCos);\r\n        directLight.color = spotLight.color.xyz;\r\n        directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.attenuation);\r\n        directLight.visible = true;\r\n    } else {\r\n        directLight.color = vec3(0.);\r\n        directLight.visible = false;\r\n    }\r\n}\r\n\nvoid getPointLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {\r\n    vec3 surfaceToLight = pointLight.position - geometry.position;\r\n    float lightDistance = length(surfaceToLight);\r\n    vec3 L = normalize(surfaceToLight);\n\n    directLight.direction = L;\r\n    directLight.intensity = pointLight.intensity;\n\n    if (testLightInRange(lightDistance, pointLight.distance)) {\r\n        directLight.color = pointLight.color.xyz;\r\n        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.attenuation);\r\n        directLight.visible = true;\r\n    } else {\r\n        directLight.color = vec3(0.);\r\n        directLight.visible = false;\r\n    }\n\n    \n\n    \n    \n    \n    \n    \n}\r\n\nvec3 BaseBRDF(vec3 baseColor) {\r\n    return baseColor / PI;\r\n}\r\n\nvec3 F_Shhlick(vec3 specularColor, vec3 H, vec3 V) {\r\n    return (specularColor + (1. - specularColor) * pow(1. - saturate(dot(V, H)), 5.));\r\n}\n\nvec3 schlick(vec3 f0, float product) {\r\n    return f0 + (1. - f0) * pow((1. - product), 5.);\r\n}\n\nfloat D_GGX(float a, float dotNH) {\r\n    float a2 = a * a;\r\n    float dotNH2 = dotNH * dotNH;\r\n    float d = dotNH2 * (a2 - 1.) + 1.;\r\n    return a2 / max((PI * d * d), EPSILON);\r\n}\n\nfloat G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {\r\n    float k = a * a * .5 + EPSILON;\r\n    float gl = dotNL / (dotNL * (1. - k) + k);\r\n    float gv = dotNV / (dotNV * (1. - k) + k);\r\n    return gl * gv;\r\n}\n\nvec3 SpecularBRDF(const vec3 lightDirection, const in GeometricContext geometry, vec3 specularColor, float roughnessFactor) {\r\n    vec3 N = normalize(geometry.normal);\r\n    vec3 V = normalize(geometry.viewDir);\r\n    vec3 L = normalize(lightDirection);\n\n    float dotNL = saturate(dot(N, L));\r\n    float dotNV = saturate(dot(N, V));\r\n    vec3 H = normalize(L + V);\r\n    float dotNH = saturate(dot(N, H));\r\n    float dotVH = saturate(dot(V, H));\r\n    float dotLV = saturate(dot(L, V));\n\n    float a = roughnessFactor * roughnessFactor;\n\n    float D = D_GGX(a, dotNH);\r\n    float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);\r\n    vec3 F = F_Shhlick(specularColor, V, H);\n\n    return (F * (G * D)) / (4. * dotNL * dotNV + EPSILON);\r\n}\r\n\nvoid RE_Direct(\r\n    const in IncidentLight directLight,\r\n    const in GeometricContext geometry,\r\n    const in Material material,\r\n    inout ReflectedLight reflectedLight,\r\n    const in float shadow\r\n) {\r\n    \n    float dotNL = saturate(dot(geometry.normal, directLight.direction));\r\n    vec3 irradiance = dotNL * directLight.color;\n\n    \n    irradiance *= PI;\r\n    irradiance *= directLight.intensity;\r\n    irradiance *= (1. - shadow);\n\n    \n    reflectedLight.directBase +=\r\n        irradiance *\r\n        clamp(\r\n            BaseBRDF(material.baseColor),\r\n            -10.,\r\n            10.\r\n        ); \n    \n    \n    reflectedLight.directSpecular +=\r\n        irradiance *\r\n        clamp(\r\n            SpecularBRDF(\r\n                directLight.direction,\r\n                geometry,\r\n                material.specularColor,\r\n                material.roughness\r\n            ),\r\n        -10.,\r\n        10.\r\n    ); \n}\n\nvoid RE_DirectSkyboxFakeIBL(\r\n    samplerCube cubeMap,\r\n    const in IncidentSkyboxLight skyboxLight,\r\n    const in GeometricContext geometry,\r\n    const in Material material,\r\n    inout ReflectedLight reflectedLight\r\n) {\r\n    \n    \n    \n\n    vec3 envDiffuseColor = textureLod(\r\n        cubeMap,\r\n        skyboxLight.diffuseDirection,\r\n        skyboxLight.maxLodLevel\r\n    ).xyz;\n\n    \n    reflectedLight.directBase +=\r\n        material.baseColor\r\n        * envDiffuseColor\r\n        * skyboxLight.diffuseIntensity;\n\n    \n    \n    \n\n    \n    \n    float specularLod = log2(material.roughness * pow(2., skyboxLight.maxLodLevel));\r\n    vec3 envSpecularColor = textureLod(\r\n        cubeMap,\r\n        skyboxLight.specularDirection,\r\n        specularLod\r\n    ).xyz;\n\n    \n\n    vec3 fresnel = schlick(material.specularColor, max(0., dot(geometry.viewDir, geometry.normal)));\n\n    \n    \n    \n\n    reflectedLight.directSpecular += mix(\r\n        envSpecularColor * skyboxLight.specularIntensity * material.specularColor,\r\n        envSpecularColor * skyboxLight.specularIntensity,\r\n        fresnel\r\n    );\n\n    \n    \n    \n}\r\n\nconst vec2 poissonDisk[4] = vec2[](\r\n    vec2(-0.94201624, -0.39906216),\r\n    vec2(0.94558609, -0.76890725),\r\n    vec2(-0.094184101, -0.92938870),\r\n    vec2(0.34495938, 0.29387760)\r\n);\r\n\nfloat calcDirectionalLightShadowAttenuation(\r\n    vec3 worldPosition,\r\n    vec3 worldNormal,\r\n    vec3 lightDirection, \n    mat4 shadowMapProjectionMatrix,\r\n    sampler2D shadowMap,\r\n    float shadowBias,\r\n    vec4 shadowColor,\r\n    float shadowBlendRate\r\n) {\r\n    float NoL = max(dot(worldNormal, -lightDirection), 0.);\r\n    float bias = .005 * tan(acos(NoL));\r\n    bias = clamp(bias, .1, .5); \n    \r\n    vec4 lightPos = shadowMapProjectionMatrix * vec4(worldPosition, 1.);\r\n    vec2 uv = lightPos.xy;\r\n    float depthFromWorldPos = lightPos.z;\n\n    float shadowAreaSmooth = .25;\r\n    float shadowAreaRect =\r\n        \n        \n        \n        \n        \n        smoothstep(0., shadowAreaSmooth, uv.x) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.x)) *\r\n        smoothstep(0., shadowAreaSmooth, uv.y) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.y)) *\r\n        step(0., depthFromWorldPos) * (1. - step(1., depthFromWorldPos));\n\n    float visibility = 1.;\r\n    float readDepth = 0.;\r\n    vec2 offset = vec2(0.);\n\n    \n    #pragma UNROLL_START 4\r\n        offset = poissonDisk[UNROLL_N] / 800.;\r\n        readDepth = textureLod(shadowMap, uv + offset, 0.).r;\r\n        \n        if(readDepth < lightPos.z - bias) {\r\n            visibility -= .25;\r\n        }\r\n    #pragma UNROLL_END\r\n    \r\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    float shadow = (1. - visibility) * shadowAreaRect * shadowBlendRate;\r\n    return clamp(shadow, 0., 1.);\r\n}\n\nfloat calcSpotLightShadowAttenuation(\r\n    vec3 worldPosition,\r\n    vec3 worldNormal,\r\n    vec3 lightDirection, \n    mat4 lightViewProjectionTextureMatrix,\r\n    sampler2D shadowMap,\r\n    float shadowBias,\r\n    vec4 shadowColor,\r\n    float shadowBlendRate\r\n) {\r\n    float rNoL = dot(worldNormal, -lightDirection);\r\n    float NoL = max(rNoL, 0.);\r\n    float bias = .005 * tan(acos(NoL));\r\n    bias = clamp(bias, .01, .02); \n\n    vec4 lightPos = lightViewProjectionTextureMatrix * vec4(worldPosition, 1.);\r\n    vec2 uv = lightPos.xy / lightPos.w;\r\n    float depthFromWorldPos = lightPos.z / lightPos.w;\r\n    \r\n    float shadowAreaSmooth = .25;\r\n    float shadowAreaRect =\r\n        \n        \n        \n        \n        \n        smoothstep(0., shadowAreaSmooth, uv.x) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.x)) *\r\n        smoothstep(0., shadowAreaSmooth, uv.y) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.y)) *\r\n        step(0., depthFromWorldPos) * (1. - step(1., depthFromWorldPos));\n\n    float visibility = 1.;\r\n    vec2 offset = vec2(0.);\r\n    float readDepth = 0.;\n\n    \n    \n    \n    \n    #pragma UNROLL_START 4\r\n        offset = poissonDisk[UNROLL_N] / 100.;\r\n        readDepth = textureLod(shadowMap, uv + offset, 0.).r;\r\n        visibility -= step(readDepth, depthFromWorldPos - bias) * .25;\r\n        \n        \n        \n    #pragma UNROLL_END\r\n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \r\n    float faceSmooth = smoothstep(0., 0.001, rNoL);\r\n    \r\n    float shadow = (1. - visibility) * shadowAreaRect * shadowBlendRate * faceSmooth;\r\n    return clamp(shadow, 0., 1.);\r\n}\n\nuniform float uShadowBias;\r\n\nin vec2 vUv;\n\nuniform sampler2D uDirectionalLightShadowMap;\r\nuniform sampler2D uSpotLightShadowMap[MAX_SPOT_LIGHT_COUNT];\n\nuniform sampler2D uGBufferATexture;\r\nuniform sampler2D uGBufferBTexture;\r\nuniform sampler2D uGBufferCTexture;\r\nuniform sampler2D uGBufferDTexture;\r\nuniform sampler2D uScreenSpaceShadowTexture;\r\nuniform sampler2D uAmbientOcclusionTexture;\n\n       \r\n\nlayout (location = 0) out vec4 outColor;\n\nvoid main() {\r\n    vec4 resultColor = vec4(0, 0, 0, 1);\n\n    vec2 uv = vUv;\n\n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\r\n    GBufferB gBufferB = DecodeGBufferB(uGBufferBTexture, uv);\r\n    GBufferC gBufferC = DecodeGBufferC(uGBufferCTexture, uv);\r\n    GBufferD gBufferD = DecodeGBufferD(uGBufferDTexture, uv);\n\n    \n    \n    vec3 baseColor = gBufferA.baseColor;\r\n    float metallic = gBufferC.metallic;\r\n    float roughness = gBufferC.roughness;\r\n    vec3 emissiveColor = gBufferD.emissiveColor;\r\n    float shadingModelId = gBufferB.shadingModelId;\r\n    vec3 worldNormal = gBufferB.normal;\n\n    \n    float rawDepth = texture(uDepthTexture, uv).r;\r\n    float depth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n\n    \n    vec3 worldPosition = reconstructWorldPositionFromDepth(uv, rawDepth, uInverseViewProjectionMatrix);\n\n    \n    if (step(rawDepth, 1. - .00001) < .5) {\r\n        outColor = vec4(baseColor, 1.); \r\n        \n        \n        \n        return;\r\n    }\n\n    \n    \n    if (1.5 < shadingModelId && shadingModelId < 2.5) {\r\n        resultColor = vec4(emissiveColor, 1.);\r\n        \n        \n        \n        \n        \n        \n        \n        outColor = resultColor;\r\n        return;\r\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    float aoRate = texture(uAmbientOcclusionTexture, uv).r;\r\n    float sssRate = texture(uScreenSpaceShadowTexture, uv).x;\n\n    \n    \n    \n    \n    \n    \n    \n\n    Surface surface;\r\n    surface.worldPosition = worldPosition;\r\n    surface.worldNormal = worldNormal;\r\n    surface.baseColor = vec4(baseColor, 1.);\n\n    \n    surface.specularAmount = .5;\n\n    \n    \n    \n\n    \n    GeometricContext geometry;\r\n    geometry.position = surface.worldPosition;\r\n    geometry.normal = surface.worldNormal;\r\n    geometry.viewDir = normalize(uViewPosition - surface.worldPosition);\r\n    Material material;\r\n    vec3 albedo = baseColor;\r\n    material.baseColor = albedo;\r\n    material.baseColor = mix(albedo, vec3(0.), metallic);\n    material.specularColor = mix(vec3(.04), albedo, metallic);\n    material.roughness = roughness;\r\n    material.metallic = metallic;\r\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.), vec3(0.), vec3(0.), vec3(0.));\r\n    \n    float opacity = 1.;\n\n    IncidentLight directLight;\r\n    float shadow = 0.;\n\n    \n    \n    \n\n    \n    \n    \n\n    DirectionalLight directionalLight;\r\n    directionalLight.direction = uDirectionalLight.direction;\r\n    directionalLight.color = uDirectionalLight.color;\r\n    directionalLight.intensity = uDirectionalLight.intensity;\r\n    getDirectionalLightIrradiance(directionalLight, geometry, directLight);\r\n    shadow = calcDirectionalLightShadowAttenuation(\r\n        worldPosition,\r\n        surface.worldNormal,\r\n        uDirectionalLight.direction,\r\n        uDirectionalLight.shadowMapProjectionMatrix,\r\n        uDirectionalLightShadowMap,\r\n        uShadowBias,\r\n        vec4(vec3(.02), 1.), \n        .5 \n    );\r\n    RE_Direct(directLight, geometry, material, reflectedLight, shadow);\r\n    \r\n    \n    \n    \n    SpotLight spotLight;\r\n    \n    \n    #pragma UNROLL_START MAX_SPOT_LIGHT_COUNT\r\n        getSpotLightIrradiance(uSpotLight[UNROLL_N], geometry, directLight);\r\n        shadow = calcSpotLightShadowAttenuation(\r\n            worldPosition,\r\n            surface.worldNormal,\r\n            uSpotLight[UNROLL_N].direction,\r\n            uSpotLight[UNROLL_N].shadowMapProjectionMatrix,\r\n            uSpotLightShadowMap[UNROLL_N], \n            uShadowBias,\r\n            vec4(vec3(.02), 1.), \n            .65 \n        );\r\n        RE_Direct(directLight, geometry, material, reflectedLight, shadow);\r\n    #pragma UNROLL_END\r\n    \n \r\n    \n    \n    \n\n    PointLight pointLight;\n\n    \n    #pragma UNROLL_START MAX_POINT_LIGHT_COUNT\r\n       getPointLightIrradiance(uPointLight[UNROLL_N], geometry, directLight);\r\n       RE_Direct(directLight, geometry, material, reflectedLight, sssRate * .25); \n    #pragma UNROLL_END\r\n    \n\n    \n    \n    \n\n#ifdef USE_ENV_MAP\r\n    SkyboxLight skyboxLight;\r\n    skyboxLight.diffuseIntensity = uSkybox.diffuseIntensity;\r\n    skyboxLight.specularIntensity = uSkybox.specularIntensity;\r\n    skyboxLight.rotationOffset = uSkybox.rotationOffset;\r\n    skyboxLight.maxLodLevel = uSkybox.maxLodLevel;\r\n    IncidentSkyboxLight directSkyboxLight;\r\n    directSkyboxLight.diffuseDirection = vec3(0.); \n    getSkyboxLightIrradiance(skyboxLight, geometry, directSkyboxLight);\r\n    RE_DirectSkyboxFakeIBL(uSkybox.cubeMap, directSkyboxLight, geometry, material, reflectedLight);\r\n#endif\n\n    \n    \n    \n\n    vec3 outgoingLight =\r\n        reflectedLight.directBase\r\n        + reflectedLight.directSpecular\r\n        + reflectedLight.indirectBase\r\n        + reflectedLight.indirectSpecular\r\n        ;\r\n    resultColor = vec4(outgoingLight, opacity);\n\n    \n    resultColor.xyz *= aoRate;\n\n    \n    resultColor.xyz += emissiveColor;\r\n    \r\n    outColor = resultColor;\r\n   \r\n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:S.GBufferATexture,type:y.Texture,value:null},{name:S.GBufferBTexture,type:y.Texture,value:null},{name:S.GBufferCTexture,type:y.Texture,value:null},{name:S.GBufferDTexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:"uScreenSpaceShadowTexture",type:y.Texture,value:null},{name:"uAmbientOcclusionTexture",type:y.Texture,value:null},{name:S.DirectionalLightShadowMap,type:y.Texture,value:null},{name:S.SpotLightShadowMap,type:y.TextureArray,value:Vr.range(e).map((()=>null))},...Hr()],useEnvMap:!0,receiveShadow:!0,renderTargetType:v.R11F_G11F_B10F,uniformBlockNames:[b.Camera,b.DirectionalLight,b.SpotLight,b.PointLight],enabled:n.enabled})}}({gpu:n}),I=function(e){const{gpu:n,enabled:t}=e,r=e.rayDepthBias??.0099,a=e.rayNearestDistance??.13,o=e.rayMaxDistance??3.25,i=e.reflectionRayThickness??.3,l=e.reflectionRayJitterSizeX??.05,s=e.reflectionRayJitterSizeY??.05,u=e.reflectionFadeMinDistance??0,c=e.reflectionFadeMaxDistance??4.2,m=e.reflectionScreenEdgeFadeFactorMinX??.42,f=e.reflectionScreenEdgeFadeFactorMaxX??.955,p=e.reflectionScreenEdgeFadeFactorMinY??.444,d=e.reflectionScreenEdgeFadeFactorMaxY??1,g=e.reflectionRoughnessPower??.5,h=e.reflectionAdditionalRate??.355,x=e.blendRate??1;return{...Ir({gpu:n,type:12,fragmentShader:"#pragma DEFINES\n\n#include <lighting>\r\n#include <ub>\r\n#include <rand>\r\n#include <depth>\r\n#include <gbuffer>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uGBufferATexture;\r\nuniform sampler2D uGBufferBTexture;\r\nuniform sampler2D uGBufferCTexture;\r\nuniform float uBlendRate;\n\nuniform float uRayDepthBias;\r\nuniform float uRayNearestDistance;\r\nuniform float uRayMaxDistance;\r\nuniform float uReflectionRayThickness;\n\nuniform float uReflectionRayJitterSizeX;\r\nuniform float uReflectionRayJitterSizeY;\n\nuniform float uReflectionFadeMinDistance;\r\nuniform float uReflectionFadeMaxDistance;\n\nuniform float uReflectionScreenEdgeFadeFactorMinX;\r\nuniform float uReflectionScreenEdgeFadeFactorMaxX;\r\nuniform float uReflectionScreenEdgeFadeFactorMinY;\r\nuniform float uReflectionScreenEdgeFadeFactorMaxY;\n\nuniform float uReflectionRoughnessPower;\n\nuniform float uReflectionAdditionalRate;\n\nvoid main() {\r\n    float eps = .001;\n\n    int maxIterationNum = 16;\r\n    int binarySearchNum = 4;\n\n    \n\n    vec2 uv = vUv;\r\n   \r\n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\r\n    GBufferB gBufferB = DecodeGBufferB(uGBufferBTexture, uv);\r\n    GBufferC gBufferC = DecodeGBufferC(uGBufferCTexture, uv);\n\n    vec3 worldNormal = gBufferB.normal;\r\n    vec3 viewNormal = normalize((uTransposeInverseViewMatrix * vec4(worldNormal, 1.)).xyz);\r\n    \r\n    vec4 baseColor = texture(uSrcTexture, uv);\r\n    vec4 reflectionColor = vec4(0., 0., 0., 1.);\n\n    vec3 viewPosition = reconstructViewPositionFromDepth(\r\n        vUv,\r\n        texture(uDepthTexture, uv).r,\r\n        uInverseProjectionMatrix\r\n    );\r\n   \r\n    \n    vec3 randomDir = normalize(vec3(\r\n        rand(uv + .1),\r\n        rand(uv + .2),\r\n        rand(uv + .3)\r\n    ) * 2. - 1.);\n\n    vec3 incidentViewDir = normalize(viewPosition);\r\n    vec3 reflectViewDir = reflect(incidentViewDir, viewNormal);\r\n    vec3 rayViewDir = reflectViewDir + randomDir * gBufferC.roughness * uReflectionRoughnessPower;\n\n    vec3 rayViewOrigin = viewPosition;\n\n    float rayDeltaStep = uRayMaxDistance / float(maxIterationNum);\n\n    vec3 currentRayInView = rayViewOrigin;\n\n    bool isHit = false;\n\n    float fadeFactor = 1.;\n\n    float jitter = rand(uv + uTime) * 2. - 1.;\n\n    vec2 jitterOffset = vec2(\r\n        jitter * uReflectionRayJitterSizeX,\r\n        jitter * uReflectionRayJitterSizeY\r\n    );\n\n    float rawDepth = texture(uDepthTexture, uv).x;\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n    if (sceneDepth > 1. - eps) {\r\n        outColor = baseColor;\r\n        return;\r\n    }\n\n    for (int i = 0; i < maxIterationNum; i++) {\r\n        float stepLength = rayDeltaStep * (float(i) + 1.) + uRayNearestDistance;\r\n        currentRayInView = rayViewOrigin + vec3(jitterOffset, 0.) + rayViewDir * stepLength;\r\n        \n        float sampledDepth = sampleRawDepthByViewPosition(\r\n            uDepthTexture,\r\n            currentRayInView,\r\n            uProjectionMatrix,\r\n            vec3(0.)\r\n        );\r\n        vec3 sampledViewPosition = reconstructViewPositionFromDepth(uv, sampledDepth, uInverseProjectionMatrix);\n\n        vec4 currentRayInClip = uProjectionMatrix * vec4(currentRayInView, 1.);\r\n        currentRayInClip.xyz = currentRayInClip.xyz / currentRayInClip.w;\n\n        if (abs(currentRayInClip.x) > 1. || abs(currentRayInClip.y) > 1.) {\r\n            break;\r\n        }\n\n        float dist = sampledViewPosition.z - currentRayInView.z;\n\n        if (uRayDepthBias < dist && dist < uReflectionRayThickness) {\r\n            isHit = true;\r\n            break;\r\n        }\r\n    }\n\n    if (isHit) {\r\n        currentRayInView -= rayViewDir * rayDeltaStep;\n\n        float rayBinaryStep = rayDeltaStep;\r\n        float stepSign = 1.;\r\n        vec3 sampledViewPosition = viewPosition;\n\n        for (int i = 0; i < binarySearchNum; i++) {\r\n            rayBinaryStep *= .5 * stepSign;\r\n            currentRayInView += rayViewDir * rayBinaryStep;\r\n            float sampledRawDepth = sampleRawDepthByViewPosition(\r\n                uDepthTexture,\r\n                currentRayInView,\r\n                uProjectionMatrix,\r\n                vec3(0.)\r\n            );\r\n            sampledViewPosition = reconstructViewPositionFromDepth(\r\n                uv,\r\n                sampledRawDepth,\r\n                uInverseProjectionMatrix\r\n            );\r\n            float dist = sampledViewPosition.z - currentRayInView.z;\r\n            stepSign = uRayDepthBias < dist ? -1. : 1.;\r\n        }\n\n        vec4 currentRayInClip = uProjectionMatrix * vec4(currentRayInView, 1.);\r\n        vec2 rayUV = (currentRayInClip.xy / currentRayInClip.w) * .5 + .5;\n\n        float screenEdgeFadeFactorX = (abs(uv.x * 2. - 1.) - uReflectionScreenEdgeFadeFactorMinX) / max(uReflectionScreenEdgeFadeFactorMaxX - uReflectionScreenEdgeFadeFactorMinX, eps);\r\n        float screenEdgeFadeFactorY = (abs(uv.y * 2. - 1.) - uReflectionScreenEdgeFadeFactorMinY) / max(uReflectionScreenEdgeFadeFactorMaxY - uReflectionScreenEdgeFadeFactorMinY, eps);\n\n        screenEdgeFadeFactorX = 1. - clamp(screenEdgeFadeFactorX, 0., 1.);\r\n        screenEdgeFadeFactorY = 1. - clamp(screenEdgeFadeFactorY, 0., 1.);\n\n        float rayWithSampledPositionDistance = distance(viewPosition, sampledViewPosition);\r\n        float distanceFadeRate = (rayWithSampledPositionDistance - uReflectionFadeMinDistance) / max(uReflectionFadeMaxDistance - uReflectionFadeMinDistance, eps);\r\n        distanceFadeRate = clamp(distanceFadeRate, 0., 1.);\r\n        distanceFadeRate = 1. - distanceFadeRate * distanceFadeRate;\n\n        fadeFactor = distanceFadeRate * screenEdgeFadeFactorX * screenEdgeFadeFactorY;\r\n    \r\n        \n        vec4 surfaceCoefficient = vec4(\r\n            mix(\r\n                vec3(.04),\r\n                gBufferA.baseColor * gBufferC.metallic,\r\n                gBufferC.metallic\r\n            ),\r\n            1.\r\n        );\r\n        reflectionColor += texture(uSrcTexture, rayUV) * surfaceCoefficient * fadeFactor * uReflectionAdditionalRate;\r\n        \r\n        \n        \n    }\n\n    vec4 color = mix(baseColor, baseColor + reflectionColor, uBlendRate);\r\n    outColor = color;\r\n    \r\n    \n    \n}",uniforms:[{name:S.GBufferATexture,type:y.Texture,value:null},{name:S.GBufferBTexture,type:y.Texture,value:null},{name:S.GBufferCTexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:"uRayDepthBias",type:y.Float,value:0},{name:"uRayNearestDistance",type:y.Float,value:0},{name:"uRayMaxDistance",type:y.Float,value:0},{name:"uReflectionAdditionalRate",type:y.Float,value:0},{name:"uReflectionRayThickness",type:y.Float,value:0},{name:"uReflectionRayJitterSizeX",type:y.Float,value:0},{name:"uReflectionRayJitterSizeY",type:y.Float,value:0},{name:"uReflectionFadeMinDistance",type:y.Float,value:0},{name:"uReflectionFadeMaxDistance",type:y.Float,value:0},{name:"uReflectionScreenEdgeFadeFactorMinX",type:y.Float,value:0},{name:"uReflectionScreenEdgeFadeFactorMaxX",type:y.Float,value:0},{name:"uReflectionScreenEdgeFadeFactorMinY",type:y.Float,value:0},{name:"uReflectionScreenEdgeFadeFactorMaxY",type:y.Float,value:0},{name:"uReflectionRoughnessPower",type:y.Float,value:0},{name:"uBlendRate",type:y.Float,value:1}],renderTargetType:v.R11F_G11F_B10F,uniformBlockNames:[b.Common],enabled:t}),rayDepthBias:r,rayNearestDistance:a,rayMaxDistance:o,reflectionRayThickness:i,reflectionRayJitterSizeX:l,reflectionRayJitterSizeY:s,reflectionFadeMinDistance:u,reflectionFadeMaxDistance:c,reflectionScreenEdgeFadeFactorMinX:m,reflectionScreenEdgeFadeFactorMaxX:f,reflectionScreenEdgeFadeFactorMinY:p,reflectionScreenEdgeFadeFactorMaxY:d,reflectionRoughnessPower:g,reflectionAdditionalRate:h,blendRate:x}}({gpu:n}),A=function(e){const{gpu:n,enabled:t,ratio:r=.5}=e,a=e.blendRate??.65,o=e.passScaleBase??.2,i=e.rayStepStrength??.012,l=Lr({gpu:n}),s=[],u=qr({gpu:n,fragmentShader:"#include <depth>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uNearClip;\r\nuniform float uFarClip;\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\r\n    float rawDepth = texture(uDepthTexture, vUv).r;\r\n    \n    float eyeDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n   \r\n    \n    float mask = step(.0001, 1. - rawDepth) * rawDepth;\n\n    float edgeWidth = .05; \r\n    float edgeMask =\r\n        smoothstep(0., edgeWidth, vUv.x) *\r\n        (1. - smoothstep(1. - edgeWidth, 1., vUv.x)) *\r\n        smoothstep(0., edgeWidth, vUv.y) *\r\n        (1. - smoothstep(1. - edgeWidth, 1., vUv.y));\r\n        \r\n    mask *= edgeMask;\r\n    \r\n    outColor = vec4(vec3(mask), 1.);\r\n}",renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:S.DepthTexture,type:y.Texture,value:null},...Nr()]});s.push(...u.materials);const c=qr({gpu:n,fragmentShader:Na,renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:_a,type:y.Float,value:0},{name:ka,type:y.Vector2,value:ha()},{name:Oa,type:y.Float,value:o},{name:Va,type:y.Float,value:i}]});s.push(...c.materials);const m=qr({gpu:n,fragmentShader:Na,renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:_a,type:y.Float,value:1},{name:ka,type:y.Vector2,value:ha()},{name:Oa,type:y.Float,value:o},{name:Va,type:y.Float,value:i}]});s.push(...m.materials);const f=qr({gpu:n,fragmentShader:Na,renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:_a,type:y.Float,value:2},{name:ka,type:y.Vector2,value:ha()},{name:Oa,type:y.Float,value:o},{name:Va,type:y.Float,value:i}]});s.push(...f.materials);const p=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uLightShaftTexture;\r\nuniform float uBlendRate;\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\r\n    vec4 destColor = sceneColor;\r\n    vec4 lightShaftColor = texture(uLightShaftTexture, vUv);\r\n    float occlusion = mix(0., 1., lightShaftColor.x * lightShaftColor.x);\n\n    occlusion *= uBlendRate;\r\n   \r\n    \n    \r\n    outColor = vec4(vec3(occlusion), 1.);\r\n}",renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:"uLightShaftTexture",type:y.Texture,value:null},{name:S.BlendRate,type:y.Float,value:a}]});return s.push(...p.materials),{...Er({gpu:n,name:"LightShaftPass",type:8,geometry:l,materials:s,enabled:t}),directionalLight:null,lightShaftDownSamplePass:u,blur1Pass:c,blur2Pass:m,blur3Pass:f,compositePass:p,ratio:r,blendRate:a,passScaleBase:o,rayStepStrength:i}}({gpu:n}),N=function(n){const{gpu:r,enabled:i}=n,l=n.rayStep??.62,s=n.blendRate??1,u=n.densityMultiplier??1,c=n.rayJitterSize??ft(.1,.1,.1),f=n.ratio??.5,p=Mr({gpu:r,type:v.Depth,width:1,height:1,depthPrecision:g.High}),d=ar({vertexShader:`\nlayout (location = 0) in vec3 ${T.Position};\nuniform mat4 ${S.WorldMatrix};\nuniform mat4 ${S.ViewMatrix};\nuniform mat4 ${S.ProjectionMatrix};\nvoid main() {vec4 wp=${S.WorldMatrix}*vec4(${T.Position},1.);gl_Position=${S.ProjectionMatrix}*${S.ViewMatrix}*wp;}\n`,fragmentShader:"\nout vec4 o; void main(){o=vec4(1.,0.,0.,1.);}",primitiveType:t.Triangles,blendType:o.Opaque,depthFuncType:a.Lequal,depthWrite:!0,depthTest:!0,faceSide:m.Double,uniforms:[{name:S.WorldMatrix,type:y.Matrix4,value:null},{name:S.ViewMatrix,type:y.Matrix4,value:null},{name:S.ProjectionMatrix,type:y.Matrix4,value:null}]});return{...Ir({gpu:r,type:16,fragmentShader:"#pragma DEFINES\n\n#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <rand>\r\n#include <depth>\r\n#include <gbuffer>\n\n#define MARCH_COUNT 64\r\n#define MARCH_COUNT_F 64.\n\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\r\n    return any(bvec2(cutoffDistance == 0., lightDistance < cutoffDistance));\r\n}\n\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float attenuationComponent) {\r\n    if (attenuationComponent > 0.) {\r\n        return pow(saturate(-lightDistance / cutoffDistance + 1.), attenuationComponent);\r\n    }\n\n    return 1.;\r\n}\r\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uGBufferATexture;\r\nuniform sampler2D uVolumetricDepthTexture;\r\nuniform float uBlendRate;\n\nuniform sampler2D uSpotLightShadowMap[MAX_SPOT_LIGHT_COUNT];\r\nuniform float uDensityMultiplier;\r\nuniform float uRayStep;\r\nuniform vec3 uRayJitterSize;\n\nfloat calcTransmittance(\r\n    SpotLight spotLight,\r\n    sampler2D spotLightShadowMap,\r\n    vec3 rayPosInWorld,\r\n    vec3 rayPosInView,\r\n    float viewZFromDepth\r\n) {\r\n    float rate = 0.;\r\n    \r\n    vec4 rayPosInProjectionTexture = spotLight.shadowMapProjectionMatrix * vec4(rayPosInWorld, 1.);\r\n    vec3 projectionCoord = rayPosInProjectionTexture.xyz / rayPosInProjectionTexture.w;\r\n    vec3 shadowUv = projectionCoord;\r\n    float rayDepthInProjection = rayPosInProjectionTexture.z / rayPosInProjectionTexture.w;\r\n    float spotLightShadowDepth = texture(spotLightShadowMap, shadowUv.xy).r;\r\n    float isShadowArea =\r\n        step(0., shadowUv.x) * (1. - step(1., shadowUv.x)) *\r\n        step(0., shadowUv.y) * (1. - step(1., shadowUv.y)) *\r\n        step(0., shadowUv.z) * (1. - step(1., shadowUv.z));\n\n    vec3 rayToLight = spotLight.position - rayPosInWorld;\r\n    vec3 PtoL = normalize(rayToLight);\r\n    vec3 LtoP = -PtoL;\r\n    float lightDistance = length(rayToLight);\r\n    float angleCos = dot(normalize(LtoP), spotLight.direction);\n\n    float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\r\n    float attenuation = punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.attenuation);\r\n   \r\n    if(abs(rayPosInView.z) < viewZFromDepth) {\r\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \r\n        if(all(bvec2(\r\n            angleCos > spotLight.coneCos,\r\n            testLightInRange(lightDistance, spotLight.distance)\r\n        ))) {\r\n            if(all(bvec2(\r\n                spotLightShadowDepth < rayDepthInProjection, \n                spotLightShadowDepth < 1. \n            ))) {\r\n            } else {\r\n                \n                rate += (1. / MARCH_COUNT_F) * attenuation * spotEffect * isShadowArea * uDensityMultiplier;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return rate;\r\n}\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\r\n    float rawDepth = texture(uDepthTexture, uv).r;\n\n    float jitter = rand(uv + uTime) * 2. - 1.;\r\n    \n    \n    \n    \n    \n    \n    vec3 jitterOffset = uRayJitterSize * jitter * vec3(1., 1., 1.);\n\n    \n    \n    \n    float rawDepthFrustum = texture(uVolumetricDepthTexture, vUv).r;\r\n    float sceneDepthFrustum = perspectiveDepthToLinearDepth(rawDepthFrustum, uNearClip, uFarClip);\r\n    vec3 worldPositionFrustum = reconstructWorldPositionFromDepth(\r\n        vUv,\r\n        texture(uVolumetricDepthTexture, vUv).x,\r\n        uInverseViewProjectionMatrix\r\n    );\r\n    vec3 worldPosition = worldPositionFrustum;\n\n    \n    \n    \n    \n    vec3 vpos = vec3(uv * 2. - 1., 1.);\r\n    vec3 viewDir = (uInverseProjectionMatrix * vpos.xyzz * uFarClip).xyz;\r\n    vec3 viewDirInWorld = (uInverseViewMatrix * vec4(viewDir, 0.)).xyz;\r\n    vec3 rayDir = normalize(viewDirInWorld);\r\n    vec3 rayOrigin = uViewPosition + jitterOffset * rayDir.xyz;\r\n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n\n    float rayStep = 0.;\n\n    vec4 accColor = vec4(vec3(0.), 1.);\r\n    float transmittance = 0.; \n\n    float[MAX_SPOT_LIGHT_COUNT] fogRateArray;\n\n    vec3 rayPosInWorld;\r\n    vec3 rayPosInView;\r\n    float viewZFromDepth = perspectiveDepthToEyeDepth(rawDepth, uNearClip, uFarClip);\r\n \r\n    for(int i = 0; i < MARCH_COUNT; i++) {\r\n        rayStep = uRayStep * float(i);\r\n        rayPosInWorld = rayOrigin + rayDir * rayStep;\r\n        rayPosInView = (uViewMatrix * vec4(rayPosInWorld, 1.)).xyz;\r\n        #pragma UNROLL_START MAX_SPOT_LIGHT_COUNT\r\n            fogRateArray[UNROLL_N] += calcTransmittance(\r\n                uSpotLight[UNROLL_N],\r\n                uSpotLightShadowMap[UNROLL_N],\r\n                rayPosInWorld,\r\n                rayPosInView,\r\n                viewZFromDepth\r\n            );\r\n        #pragma UNROLL_END\r\n    }\r\n   \r\n    \n    \n    \n    \r\n    vec4 fogColor = vec4(0.);\r\n    float fogRate = 0.;\r\n  \r\n    vec4 currentFogColor = vec4(0.); \r\n    float currentFogRate = 0.; \r\n    \r\n        \n        \n        \n        \n        \n        \n        \n        \n\n    #pragma UNROLL_START MAX_SPOT_LIGHT_COUNT\r\n        currentFogRate = fogRateArray[UNROLL_N] * uSpotLight[UNROLL_N].intensity * uBlendRate;\r\n        fogRate += currentFogRate;\n\n        currentFogColor = currentFogRate * uSpotLight[UNROLL_N].color;\r\n        fogColor += currentFogColor;\r\n    #pragma UNROLL_END\n\n    accColor.a = fogRate; \n    accColor.rgb = fogColor.xyz;\r\n   \r\n    accColor.a = 1.; \n    outColor = accColor;\r\n    \r\n    \n    \n    \n    \n}",uniforms:[{name:S.SpotLightShadowMap,type:y.TextureArray,value:Vr.range(e).map((()=>null))},{name:ao,type:y.Float,value:0},{name:oo,type:y.Float,value:0},{name:io,type:y.Vector3,value:Rt()},{name:S.GBufferATexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:ro,type:y.Texture,value:null},{name:S.BlendRate,type:y.Float,value:1}],uniformBlockNames:[b.Common,b.Transformations,b.Camera,b.SpotLight],renderTargetType:v.RGBA16F,enabled:i}),spotLights:[],spotLightFrustumMaterial:d,renderTargetSpotLightFrustum:p,rawWidth:1,rawHeight:1,rayStep:l,blendRate:s,densityMultiplier:u,rayJitterSize:c,ratio:f}}({gpu:n}),k=function(e){const{gpu:n,enabled:t}=e,r=e.fogColor??mr(),a=e.fogStrength??.01,o=e.fogDensity??.023,i=e.fogDensityAttenuation??.45,l=e.fogEndHeight??1,s=e.distanceFogStart??20,u=e.distanceFogPower??.1,c=e.distanceFogEnd??100,m=e.sssFogRate??1,f=e.sssFogColor??mr(),p=e.blendRate??1;return{...Ir({gpu:n,type:18,fragmentShader:"#include <common>\r\n#include <lighting>\r\n#include <ub>\r\n#include <depth>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uLightShaftTexture;\r\nuniform sampler2D uVolumetricLightTexture;\r\nuniform sampler2D uSSSTexture;\r\nuniform sampler2D uNoiseTexture;\r\nuniform vec4 uFogColor;\r\nuniform float uFogStrength;\r\nuniform float uFogDensity;\r\nuniform float uFogDensityAttenuation;\r\nuniform float uFogEndHeight;\r\nuniform float uDistanceFogStart;\r\nuniform float uDistanceFogEnd;\r\nuniform float uDistanceFogPower;\r\nuniform float uSSSFogRate;\r\nuniform vec4 uSSSFogColor;\r\nuniform float uBlendRate;\r\nuniform float uTexelSize;\n\nfloat calcFogHeightExp(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float densityY0, float densityAttenuation) {\r\n    vec3 v = cameraPositionInWorld - objectPositionInWorld;\r\n    float l = length(v);\r\n    float ret;\r\n    float tmp = l * densityY0 * exp(-densityAttenuation * objectPositionInWorld.y);\r\n    if(v.y == 0.) {\r\n        ret = exp(-tmp);\r\n    } else {\r\n        float kvy = densityAttenuation * v.y;\r\n        ret = exp(tmp / kvy * (exp(-kvy) - 1.));\r\n    }\r\n    \r\n    return 1. - ret;\r\n}\n\nfloat calcFogHeightUniform(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float fogDensity, float fogEndHeight) {\r\n    vec3 v = cameraPositionInWorld - objectPositionInWorld;\r\n    float t;\r\n    if(objectPositionInWorld.y < fogEndHeight) {\r\n        if(cameraPositionInWorld.y > fogEndHeight) {\r\n            t = (fogEndHeight - objectPositionInWorld.y) / v.y;\r\n        } else {\r\n            t = 1.;\r\n        }\r\n    } else {\r\n        if(cameraPositionInWorld.y < fogEndHeight) {\r\n            t = (cameraPositionInWorld.y - fogEndHeight) / v.y;\r\n        } else {\r\n            t = 0.;\r\n        }\r\n    }\r\n    float dist = length(v) * t;\r\n    float fog = exp(-dist * fogDensity);\r\n    return 1. - fog;\r\n}\n\nfloat calcDistanceFog(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float expStart, float fogEnd, float expPower) {\r\n    float dist = length(cameraPositionInWorld - objectPositionInWorld);\r\n    dist = max(0., dist - expStart);\r\n    return max(0., 1. - exp(-dist * expPower)) * smoothstep(expStart, fogEnd, dist);\r\n}\n\nvoid main() {\r\n    vec2 uv = vUv;\r\n    \r\n    vec4 sceneColor = texture(uSrcTexture, uv);\r\n    vec4 destColor = sceneColor;\r\n    vec4 lightShaftColor = texture(uLightShaftTexture, uv);\r\n    vec4 volumetricLightColor = texture(uVolumetricLightTexture, uv);\r\n    float sssRate = texture(uSSSTexture, uv).r;\n\n    vec2 aspect = vec2(uAspect, 1.);\r\n  \r\n    \n    \n    vec2 viewCoef = uViewDirection.xy * .4;\r\n    float noiseRate1 = texture(uNoiseTexture, (uv + viewCoef + uTime * vec2(.04, .02)) * aspect * 1.2).x;\r\n    float noiseRate2 = texture(uNoiseTexture, (uv + viewCoef + uTime * vec2(-.03, .015) + noiseRate1 * .02) * aspect * 1.2).x;\r\n    float noiseRate = saturate(1. - (noiseRate1 * .13 + noiseRate2 * .17));\r\n    \r\n    \n    float occlusion = saturate(lightShaftColor.x);\n\n    float rawDepth = texture(uDepthTexture, uv).x;\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n    vec3 viewPositionFromDepth = reconstructViewPositionFromDepth(uv, rawDepth, uInverseProjectionMatrix);\r\n    vec3 worldPositionFromDepth = reconstructWorldPositionFromDepth(uv, rawDepth, uInverseViewProjectionMatrix);\r\n \r\n    float constantFogScale = .1;\r\n  \r\n    vec3 fogColor = uFogColor.xyz;\r\n    \n    \n    \n    float rate = constantFogScale * max(0., 1. - exp(-uFogStrength * -viewPositionFromDepth.z));\r\n   \r\n    \n    float fogRate = calcFogHeightExp(worldPositionFromDepth, uViewPosition, uFogDensity, uFogDensityAttenuation);\r\n    fogRate *= 1. - step(1. - .0001, rawDepth);\r\n    \n    fogRate += calcDistanceFog(worldPositionFromDepth, uViewPosition, uDistanceFogStart, uDistanceFogEnd, uDistanceFogPower);\r\n    \n    fogRate = saturate(fogRate) * noiseRate;\n\n    \n    vec4 applyOcclusionColor = sceneColor * (1. - occlusion);\r\n    outColor = vec4(mix(applyOcclusionColor.xyz, fogColor.xyz, fogRate), 1.);\r\n    \r\n    \n    \n    \n    \n    outColor += vec4(volumetricLightColor.xyz * noiseRate, 0.);\r\n    \n    \r\n    \n    \n    \n    \n    \n    \n\n    \n    outColor += vec4(uSSSFogColor.xyz * (1. - sssRate) * uSSSFogRate * fogRate, 0.);\r\n    \r\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:ya,type:y.Color,value:mr()},{name:S.DepthTexture,type:y.Texture,value:null},{name:Ba,type:y.Texture,value:null},{name:Ea,type:y.Texture,value:null},{name:Ia,type:y.Texture,value:null},{name:Sa,type:y.Float,value:a},{name:ba,type:y.Float,value:o},{name:Ca,type:y.Float,value:i},{name:Ma,type:y.Float,value:l},{name:Pa,type:y.Float,value:s},{name:wa,type:y.Float,value:c},{name:Ra,type:y.Float,value:u},{name:Da,type:y.Float,value:m},{name:Fa,type:y.Color,value:mr()},{name:La,type:y.Texture,value:null},{name:S.BlendRate,type:y.Float,value:1}],uniformBlockNames:[b.Common,b.Camera],enabled:t}),fogColor:r,fogStrength:a,fogDensity:o,fogDensityAttenuation:i,fogEndHeight:l,distanceFogStart:s,distanceFogPower:u,distanceFogEnd:c,sssFogRate:m,sssFogColor:f,blendRate:p}}({gpu:n}),O=function(e){const{gpu:n,enabled:t}=e,r=e.focusDistance??14,a=e.focusRange??10,o=e.bokehRadius??4,i=Lr({gpu:n}),l=[],s=qr({name:"circleOfConfusionPass",gpu:n,fragmentShader:"#include <lighting>\r\n#include <ub>\r\n#include <depth>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\n\nuniform float uFocusDistance;\r\nuniform float uFocusRange;\r\nuniform float uBokehRadius;\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\r\n    float rawDepth = texture(uDepthTexture, vUv).r;\r\n    float eyeDepth = perspectiveDepthToEyeDepth(rawDepth, uNearClip, uFarClip);\r\n    \r\n    \n    float coc = (eyeDepth - uFocusDistance) / uFocusRange;\r\n    coc = clamp(coc, -1., 1.) * uBokehRadius;\r\n    \r\n    \n    \n    \n    \n    \n    \r\n    outColor = vec4(vec3(coc), 1.);\r\n    \r\n    \n    \n}",uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:S.DepthTexture,type:y.Texture,value:null},{name:"uFocusDistance",type:y.Float,value:r},{name:"uFocusRange",type:y.Float,value:a},{name:"uBokehRadius",type:y.Float,value:o},...Nr()],uniformBlockNames:[b.Camera],renderTargetType:v.R16F});l.push(...s.materials);const u=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uCocTexture;\r\nuniform vec2 uTexelSize;\n\nfloat weight(vec3 c) {\r\n    return 1. / (1. + max(max(c.r, c.g), c.b));\r\n    \n}\n\nfloat maxV3(vec3 c) {\r\n    return max(max(c.r, c.g), c.b);\r\n}\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\r\n    vec4 cocColor = texture(uCocTexture, vUv);\r\n    \n    \n \r\n    vec4 kernel = uTexelSize.xyxy * vec2(-.5, .5).xxyy;\r\n   \r\n    vec3 s0 = texture(uSrcTexture, vUv + kernel.xy).rgb;\r\n    vec3 s1 = texture(uSrcTexture, vUv + kernel.zy).rgb;\r\n    vec3 s2 = texture(uSrcTexture, vUv + kernel.xw).rgb;\r\n    vec3 s3 = texture(uSrcTexture, vUv + kernel.zw).rgb;\r\n    \r\n    float w0 = weight(s0);\r\n    float w1 = weight(s1);\r\n    float w2 = weight(s2);\r\n    float w3 = weight(s3);\r\n    \r\n    float coc0 = texture(uCocTexture, vUv + kernel.xy).r;\r\n    float coc1 = texture(uCocTexture, vUv + kernel.zy).r;\r\n    float coc2 = texture(uCocTexture, vUv + kernel.xw).r;\r\n    float coc3 = texture(uCocTexture, vUv + kernel.zw).r;\r\n    \n    \n    \n    \n    \r\n    float coc = 0.;\r\n    \n    float cocMin = min(min(min(coc0, coc1), coc2), coc3);\r\n    float cocMax = max(max(max(coc0, coc1), coc2), coc3);\r\n    coc = cocMax >= -cocMin ? cocMax : cocMin;\r\n    \r\n    vec4 weights = vec4(w0, w1, w2, w3);\n\n    \n    \n    \n    \n    \n    \n    w0 *= 1. / (maxV3(s0) + 1.);\r\n    w1 *= 1. / (maxV3(s1) + 1.);\r\n    w2 *= 1. / (maxV3(s2) + 1.);\r\n    w3 *= 1. / (maxV3(s3) + 1.);\n\n    \n    \n    \n    \n    \n\n    \n    \n    vec3 color =\r\n        s0 * weights.x +\r\n        s1 * weights.y +\r\n        s2 * weights.z +\r\n        s3 * weights.w;\r\n    \n    \n    \n    color /= dot(weights, vec4(1.));\r\n    \r\n    coc = dot(coc, .25);\r\n    color *= smoothstep(0., uTexelSize.y * 2., abs(coc));\r\n    \r\n    outColor = vec4(color.rgb, coc);\r\n   \r\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:xa,type:y.Texture,value:null},{name:S.TexelSize,type:y.Vector2,value:ha()},...Nr()],renderTargetType:v.RGBA16F});l.push(...u.materials);const c=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\n\nuniform vec2 uTexelSize;\r\nuniform float uBokehRadius;\n\n#define BOKEH_KERNEL_MEDIUM\n\n#define KERNEL_SAMPLE_COUNT 22\r\nconst vec2[22] kernel = vec2[](\r\n\tvec2(0, 0),\r\n\tvec2(0.53333336, 0),\r\n\tvec2(0.3325279, 0.4169768),\r\n\tvec2(-0.11867785, 0.5199616),\r\n\tvec2(-0.48051673, 0.2314047),\r\n\tvec2(-0.48051673, -0.23140468),\r\n\tvec2(-0.11867763, -0.51996166),\r\n\tvec2(0.33252785, -0.4169769),\r\n\tvec2(1, 0),\r\n\tvec2(0.90096885, 0.43388376),\r\n\tvec2(0.6234898, 0.7818315),\r\n\tvec2(0.22252098, 0.9749279),\r\n\tvec2(-0.22252095, 0.9749279),\r\n\tvec2(-0.62349, 0.7818314),\r\n\tvec2(-0.90096885, 0.43388382),\r\n\tvec2(-1, 0),\r\n\tvec2(-0.90096885, -0.43388376),\r\n\tvec2(-0.6234896, -0.7818316),\r\n\tvec2(-0.22252055, -0.974928),\r\n\tvec2(0.2225215, -0.9749278),\r\n\tvec2(0.6234897, -0.7818316),\r\n\tvec2(0.90096885, -0.43388376)\r\n);\r\n\nfloat weight(float coc, float radius) {\r\n    \n    return clamp((coc - radius + 2.) / 2., 0., 1.);\r\n}\n\nvoid main() {\r\n    vec4 srcColor = texture(uSrcTexture, vUv);\r\n    \r\n    vec2 texelSize = uTexelSize;\r\n   \r\n    vec3 bgColor = vec3(0.);\r\n    vec3 fgColor = vec3(0.);\r\n    float bgWeight = 0.;\r\n    float fgWeight = 0.;\r\n \r\n    float coc = texture(uSrcTexture, vUv).a;\n\n    for(int k = 0; k < KERNEL_SAMPLE_COUNT; k++) {\r\n        vec2 o = kernel[k].xy * uBokehRadius;\r\n        float radius = length(o);\r\n        o *= texelSize;\r\n        vec4 s = texture(uSrcTexture, vUv + o);\r\n      \r\n        \n        \n        float bgw = weight(max(0., min(s.a, coc)), radius);\r\n        \n        bgColor += s.rgb * bgw;\r\n        bgWeight += bgw;\r\n       \r\n        \n        \n        float fgw = weight(-s.a, radius);\r\n        fgColor += s.rgb * fgw;\r\n        fgWeight += fgw;\r\n    }\r\n   \r\n    bgColor *= vec3(1.) / (bgWeight + (bgWeight == 0. ? 1. : 0.)); \r\n    fgColor *= vec3(1.) / (fgWeight + (fgWeight == 0. ? 1. : 0.));\r\n    \r\n    \n    \n    \n\n    \n    float bgfg = min(1., fgWeight * 3.141592 / float(KERNEL_SAMPLE_COUNT));\r\n    \r\n    \n    \n    \r\n    vec3 color = mix(bgColor, fgColor, bgfg);\r\n    \r\n    outColor = vec4(color, bgfg);\r\n    \r\n    \n    \n    \n    \n    \r\n    \n    \n    \n}",renderTargetType:v.RGBA16F,uniforms:[{name:"uTexelSize",type:y.Vector2,value:ha()},{name:"uBokehRadius",type:y.Float,value:o}]});l.push(...c.materials);const m=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform vec2 uTexelSize;\r\nuniform float uBokehRadius;\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n\n    \n    vec4 kernel = uTexelSize.xyxy * vec2(-.5, .5).xxyy;\r\n    vec4 s =\r\n        texture(uSrcTexture, vUv + kernel.xy) +\r\n        texture(uSrcTexture, vUv + kernel.zy) +\r\n        texture(uSrcTexture, vUv + kernel.xw) +\r\n        texture(uSrcTexture, vUv + kernel.zw);\r\n        \n        \n        \n        \n        \r\n    \n    outColor = s * .25;\r\n        \n\n    \n    \n}",renderTargetType:v.RGBA16F,uniforms:[{name:"uTexelSize",type:y.Vector2,value:ha()},{name:"uBokehRadius",type:y.Float,value:o}]});l.push(...m.materials);const f=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uCocTexture;\r\nuniform sampler2D uDofTexture;\n\nvoid main() {\r\n    vec4 sceneColor = texture(uSrcTexture, vUv);\r\n   \r\n    float coc = texture(uCocTexture, vUv).r;\r\n    vec4 dof = texture(uDofTexture, vUv);\r\n    \r\n    \n    float dofStrength = smoothstep(.1, 1., coc); \r\n    \r\n    \n    float rate = dofStrength + dof.a - dofStrength * dof.a;\r\n    \r\n    \n    vec3 color = mix(\r\n        sceneColor.rgb,\r\n        dof.rgb,\r\n        rate\r\n    );\r\n    \r\n    outColor = vec4(color, 1.);\r\n   \r\n    \n    \n    \n    \n    \n    \n    \n    \n}",renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:xa,type:y.Texture,value:null},{name:Ta,type:y.Texture,value:null}]});return l.push(...f.materials),{...Er({gpu:n,name:"DepthOfFieldPass",type:1,geometry:i,materials:l,enabled:t}),circleOfConfusionPass:s,preFilterPass:u,dofBokehPass:c,bokehBlurPass:m,compositePass:f,focusDistance:r,focusRange:a,bokehRadius:o}}({gpu:n}),_=function(e){const{gpu:n,enabled:t}=e,r=e.threshold??1.534,a=e.tone??.46,o=e.bloomAmount??.26,i=[],l=Lr({gpu:n}),s=Mr({gpu:n,type:v.R11F_G11F_B10F}),u=Mr({gpu:n,type:v.R11F_G11F_B10F}),c=Mr({gpu:n,type:v.R11F_G11F_B10F}),m=Mr({gpu:n,type:v.R11F_G11F_B10F}),f=Mr({gpu:n,type:v.R11F_G11F_B10F}),p=Mr({gpu:n,type:v.R11F_G11F_B10F}),d=Mr({gpu:n,type:v.R11F_G11F_B10F}),g=Mr({gpu:n,type:v.R11F_G11F_B10F}),h=Mr({gpu:n,type:v.R11F_G11F_B10F}),x=Mr({gpu:n,type:v.R11F_G11F_B10F}),T=qr({gpu:n,fragmentShader:"out vec4 outColor;\n\nin vec2 vUv;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uThreshold;\n\nvoid main() {\r\n    vec4 color = texture(uSrcTexture, vUv);\n\n    float k = uThreshold;\r\n    \r\n    \n    \n    \n    \n    \n    \n    \r\n    \n    \n    \n\n    \n    \n    vec3 b = max(color.xyz - vec3(1. + uThreshold), vec3(0.));\r\n    \n\n    outColor = vec4(b, 1.);\r\n}",uniforms:[{name:oa,type:y.Float,value:r}],renderTargetType:v.R11F_G11F_B10F});i.push(...T.materials);const b=function(e,n){const t=Math.floor(3.5);let r=0;return new Array(7).fill(0).map(((e,n)=>{const a=(o=n-t,Math.exp(-o*o/1.6928));var o;return r+=a,a})).map((e=>e/r))}(),C=ar({vertexShader:Ar(),fragmentShader:Jr,uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:Yr,type:y.FloatArray,value:new Float32Array(b)},{name:Kr,type:y.Float,value:1},...Nr()]});i.push(C);const M=ar({vertexShader:Ar(),fragmentShader:Jr,uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:Yr,type:y.FloatArray,value:new Float32Array(b)},{name:Kr,type:y.Float,value:0},...Nr()]});i.push(M);const P=qr({gpu:n,fragmentShader:"#include <common>\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uBlur4Texture;\r\nuniform sampler2D uBlur8Texture;\r\nuniform sampler2D uBlur16Texture;\r\nuniform sampler2D uBlur32Texture;\r\nuniform sampler2D uBlur64Texture;\r\nuniform sampler2D uExtractTexture;\r\nuniform float uTone;\r\nuniform float uBloomAmount;\n\nvoid main() {\r\n    \n    vec4 blur4Color = texture(uBlur4Texture, vUv);\r\n    vec4 blur8Color = texture(uBlur8Texture, vUv);\r\n    vec4 blur16Color = texture(uBlur16Texture, vUv);\r\n    vec4 blur32Color = texture(uBlur32Texture, vUv);\r\n    vec4 blur64Color = texture(uBlur64Texture, vUv);\r\n    vec4 sceneColor = texture(uSrcTexture, vUv) * uTone;\r\n    vec4 extractColor = texture(uExtractTexture, vUv) * uTone;\n\n    vec4 blurColor = ((blur4Color + blur8Color + blur16Color + blur32Color + blur64Color) * .2) * uBloomAmount;\n\n    outColor = sceneColor + blurColor;\n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:Zr,type:y.Texture,value:null},{name:Qr,type:y.Texture,value:null},{name:ea,type:y.Texture,value:null},{name:na,type:y.Texture,value:null},{name:ta,type:y.Texture,value:null},{name:ra,type:y.Float,value:a},{name:aa,type:y.Float,value:o},{name:ia,type:y.Texture,value:null},...Nr()],renderTargetType:v.R11F_G11F_B10F});return i.push(...P.materials),{...Er({gpu:n,name:"BloomPass",type:0,geometry:l,materials:i,enabled:t}),extractBrightnessPass:T,renderTargetBlurMip4_Horizontal:s,renderTargetBlurMip4_Vertical:u,renderTargetBlurMip8_Horizontal:c,renderTargetBlurMip8_Vertical:m,renderTargetBlurMip16_Horizontal:f,renderTargetBlurMip16_Vertical:p,renderTargetBlurMip32_Horizontal:d,renderTargetBlurMip32_Vertical:g,renderTargetBlurMip64_Horizontal:h,renderTargetBlurMip64_Vertical:x,compositePass:P,horizontalBlurMaterial:C,verticalBlurMaterial:M,tone:a,threshold:r,bloomAmount:o}}({gpu:n}),V=function(e){const{gpu:n,enabled:t}=e,r=e.threshold||.9,a=e.stretch||.5,o=e.color||mr(),i=e.intensity||.6,l=e.verticalScale||1.5,s=e.horizontalScale||1.25,u=Lr({gpu:n}),c=[],m=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform vec2 uTexelSize;\r\nuniform float uThreshold;\r\nuniform float uVerticalScale;\n\nvoid main() {\r\n    \n    float vScale = uVerticalScale;\r\n    float dy = uTexelSize.y * vScale / 2.;\r\n    vec2 uv = vUv;\r\n    vec4 srcColor = texture(uSrcTexture, uv);\r\n    vec3 c0 = texture(uSrcTexture, vec2(uv.x, uv.y - dy)).rgb;\r\n    vec3 c1 = texture(uSrcTexture, vec2(uv.x, uv.y + dy)).rgb;\r\n    vec3 c = (c0 + c1) / 2.;\r\n    \r\n    \n    float br = max(c.r, max(c.g, c.b)); \r\n    \r\n    \n    \n    c *= max(0., br - uThreshold) / max(br, 1e-5);\r\n    \r\n    outColor = vec4(c, 1.);\r\n}",uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:S.TexelSize,type:y.Vector2,value:ha()},{name:"uThreshold",type:y.Float,value:r},{name:"uVerticalScale",type:y.Float,value:l},...Nr()],renderTargetType:v.R11F_G11F_B10F});c.push(...m.materials);const f=[2,4,8,16,32].map((e=>{const t=qr({name:`DownSampleMip${e}Pass`,gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uPrevTexture;\r\nuniform vec2 uTexelSize;\r\nuniform float uHorizontalScale;\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    \n    float hScale = uHorizontalScale;\r\n    \n    float dx = uTexelSize.x * hScale;\n\n    float u0 = uv.x - dx * 5.;\r\n    float u1 = uv.x - dx * 3.;\r\n    float u2 = uv.x - dx * 1.;\r\n    float u3 = uv.x + dx * 1.;\r\n    float u4 = uv.x + dx * 3.;\r\n    float u5 = uv.x + dx * 5.;\r\n    \r\n    vec4 c0 = texture(uPrevTexture, vec2(u0, uv.y));\r\n    vec4 c1 = texture(uPrevTexture, vec2(u1, uv.y));\r\n    vec4 c2 = texture(uPrevTexture, vec2(u2, uv.y));\r\n    vec4 c3 = texture(uPrevTexture, vec2(u3, uv.y));\r\n    vec4 c4 = texture(uPrevTexture, vec2(u4, uv.y));\r\n    vec4 c5 = texture(uPrevTexture, vec2(u5, uv.y));\r\n  \r\n    \n    \n    vec4 c = (c0 + c1 + c2 + c3 + c4 + c5) / 6.0;\r\n    \r\n    outColor = vec4(c.xyz, 1.);\r\n}",uniforms:[{name:S.TexelSize,type:y.Vector2,value:ha()},{name:Ya,type:y.Texture,value:null},{name:Qa,type:y.Float,value:s},...Nr()]});return c.push(...t.materials),{pass:t,downScale:e}})),p=f.map((({pass:e,downScale:n},t)=>({pass:e,prevPass:0===t?m:f[t-1].pass,downScale:n}))),d=Vr.range(5).map(((e,t)=>{const r=qr({name:`UpSampleMip${t}Pass`,gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uDownSampleTexture;\r\nuniform sampler2D uPrevTexture; \nuniform float uStretch;\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    \n    vec3 c0 = texture(uPrevTexture, uv).xyz * .25;\r\n    vec3 c1 = texture(uPrevTexture, uv).xyz * .5;\r\n    vec3 c2 = texture(uPrevTexture, uv).xyz * .25;\n\n    vec3 c3 = texture(uDownSampleTexture, uv).xyz;\n\n    \n    vec3 c = mix(c3, c0 + c1 + c2, uStretch);\r\n    outColor = vec4(c.xyz, 1.);\n\n    \n    \n}",uniforms:[{name:Ka,type:y.Texture,value:null},{name:Ya,type:y.Texture,value:null},{name:Za,type:y.Float,value:a},...Nr()]});return c.push(...r.materials),{pass:r}})),g=d.map((({pass:e},n)=>({pass:e,prevPass:0===n?p[p.length-1].pass:d[n-1].pass,downSamplePass:p[p.length-1-n].pass}))),h=qr({gpu:n,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform vec4 uColor;\r\nuniform float uIntensity;\r\nuniform sampler2D uSrcTexture;\r\nuniform sampler2D uStreakTexture;\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    \n    vec3 c0 = texture(uStreakTexture, uv).xyz * .25;\r\n    vec3 c1 = texture(uStreakTexture, uv).xyz * .5;\r\n    vec3 c2 = texture(uStreakTexture, uv).xyz * .25;\r\n    \r\n    vec3 c3 = texture(uSrcTexture, uv).xyz;\r\n  \r\n    \n    float multiplier = 5.;\r\n    vec3 cf = (c0 + c1 + c2) * uColor.xyz * uIntensity * multiplier;\r\n   \r\n    \n    outColor = vec4(cf + c3, 1.);\r\n    \r\n    \n    \n}",uniforms:[{name:eo,type:y.Texture,value:null},{name:no,type:y.Color,value:o},{name:to,type:y.Float,value:i},...Nr()],renderTargetType:v.R11F_G11F_B10F});return c.push(...h.materials),{...Er({gpu:n,name:"StreakPass",type:13,geometry:u,materials:c,enabled:t}),halfHeight:0,prefilterPass:m,downSamplePasses:p,upSamplePasses:g,compositePass:h,threshold:r,stretch:a,color:o,intensity:i,verticalScale:l,horizontalScale:s}}({gpu:n}),U=function(e){const{gpu:n,enabled:t}=e;return{...Ir({gpu:n,type:14,name:"ToneMappingPass",fragmentShader:"#include <tone>\n\nvec4 encodePseudoHDR(vec3 color) {\r\n    float base = .25;\r\n    float l = max(max(color.r, color.g), max(color.b, base));\r\n    return vec4(\r\n        color.r / l,\r\n        color.g / l,\r\n        color.b / l,\r\n        base / l\r\n    );\r\n}\n\nvec4 decodePseudoHDR(vec4 encodedColor) {\r\n    float base = .25;\r\n    float rl = encodedColor.a;\r\n    return vec4(\r\n        (encodedColor.r / rl) * base,\r\n        (encodedColor.g / rl) * base,\r\n        (encodedColor.b / rl) * base,\r\n        rl * base\r\n    );\r\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\n\nvoid main() {\r\n    \n    \n    \n    \n\n    vec3 resultColor = texture(uSrcTexture, vUv).xyz;\n\n    \n    \n    \n    resultColor = aces(resultColor);\r\n    \r\n    \n    resultColor = degamma(resultColor);\n\n    \n    if(\r\n        resultColor.r > 1.\r\n        || resultColor.g > 1.\r\n        || resultColor.b > 1.\r\n    ) {\r\n        resultColor = vec3(1., 0., 1.);\r\n    }\r\n    \r\n    outColor = vec4(resultColor, 1.);\r\n}",uniforms:[{name:S.SrcTexture,type:y.Texture,value:null}],enabled:t})}}({gpu:n}),z=function(e){const{gpu:n,enabled:t}=e,r=e.scale??.015,a=e.power??1,o=e.blendRate??1;return{...Ir({gpu:n,type:3,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uTargetWidth;\r\nuniform float uTargetHeight;\r\nuniform float uScale;\r\nuniform float uPower;\n\nconst int ARRAY_NUM = 5;\n\nconst vec3 chromaticAberrationFilter[ARRAY_NUM] = vec3[](\r\n    vec3(0., 0., .5),\r\n    vec3(0., .25, .5),\r\n    vec3(0., .5, 0.),\r\n    vec3(.5, .25, 0.),\r\n    vec3(.5, 0., 0.)\r\n);\n\nvoid main() {\r\n    vec2 uv = vUv;\r\n    vec2 centerUv = vUv * 2. - 1.; \n    outColor = vec4(0.);\r\n    for(int i = 0; i < ARRAY_NUM; i++) {\r\n        vec2 tempUv = centerUv * (1. - pow(uScale * (float(i) + 1.) / float(ARRAY_NUM), uPower));\r\n        tempUv = (tempUv + 1.) * .5; \n        vec3 mask = chromaticAberrationFilter[i];\r\n        vec4 color = texture(uSrcTexture, tempUv);\r\n        outColor += vec4(color.rgb * mask, 1.);\r\n    }\r\n}",uniforms:[{name:sa,type:y.Float,value:.015},{name:ua,type:y.Float,value:1}],enabled:t}),scale:r,power:a,blendRate:o}}({gpu:n}),j=function(e){const{gpu:n,enabled:t}=e,r=e.blendRate??0;return{...Ir({gpu:n,type:4,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\n#include <lighting>\r\n#include <ub>\r\n#include <rand>\n\nuniform sampler2D uSrcTexture;\r\nuniform float uTargetWidth;\r\nuniform float uTargetHeight;\r\nuniform float uBlendRate;\n\nuniform float uVignetteRadius;\r\nuniform float uVignettePower;\r\n\nfloat blockNoise(vec2 st, vec2 scale, vec2 offset) {\r\n    st *= scale;\r\n    vec2 ipos = floor(st);\r\n    \n    float r = rand(ipos + offset);\r\n    return r;\r\n}\n\nvoid main() {\r\n    vec2 uv = vUv;\n\n    outColor = vec4(0.);\r\n    vec4 color = texture(uSrcTexture, uv);\n\n    float random1 = rand(vec2(uTime, 0.));\r\n    float random2 = rand(vec2(uTime, .1));\r\n    float glitchMix = sin(uTime * 80.) * .5 + .5;\r\n    float dmg = 1.8;\r\n    float corruption = .02;\r\n    float glitchAmount = .1;\r\n    float desaturate = .02;\n\n    vec4 srcCol = texture(uSrcTexture, uv);\n\n    \n\n    float glitchStep = mix(4., 32., random1);\r\n    float glitchUV = round(uv.x * glitchStep) / glitchStep;\r\n    vec4 glitchCol = texture(uSrcTexture, vec2(glitchUV, uv.y));\r\n    vec4 glitchFinal = mix(srcCol, glitchCol, glitchMix);\n\n    \n\n    float chrNoise = blockNoise(uv, vec2(8.), vec2(random1, 0.));\r\n    float chrNoise2 = blockNoise(uv, vec2(11.), vec2(random1, 1.));\n\n    float chrOffset = step(.5 * (chrNoise + chrNoise2), .5);\r\n    chrOffset = (2. * chrOffset + 1.) * .005 * dmg;\n\n    vec4 chrColR = texture(uSrcTexture, vec2(uv.x + chrOffset, uv.y));\r\n    vec4 chrColB = texture(uSrcTexture, vec2(uv.x - chrOffset, uv.y));\n\n    vec4 chrCol2R = texture(uSrcTexture, vec2(uv.x + step(.5 * (chrNoise + chrNoise2), .2) * .005, uv.y));\r\n    vec4 chrCol2B = texture(uSrcTexture, vec2(uv.x - step(.5 * (chrNoise + chrNoise2), .1) * .005, uv.y));\n\n    vec4 finalScrCol = vec4(0.);\r\n    finalScrCol.r = mix(chrCol2R.r, chrColR.r, dmg) - step(chrNoise2, .2);\r\n    finalScrCol.g = srcCol.g + step(chrNoise, .2);\r\n    finalScrCol.b = mix(chrCol2R.b, chrColR.b, dmg) - step(chrNoise2, .2);\n\n    finalScrCol = vec4(chrColR.r, srcCol.g + step(chrNoise, .2) * corruption, chrColB.b, 1.);\n\n    float aberration = pow(((length(uv * 2. - 1.)) - uTime * .1), .2);\r\n    vec4 lensBlur = texture(uSrcTexture, uv - (uv * 2. - 1.) * aberration * .0125 * 2.);\r\n    vec4 lensBlur2 = texture(uSrcTexture, uv - (uv * 2. - 1.) * aberration * .0125 * 2.);\r\n    vec4 lensBlur3 = texture(uSrcTexture, uv - (uv * 2. - 1.) * aberration * .025);\r\n    float lensAbrR = dot((lensBlur3 - srcCol).rgb, vec3(.3, .59, .11));\n\n    vec4 compositeCol = mix(finalScrCol, glitchFinal, glitchAmount);\r\n    vec4 destCol = compositeCol;\n\n    vec4 desaturatedCol = vec4(dot((srcCol + lensBlur + lensBlur2).rgb / 3., vec3(.3, .59, .11)));\r\n    desaturatedCol += vec4(lensAbrR * 2., 0., 0., 0.);\r\n    destCol = mix(compositeCol, vec4(desaturatedCol.xyz, 1.), desaturate);\n\n    \n    vec2 centerUv = vUv * 2. - 1.;\r\n    centerUv.x *= uAspect;\r\n    vec2 rectSize = vec2(.5, .5);\r\n    vec2 rectArea = step(-rectSize, centerUv) * (1. - step(rectSize, centerUv));\r\n    float rectmask = rectArea.x * rectArea.y;\n\n    outColor = mix(srcCol, destCol, uBlendRate * 1.);\r\n}",uniforms:[{name:Aa,type:y.Float,value:r},{name:S.Aspect,type:y.Float,value:1}],uniformBlockNames:[b.Common],enabled:t}),blendRate:r}}({gpu:n}),G=function(e){const{gpu:n,enabled:t}=e,r=e.vignetteRadiusFrom??1.77,a=e.vignetteRadiusTo??4.484,o=e.vignettePower??1.345,i=e.blendRate??.73;return{...Ir({gpu:n,type:15,fragmentShader:"in vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uVignetteRadiusFrom;\r\nuniform float uVignetteRadiusTo;\r\nuniform float uVignettePower;\r\nuniform float uBlendRate;\r\nuniform float uAspect;\n\nvoid main() {\r\n    vec2 uv = vUv;\r\n    vec2 centerUv = vUv * 2. - 1.; \n    centerUv.x *= uAspect;\r\n    float d = dot(centerUv, centerUv);\r\n    \n    \n    \n    float factor = pow(smoothstep(uVignetteRadiusFrom, uVignetteRadiusTo, d), uVignettePower) * uBlendRate;\r\n    vec3 vignetteColor = vec3(0.);\r\n    vec3 srcColor = texture(uSrcTexture, uv).rgb;\r\n    outColor = vec4(mix(srcColor, vignetteColor, factor), 1.);\r\n}",uniforms:[{name:$a,type:y.Float,value:1.77},{name:Xa,type:y.Float,value:4.484},{name:qa,type:y.Float,value:1.345},{name:Ja,type:y.Float,value:.73},{name:S.Aspect,type:y.Float,value:1}],enabled:t}),vignetteRadiusFrom:r,vignetteRadiusTo:a,vignettePower:o,blendRate:i}}({gpu:n}),W=function(e){const{gpu:n,enabled:t}=e;return{...Ir({gpu:n,type:7,fragmentShader:"#define MAX_EDGE_STEP_COUNT 9\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\r\nuniform float uTargetWidth;\r\nuniform float uTargetHeight;\n\nuniform float uContrastThreshold;\r\nuniform float uRelativeThreshold;\r\nuniform float uSubpixelBlending;\r\n       \r\nstruct EdgeData {\r\n    bool isHorizontal;\r\n    float pixelStep;\r\n    float oppositeLuma;\r\n    float gradient;\r\n};\n\nstruct LuminanceData {\r\n    float center;\r\n    float top;\r\n    float right;\r\n    float bottom;\r\n    float left;\r\n    \r\n    float topLeft;\r\n    float topRight;\r\n    float bottomLeft;\r\n    float bottomRight;\r\n    \r\n    float highest;\r\n    float lowest;\r\n    float contrast;\r\n};\r\n\nfloat rgbToLuma(vec3 rgb) {\r\n    return dot(rgb, vec3(.299, .587, .114));\r\n}\n\nvec4 sampleTexture(sampler2D tex, vec2 coord) {\r\n    return texture(tex, coord);\r\n}\n\nvec4 sampleTextureOffset(sampler2D tex, vec2 coord, float offsetX, float offsetY) {\r\n    return sampleTexture(tex, coord + vec2(offsetX, offsetY));\r\n}\n\nLuminanceData sampleLuminanceNeighborhood(vec2 uv, vec2 texelSize) {\r\n    LuminanceData l;\n\n    \n    vec3 rgbTop = sampleTextureOffset(uSrcTexture, uv, 0., texelSize.y).xyz;\r\n    vec3 rgbRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, 0.).xyz;\r\n    vec3 rgbBottom = sampleTextureOffset(uSrcTexture, uv, 0., -texelSize.y).xyz;\r\n    vec3 rgbLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, 0.).xyz;\r\n    vec3 rgbCenter = sampleTextureOffset(uSrcTexture, uv, 0., 0.).xyz;\n\n    \n    vec3 rgbTopRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, texelSize.y).xyz;\r\n    vec3 rgbTopLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, texelSize.y).xyz;\r\n    vec3 rgbBottomRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, -texelSize.y).xyz;\r\n    vec3 rgbBottomLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, -texelSize.y).xyz;\n\n    \n    float lumaTop = rgbToLuma(rgbTop);\r\n    float lumaLeft = rgbToLuma(rgbLeft);\r\n    float lumaCenter = rgbToLuma(rgbCenter);\r\n    float lumaRight = rgbToLuma(rgbRight);\r\n    float lumaBottom = rgbToLuma(rgbBottom);\n\n    \n    float lumaTopLeft = rgbToLuma(rgbTopLeft);\r\n    float lumaTopRight = rgbToLuma(rgbTopRight);\r\n    float lumaBottomLeft = rgbToLuma(rgbBottomLeft);\r\n    float lumaBottomRight = rgbToLuma(rgbBottomRight);\n\n    \n    float lumaHighest = max(lumaCenter, max(max(lumaTop, lumaLeft), max(lumaBottom, lumaRight)));\r\n    float lumaLowest = min(lumaCenter, min(min(lumaTop, lumaLeft), min(lumaBottom, lumaRight)));\r\n    float lumaContrast = lumaHighest - lumaLowest;\r\n \r\n    l.top = lumaTop;\r\n    l.left = lumaLeft;\r\n    l.center = lumaCenter;\r\n    l.right = lumaRight;\r\n    l.bottom = lumaBottom;\r\n    \r\n    l.topLeft = lumaTopLeft;\r\n    l.topRight = lumaTopRight;\r\n    l.bottomLeft = lumaBottomLeft;\r\n    l.bottomRight = lumaBottomRight;\r\n    \r\n    l.highest = lumaHighest;\r\n    l.lowest = lumaLowest;\r\n    l.contrast = lumaContrast;\r\n    \r\n    return l;\r\n}\n\nbool shouldSkipPixel(LuminanceData l) {\r\n    return l.contrast < max(uContrastThreshold, l.highest * uRelativeThreshold);\r\n}\n\nfloat determinePixelBlendFactor(LuminanceData l) {\r\n    \n    \n    \n    \n \r\n    float determineEdgeFilter = 2. * (l.top + l.right + l.bottom + l.left);\r\n    determineEdgeFilter += l.topLeft + l.topRight + l.bottomLeft + l.bottomRight;\r\n    \r\n    \n    determineEdgeFilter *= 1. / 12.; \r\n    \r\n    \n    determineEdgeFilter = abs(determineEdgeFilter - l.center); \r\n    \r\n    \n    determineEdgeFilter = clamp(determineEdgeFilter / l.contrast, 0., 1.); \r\n    \r\n    \n    float pixelBlendFactor = smoothstep(0., 1., determineEdgeFilter); \r\n    \r\n    \n    pixelBlendFactor = pixelBlendFactor * pixelBlendFactor;\r\n    \r\n    \n    pixelBlendFactor *= uSubpixelBlending; \r\n    \r\n    return pixelBlendFactor;\r\n}\n\nEdgeData determineEdge(LuminanceData l, vec2 texelSize) {\r\n    EdgeData e;\r\n    \r\n    \n   \r\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \r\n    float horizontal =\r\n        abs(l.top + l.bottom - 2. * l.center) * 2. +\r\n        abs(l.topRight + l.bottomRight - 2. * l.right) + \r\n        abs(l.topLeft + l.bottomLeft - 2. * l.left);\r\n        \r\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        \r\n    float vertical = \r\n        abs(l.right + l.left - 2. * l.center) * 2. +\r\n        abs(l.topRight + l.topLeft - 2. * l.top) +\r\n        abs(l.bottomRight + l.bottomLeft - 2. * l.bottom);\r\n       \r\n    \n    \n        \r\n    e.isHorizontal = horizontal >= vertical;\r\n    \r\n    \n    \n    \n    \r\n    float positiveLuma = e.isHorizontal ? l.top : l.right;\r\n    float negativeLuma = e.isHorizontal ? l.bottom : l.left;\r\n    \r\n    \n\n    float positiveGradient = abs(positiveLuma - l.center);\r\n    float negativeGradient = abs(negativeLuma - l.center);\r\n    \r\n    \n  \r\n    e.pixelStep = e.isHorizontal ? texelSize.y : texelSize.x;\n\n    \n\n    if(positiveGradient < negativeGradient) {\r\n        \n        e.pixelStep = -e.pixelStep;\r\n        e.oppositeLuma = negativeLuma;\r\n        e.gradient = negativeGradient;\r\n    } else {\r\n        \n        e.oppositeLuma = positiveLuma;\r\n        e.gradient = positiveGradient;\r\n    }\r\n    \r\n    return e;\r\n}\n\nfloat determineEdgeBlendFactor(LuminanceData l, EdgeData e, vec2 uv, vec2 texelSize) {\n\n    \n    \n    \n    \n    \n    \n    \n    \r\n\n    float[10] edgeStepsArray = float[](1., 1.5, 2., 2., 2., 2., 2., 2., 2., 4.);\r\n    \n    float edgeGuess = 8.;\n\n    vec2 uvEdge = uv; \n    vec2 edgeStep = vec2(0.);\n\n    \n    \n    if(e.isHorizontal) {\r\n        uvEdge.y += e.pixelStep * .5; \n        edgeStep = vec2(texelSize.x, 0.);\r\n    } else {\r\n        uvEdge.x += e.pixelStep * .5; \n        edgeStep = vec2(0., texelSize.y);\r\n    }\n\n    float edgeLuma = (l.center + e.oppositeLuma) * .5;\r\n    float gradientThreshold = e.gradient * .25;\r\n    \r\n    \n    \n\n    \n    vec2 puv = uvEdge + edgeStep * vec2(edgeStepsArray[0]);\r\n    float pLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, puv).xyz) - edgeLuma;\r\n    bool pAtEnd = abs(pLumaDelta) >= gradientThreshold;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    #pragma UNROLL_START MAX_EDGE_STEP_COUNT\r\n        if(!pAtEnd) {\r\n            int index = UNROLL_N + 1;\r\n            puv += edgeStep * vec2(edgeStepsArray[index]);\r\n            pLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, puv).xyz) - edgeLuma;\r\n            pAtEnd = abs(pLumaDelta) >= gradientThreshold;\r\n        }\r\n    #pragma UNROLL_END\r\n    \n\n    if(!pAtEnd) {\r\n        puv += edgeStep * vec2(edgeGuess);\r\n    }\r\n    \r\n    \r\n    \n    \n   \r\n    vec2 nuv = uvEdge - edgeStep * vec2(edgeStepsArray[0]);\r\n    float nLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, nuv).xyz) - edgeLuma;\r\n    bool nAtEnd = abs(nLumaDelta) >= gradientThreshold;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    #pragma UNROLL_START MAX_EDGE_STEP_COUNT\r\n        if(!nAtEnd) {\r\n            int index = UNROLL_N + 1;\r\n            nuv -= edgeStep * vec2(edgeStepsArray[index]);\r\n            nLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, nuv).xyz) - edgeLuma;\r\n            nAtEnd = abs(nLumaDelta) >= gradientThreshold;\r\n        }\r\n    #pragma UNROLL_END\r\n    \n\n    if(!nAtEnd) {\r\n        nuv -= edgeStep * vec2(edgeGuess);\r\n    }\r\n    \r\n    \n    \n   \r\n    float pDistance, nDistance;\r\n    if(e.isHorizontal) {\r\n        pDistance = puv.x - uv.x;\r\n        nDistance = uv.x - nuv.x;\r\n    } else {\r\n        pDistance = puv.y - uv.y;\r\n        nDistance = uv.y - nuv.y;\r\n    }\r\n    \r\n    \n    \r\n    float shortestDistance;\r\n    bool deltaSign;\r\n    if(pDistance <= nDistance) {\r\n        shortestDistance = pDistance;\r\n        deltaSign = pLumaDelta >= 0.;\r\n    } else {\r\n        shortestDistance = nDistance;\r\n        deltaSign = nLumaDelta >= 0.;\r\n    }\r\n   \r\n    float edgeBlendFactor;\r\n    \r\n    if(deltaSign == (l.center - edgeLuma >= 0.)) {\r\n        \n        edgeBlendFactor = 0.;\r\n    } else {\r\n        \n        edgeBlendFactor = .5 - shortestDistance / (pDistance + nDistance);\r\n    }\r\n    \r\n    return edgeBlendFactor;\r\n}\n\nvoid main() {\r\n    vec2 uv = vUv;\r\n    \r\n    vec2 texelSize = vec2(1. / uTargetWidth, 1. / uTargetHeight);\r\n    \r\n    LuminanceData l = sampleLuminanceNeighborhood(uv, texelSize);   \n\n    if(shouldSkipPixel(l)) {\r\n        outColor = sampleTexture(uSrcTexture, uv);\r\n        return;\r\n    }\r\n    \r\n    EdgeData e = determineEdge(l, texelSize);\r\n    float pixelBlend = determinePixelBlendFactor(l); \r\n    float edgeBlend = determineEdgeBlendFactor(l, e, uv, texelSize);\r\n    \r\n    float finalBlend = max(pixelBlend, edgeBlend);\n\n    if(e.isHorizontal) {\r\n        uv.y += e.pixelStep * finalBlend;\r\n    } else {\r\n        uv.x += e.pixelStep * finalBlend;\r\n    }\n\n    outColor = sampleTexture(uSrcTexture, uv);\r\n    \n}",renderTargetType:v.R11F_G11F_B10F,uniforms:[{name:"uContrastThreshold",type:y.Float,value:.0625},{name:"uRelativeThreshold",type:y.Float,value:.125},{name:"uSubpixelBlending",type:y.Float,value:.75}],enabled:t})}}({gpu:n});bi(u,W),bi(u,O),bi(u,_),bi(u,V),bi(u,U),bi(u,G),bi(u,z),bi(u,j);const H=Xt({gpu:n,vertexShader:Yt("#version 300 es\n\n#include <lighting>\r\n#include <ub>\n\nvoid main() {\r\n}"),fragmentShader:Yt("#version 300 es\n\nvoid main() {\r\n}")}),$=[{name:S.WorldMatrix,type:y.Matrix4,value:at()},{name:S.ViewMatrix,type:y.Matrix4,value:at()},{name:S.ProjectionMatrix,type:y.Matrix4,value:at()},{name:S.NormalMatrix,type:y.Matrix4,value:at()},{name:S.InverseWorldMatrix,type:y.Matrix4,value:at()},{name:S.ViewProjectionMatrix,type:y.Matrix4,value:at()},{name:S.InverseViewMatrix,type:y.Matrix4,value:at()},{name:S.InverseProjectionMatrix,type:y.Matrix4,value:at()},{name:S.InverseViewProjectionMatrix,type:y.Matrix4,value:at()},{name:S.TransposeInverseViewMatrix,type:y.Matrix4,value:at()}];l.push({uniformBufferObject:en(n,H,b.Transformations,$),data:$});const X=[{name:S.ViewPosition,type:y.Vector3,value:Rt()},{name:S.ViewDirection,type:y.Vector3,value:Rt()},{name:S.CameraNear,type:y.Float,value:0},{name:S.CameraFar,type:y.Float,value:0},{name:S.CameraAspect,type:y.Float,value:0},{name:S.CameraFov,type:y.Float,value:0}];l.push({uniformBufferObject:en(n,H,b.Camera,X),data:X});const q=[{name:S.DirectionalLight,type:y.Struct,value:[{name:S.LightDirection,type:y.Vector3,value:Rt()},{name:S.LightIntensity,type:y.Float,value:0},{name:S.LightColor,type:y.Color,value:fr()},{name:S.ShadowMapProjectionMatrix,type:y.Matrix4,value:at()}]}];l.push({uniformBufferObject:en(n,H,b.DirectionalLight,q),data:q});const J=[{name:S.SpotLight,type:y.StructArray,value:Vr.range(e).map((()=>[{name:S.LightColor,type:y.Color,value:fr()},{name:S.LightPosition,type:y.Vector3,value:Rt()},{name:S.LightDirection,type:y.Vector3,value:Rt()},{name:S.LightIntensity,type:y.Float,value:0},{name:S.LightDistance,type:y.Float,value:0},{name:S.LightAttenuation,type:y.Float,value:0},{name:S.LightConeCos,type:y.Float,value:0},{name:S.LightPenumbraCos,type:y.Float,value:0},{name:S.ShadowMapProjectionMatrix,type:y.Matrix4,value:at()}]))}];l.push({uniformBufferObject:en(n,H,b.SpotLight,J),data:J});const Y=[{name:S.PointLight,type:y.StructArray,value:Vr.range(1).map((()=>[{name:S.LightColor,type:y.Color,value:fr()},{name:S.LightPosition,type:y.Vector3,value:Rt()},{name:S.LightIntensity,type:y.Float,value:0},{name:S.LightDistance,type:y.Float,value:0},{name:S.LightAttenuation,type:y.Float,value:0}]))}];l.push({uniformBufferObject:en(n,H,b.PointLight,Y),data:Y});const K=[{name:S.TimelineTime,type:y.Float,value:0},{name:S.TimelineDeltaTime,type:y.Float,value:0}];l.push({uniformBufferObject:en(n,H,b.Timeline,K),data:K});const Z=[{name:S.Time,type:y.Float,value:0},{name:S.DeltaTime,type:y.Float,value:0},{name:S.Viewport,type:y.Vector4,value:xr(0,0,0,0)}];return l.push({uniformBufferObject:en(n,H,b.Common,Z),data:Z}),{canvas:r,pixelRatio:i,globalUniformBufferObjects:l,gpu:n,realWidth:1,realHeight:1,stats:null,scenePostProcess:u,screenQuadCamera:s,depthPrePassRenderTarget:c,gBufferRenderTargets:x,afterDeferredShadingRenderTarget:C,copyDepthSourceRenderTarget:M,copyDepthDestRenderTarget:P,copySceneSourceRenderTarget:w,copySceneDestRenderTarget:R,screenSpaceShadowPass:F,ambientOcclusionPass:L,deferredShadingPass:E,ssrPass:I,lightShaftPass:A,volumetricLightPass:N,fogPass:k,depthOfFieldPass:O,bloomPass:_,streakPass:V,toneMappingPass:U,chromaticAberrationPass:z,glitchPass:j,vignettePass:G,fxaaPass:W,renderTarget:null,clearColorDirtyFlag:!1}}({gpu:ts,canvas:es,pixelRatio:as}),is=function({gpu:e,renderer:n,fixedUpdateFps:t=60,updateFps:r=60,showStats:a=!1,showPipeline:o=!1}){const i=function({gpu:e,renderer:n}){const t=Lr({gpu:e}),r=({gpu:e,width:n,height:t})=>Mr({gpu:e,width:n,height:t,type:v.RGBA,minFilter:d.Linear,magFilter:d.Linear,wrapS:p.Repeat,wrapT:p.Repeat}),a=on(t),o=new Map;for(let i=0;i<ii.length;i++){const l=ii[i],{key:s,width:u,height:c,effectFragmentShader:m,effectUniforms:f,tilingEnabled:p,edgeMaskMix:d,remapMin:g,remapMax:h}=l,v=r({gpu:e,width:u,height:c}),x=r({gpu:e,width:u,height:c}),T=ar({vertexShader:Ar(),fragmentShader:m,uniforms:f}),b=ar({vertexShader:Ar(),fragmentShader:"uniform sampler2D uSrcTexture;\r\nuniform float uTilingEnabled;\r\nuniform float uEdgeMaskMix;\r\nuniform float uRemapMin;\r\nuniform float uRemapMax;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nconst float EPS = .001;\r\n\nfloat circularMask(in vec2 uv, in float scale) {\r\n    \n    \n    \r\n    vec2 p = abs(uv - vec2(0.5)) * scale;\r\n    \n    return clamp(0., 1., max(1. - dot(p, p), EPS));\r\n    \n    \n}\n\nfloat edgeMask(in vec2 uv, float band, float rate) {\r\n    vec2 p = abs(fract(uv) - vec2(0.5)) * 2.;\r\n    float e = max(1. - max(p.x, p.y), EPS);\r\n    return e;\n\n    \n    \n    \n    \n    \n    \n}\n\nvoid main() {\r\n    vec2 uv = vUv;\r\n    vec4 textureColor = texture(uSrcTexture, vUv);\n\n    float centerCircularScale = 2.;\r\n    float edgeCircularScale = 2.;\r\n    float topBottomCircularScale = 4.;\r\n    float leftRightCircularScale = 4.;\r\n  \r\n    float maskNum = 9.;\r\n    float baseMaskRate = 1. / maskNum;\r\n    \n    \n    \n    \n    float centerCircularMaskRate = 1.;\r\n    float edgeCircularMaskRate = 1.;\r\n    float topBottomCircularMaskRate = .25;\r\n    float leftRightCircularMaskRate = .25;\r\n    \r\n    float centerMask = circularMask(uv, centerCircularScale) * centerCircularMaskRate;\r\n    float leftTopEdgeCircularMask = circularMask(uv + vec2(.5, -.5), edgeCircularScale) * edgeCircularMaskRate;\r\n    float leftBottomEdgeCircularMask = circularMask(uv + vec2(.5, .5), edgeCircularScale) * edgeCircularMaskRate;\r\n    float rightTopEdgeCircularMask = circularMask(uv + vec2(-.5, -.5), edgeCircularScale) * edgeCircularMaskRate;\r\n    float rightBottomEdgeCircularMask = circularMask(uv + vec2(-.5, .5), edgeCircularScale) * edgeCircularMaskRate;\r\n    float topCircularMask = circularMask(uv + vec2(0., -.5), topBottomCircularScale) * topBottomCircularMaskRate;\r\n    float bottomCircularMask = circularMask(uv + vec2(0., .5), topBottomCircularScale) * topBottomCircularMaskRate;\r\n    float leftCircularMask = circularMask(uv + vec2(.5, 0.), leftRightCircularScale) * leftRightCircularMaskRate;\r\n    float rightCircularMask = circularMask(uv + vec2(-.5, 0.), leftRightCircularScale) * leftRightCircularMaskRate;\n\n    float edgeMask = edgeMask(uv, .1, .1);\n\n    float accCenterMask = centerMask;\n\n    float accEdgeMask =\r\n        mix(\r\n            edgeMask,\r\n            leftTopEdgeCircularMask\r\n            + leftBottomEdgeCircularMask\r\n            + rightTopEdgeCircularMask\r\n            + rightBottomEdgeCircularMask,\r\n            uEdgeMaskMix\r\n        );\r\n    \r\n    float accTopBottomMask =\r\n        mix(\r\n            edgeMask,\r\n            topCircularMask + bottomCircularMask,\r\n            uEdgeMaskMix\r\n        );\r\n    \r\n    float accLeftRightMask =\r\n        mix(\r\n            edgeMask,\r\n            leftCircularMask + rightCircularMask,\r\n            uEdgeMaskMix\r\n        );\n\n    float accTotalMask =\r\n        accCenterMask\r\n        + accEdgeMask\r\n        \n        \n    ;\n\n    vec4 centerColor = texture(uSrcTexture, uv);\r\n    vec4 edgeColor = texture(uSrcTexture, uv + vec2(.5));\r\n    vec4 topBottomColor = texture(uSrcTexture, uv + vec2(0., .5));\r\n    vec4 leftRightColor = texture(uSrcTexture, uv + vec2(.5, 0.));\n\n    vec4 result =\r\n        centerColor * accCenterMask / accTotalMask\r\n        + edgeColor * accEdgeMask / accTotalMask\r\n        + topBottomColor * accTopBottomMask / accTotalMask\r\n        + leftRightColor * accLeftRightMask / accTotalMask;\r\n        \n        \n        \n        \n\n    \n    outColor = vec4(result.xyz, 1.);\r\n    \r\n    float r = accCenterMask * centerColor.r / accTotalMask + accEdgeMask * edgeColor.r / accTotalMask;\r\n    float g = accCenterMask * centerColor.g / accTotalMask + accEdgeMask * edgeColor.g / accTotalMask;\r\n    float b = accCenterMask * centerColor.b / accTotalMask + accEdgeMask * edgeColor.b / accTotalMask;\r\n    \r\n    outColor = mix(\r\n        centerColor,\r\n        vec4(r, g, b, 1.),\r\n        step(.5, uTilingEnabled)\r\n    );\r\n    \r\n    vec3 c = clamp((outColor.xyz - vec3(uRemapMin)) / (uRemapMax - uRemapMin), 0., 1.);\n\n    outColor.xyz = c;\r\n  \r\n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:S.SrcTexture,type:y.Texture,value:null},{name:"uTilingEnabled",type:y.Float,value:p?1:0},{name:"uEdgeMaskMix",type:y.Float,value:d},{name:"uRemapMin",type:y.Float,value:g},{name:"uRemapMax",type:y.Float,value:h}]});or(T,{gpu:e,attributeDescriptors:a}),or(b,{gpu:e,attributeDescriptors:a}),nr(b,S.SrcTexture,v.texture);const C={texture:x.texture,needsUpdate:!1,planeGeometry:t,effectMaterial:T,effectRenderTarget:v,compositeMaterial:b,compositeRenderTarget:x};si(n,C,0),o.set(s,C)}return o}({gpu:e,renderer:n}),l=function(e={}){const{wrapperElement:n,showStats:t=!0,showPipeline:r=!0,showPassDetails:a=!0}=e,o=document.createElement("div"),i=function(e=1){return{renderCount:0,startCountTime:-1/0,calculateInterval:e,currentFPS:0}}();o.style.cssText="\nposition: absolute;\ntop: 0;\nleft: 0;\npadding: 0.2em 0.5em;\nfont-size: 9px;\ncolor: white;\nfont-weight: bold;\ntext-shadow: rgba(0, 0, 0, 0.7) 1px 1px;\nwhite-space: break-spaces;\n";const l=document.createElement("p");o.appendChild(l);const s=document.createElement("div");o.appendChild(s);const u=document.createElement("p");s.appendChild(u);const c=document.createElement("p");s.appendChild(c);const m=document.createElement("p");return s.appendChild(m),(n||document.body).appendChild(o),{passes:[],fpsCounter:i,showStats:t,showPipeline:r,showPassDetails:a,showFPS:!0,domElement:o,fpsCounterView:l,pipelineWrapper:s,passInfoView:u,drawVertexCount:0,drawCallCount:0,drawVertexCountView:c,drawCallCountView:m}}({showStats:a,showPipeline:o}),u={sharedTextures:i,stats:l,renderer:n,scene:null,onBeforeStart:null,onAfterStart:null,onBeforeUpdate:null,onBeforeFixedUpdate:null,onLastUpdate:null,onRender:null},c=function(e,n,t=60){return{targetFPS:e,maxChaseCount:t,callback:n,lastTime:-1/0}}(t,((e,n)=>function(e,n,t){e.onBeforeFixedUpdate&&e.onBeforeFixedUpdate({fixedTime:n,fixedDeltaTime:t}),e.scene&&Pl(e.scene,(r=>{((e,{gpu:n,scene:t,fixedTime:r,fixedDeltaTime:a})=>{var o,i;ji(e,{gpu:n,scene:t}),e.components.forEach((e=>{e.fixedUpdate({gpu:n,fixedTime:r,fixedDeltaTime:a})})),e.animator&&(o=e.animator,i=a,o.playingAnimationClip&&(o.playingAnimationClip.loop=!0,function(e,n){if(!e.isPlaying)return;const t=1/e.fps;e.currentTime+=n*e.speed;const r=t*e.frameCount;if(e.currentTime>r){if(!e.loop)return e.currentFrame=e.frameCount,void(e.currentTime=r);e.currentTime%=r}e.currentFrame=Math.floor(e.currentTime/t),e.keyframes.forEach((n=>{const t=xl(n,e.currentFrame);switch(n.key){case"translation":const e=t;n.target.transform?Ut(n.target.transform,e):n.target.position=e;break;case"rotation":const r=Pn(xn(t));n.target.transform?((e,n)=>{e.rotation=n})(n.target.transform,r):n.target.rotation=r;break;case"scale":const a=t;n.target.transform?Vt(n.target.transform,a):n.target.scale=a}}))}(o.playingAnimationClip,i))),e.onFixedUpdate&&e.onFixedUpdate({gpu:n,scene:t,fixedTime:r,fixedDeltaTime:a})})(r,{gpu:e.renderer.gpu,scene:e.scene,fixedTime:n,fixedDeltaTime:t})}))}(u,e,n))),m=(f=(e,n)=>function(e,n,t){e.onBeforeUpdate&&e.onBeforeUpdate({time:n,deltaTime:t}),e.scene&&(Pl(e.scene,(r=>{switch(((e,{gpu:n,scene:t,time:r,deltaTime:a})=>{ji(e,{gpu:n,scene:t}),e.components.forEach((e=>{e.update({gpu:n,time:r,deltaTime:a})})),e.onUpdate.forEach((e=>{e({gpu:n,scene:t,time:r,deltaTime:a})})),Xi[e.type]?.(e,{gpu:n,scene:t,time:r,deltaTime:a})})(r,{gpu:e.renderer.gpu,scene:e.scene,time:n,deltaTime:t}),r.type){case s.Skybox:case s.Mesh:((e,{gpu:n})=>{e.onBeforeRender&&e.onBeforeRender()})(r,{gpu:e.renderer.gpu});const n=r;n.materials.forEach((n=>{ci(e.renderer,n)})),n.depthMaterials.forEach((n=>{ci(e.renderer,n)}))}})),e.onLastUpdate&&e.onLastUpdate({time:n,deltaTime:t}),Pl(e.scene,(r=>{((e,{gpu:n,scene:t,time:r,deltaTime:a})=>{ji(e,{gpu:n,scene:t}),e.components.forEach((e=>{e.lastUpdate({gpu:n,time:r,deltaTime:a})})),e.onLastUpdate&&e.onLastUpdate({gpu:n,scene:t,time:r,deltaTime:a})})(r,{gpu:e.renderer.gpu,scene:e.scene,time:n,deltaTime:t})})),Pl(e.scene,(e=>{Yi(e)})),function(e,n,t){(e=>{e.passes=[],e.drawVertexCount=0,e.drawCallCount=0})(e.stats),function(e,n,t){!function(e,{time:n,deltaTime:t}){xi(e,b.Common,S.Time,n),xi(e,b.Common,S.DeltaTime,t),xi(e,b.Common,S.Viewport,xr(e.realWidth,e.realHeight,e.realWidth/e.realHeight,0))}(e,{time:n,deltaTime:t})}(e.renderer,n,t),function(e,n,t){n.forEach((n=>{n.needsUpdate&&si(e,n,t)}))}(e.renderer,e.sharedTextures,n),e.onRender&&e.onRender(n,t),((e,n)=>{((e,n)=>{if(e.startCountTime<0)return void Be(e,n);e.renderCount++;const t=n-e.startCountTime;t>e.calculateInterval&&(e.currentFPS=e.renderCount/t,Be(e,n))})(e.fpsCounter,n),(e=>{e.domElement.style.display=e.showStats?"block":"none",e.fpsCounterView.style.display=e.showFPS?"block":"none",e.pipelineWrapper.style.display=e.showPipeline?"block":"none",e.fpsCounterView.textContent=`FPS: ${Math.floor(e.fpsCounter.currentFPS)}`;const n=[];n.push("-------------");for(let t=0;t<e.passes.length;t++){let r=0,a=0;const o=[];for(let n=0;n<e.passes[t].passInfos.length;n++){const i=e.passes[t].passInfos[n];if(e.showPassDetails){const e=`${i.passLabel} - vertex count: ${i.vertexCount}`;o.push(e)}r++,a+=i.vertexCount}o.unshift(`[${e.passes[t].groupLabel}]\ndraw calls: ${r}, vertex count: ${a}`),n.push(...o)}n.push("-------------"),e.passInfoView.textContent=n.join("\n"),e.drawVertexCountView.textContent=`vertex count: ${e.drawVertexCount}`,e.drawCallCountView.textContent=`draw call count: ${e.drawCallCount}`})(e)})(e.stats,n)}(e,n,t))}(u,e,n),{targetFPS:r,callback:f,lastTime:-1/0});var f;return u.fixedUpdateFrameTimer=c,u.updateFrameTimer=m,function(e,n){e.stats=n}(n,l),u}({gpu:ts,renderer:os,showStats:!0,showPipeline:!0});!function(e,n){e.scene=n}(is,rs);const ls=function(e,n,t,r,a){const o={...br({name:void 0,cameraType:0}),fov:35,aspect:1,fixedAspect:!1,near:.1,far:200};return Ai(o),o}();Cl(rs,ls);const ss=function(e=null){return{camera:e,dampingFactor:.01,minAzimuth:-45,maxAzimuth:45,minAltitude:-45,maxAltitude:45,azimuthSpeed:100,altitudeSpeed:100,cameraAngle:{azimuth:0,altitude:0},lookAtTarget:Rt(),distance:10,attenuation:.001,targetX:0,targetY:0,deltaAzimuthPower:1,deltaAltitudePower:1,defaultAzimuth:0,defaultAltitude:0,enabled:!0,enabledUpdateCamera:!0,targetCameraPosition:Rt(),currentCameraPosition:Rt()}}(ls);ss.distance=15,ss.attenuation=.01,ss.dampingFactor=.2,ss.azimuthSpeed=100,ss.altitudeSpeed=100,ss.deltaAzimuthPower=2,ss.deltaAltitudePower=2,ss.maxAltitude=5,ss.minAltitude=-45,ss.maxAzimuth=55,ss.minAzimuth=-55,ss.defaultAzimuth=10,ss.defaultAltitude=-10,ss.lookAtTarget=ft(0,4.5,0),bl(ls,(()=>{var e,n;e=ls,n=xr(0,0,0,1),e.clearColor=n})),ls.onFixedUpdate=()=>{var e;Zl.isDown&&ss.enabled&&function(e,n){e.enabled&&(e.targetX=n.x*e.deltaAzimuthPower,e.targetY=n.y*e.deltaAltitudePower)}(ss,{x:ma(e=Zl.deltaNormalizedInputPosition),y:fa(e)}),function(e){e.enabled&&(e.targetX=Math.sign(e.targetX)*Math.max(0,Math.abs(e.targetX)-e.attenuation),e.targetY=Math.sign(e.targetY)*Math.max(0,Math.abs(e.targetY)-e.attenuation),e.cameraAngle.azimuth+=e.targetX*e.azimuthSpeed,e.cameraAngle.altitude+=e.targetY*e.altitudeSpeed,wl(e))}(ss)};const us=function(e){const n=function({name:e,intensity:n,color:t,lightType:r}){return{...Tl({name:e,type:s.Light}),intensity:n,color:t,lightType:r,castShadow:!1,shadowCamera:null,shadowMap:null,lightViewProjectionMatrix:at(),shadowMapProjectionMatrix:at()}}({intensity:1,color:mr(),lightType:0});return n.shadowCamera=Vi(-1,1,-1,1,.1,1),Mn(n.shadowCamera.transform.rotation,180),Sl(n,n.shadowCamera),{...n}}();us.shadowCamera&&(us.shadowCamera.visibleFrustum=!1,us.castShadow=!1,us.shadowCamera.near=1,us.shadowCamera.far=15,Oi(us.shadowCamera,null,null,-7,7,-7,7),us.shadowMap=Mr({gpu:ts,width:1024,height:1024,type:v.Depth,depthPrecision:g.High})),bl(us,(()=>{Ut(us.transform,ft(-16,16,-4)),zt(us.transform,ft(0,0,0))})),Cl(rs,us);const cs=yi(),ms=function(e){const{gpu:n,enabled:t}=e,r=e.fullViewTextureEnabled||!1,a=[],o=[],i=Lr({gpu:n});a.push({pass:qr({gpu:n,fragmentShader:"#include <common>\r\n#include <buffer_visualizer_h>\r\n#include <depth>\n\nuniform vec2 uTiling;\r\nuniform sampler2D uTextureCol0;\r\nuniform vec2 uTextureCol0UvOffset;\r\nuniform vec2 uTextureCol1UvOffset;\r\nuniform sampler2D uTextureCol2;\r\nuniform vec2 uTextureCol2UvOffset;\r\nuniform sampler2D uTextureCol3;\r\nuniform vec2 uTextureCol3UvOffset;\r\nuniform sampler2D uTextureCol4;\r\nuniform vec2 uTextureCol4UvOffset;\r\nuniform sampler2D uTextureCol5;\r\nuniform vec2 uTextureCol5UvOffset;\n\nuniform float uNearClip;\r\nuniform float uFarClip;\r\nuniform mat4 uInverseViewProjectionMatrix;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\r\n    vec2 tiling = uTiling;\r\n    \n\n    \n    vec2 depthUv = vUv * tiling + uTextureCol0UvOffset;\r\n    vec2 worldPositionUv = vUv * tiling + uTextureCol1UvOffset;\r\n    \r\n    \r\n    \n\n    float rawDepth = texture(uTextureCol0, depthUv).x * isArea(depthUv);\r\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\r\n    \r\n    vec3 worldPosition = reconstructWorldPositionFromDepth(\r\n        worldPositionUv,\r\n        texture(uTextureCol0, worldPositionUv).x,\r\n        uInverseViewProjectionMatrix\r\n    );\n\n    vec4 depthColor = calcAreaColor(vec4(sceneDepth), vUv, tiling, vec2(0., 0.));\r\n    vec4 worldPositionColor = calcAreaColor(vec4(worldPosition, 1.), vUv, tiling, vec2(-1., 0.));\r\n    vec4 color2 = calcTextureAreaColor(uTextureCol2, vUv, tiling, uTextureCol2UvOffset);\r\n    vec4 color3 = calcTextureAreaColor(uTextureCol3, vUv, tiling, uTextureCol3UvOffset);\r\n    vec4 color4 = calcTextureAreaColor(uTextureCol4, vUv, tiling, uTextureCol4UvOffset);\r\n    vec4 color5 = calcTextureAreaColor(uTextureCol5, vUv, tiling, uTextureCol5UvOffset);\n\n    outColor = depthColor + worldPositionColor + color2 + color3 + color4 + color5;\r\n}",uniforms:[{name:"uNearClip",type:y.Float,value:.1},{name:"uFarClip",type:y.Float,value:1},{name:"uInverseViewProjectionMatrix",type:y.Matrix4,value:at()}]}),tiles:new Map([[so,{label:"depth",type:"Texture"}],["worldPosition",{type:"Other",uniformPrefix:"uWorldPosition"}],[uo,{type:"Texture"}],[co,{type:"Texture"}],[mo,{type:"Texture"}],[fo,{type:"Texture"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[po,{type:"Texture"}],[`${go}0`,{type:"Texture"}],[`${go}1`,{type:"Texture"}],[`${go}2`,{type:"Texture"}],[`${go}3`,{type:"Texture"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[ho,{type:"Texture"}],[vo,{type:"Texture"}],[xo,{type:"Texture"}],[To,{type:"Texture",label:"combine ssr"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[yo,{type:"Texture"}],[So,{type:"Texture"}],[bo,{type:"Texture",label:"combine fog"}],[Co,{type:"Texture",label:"dof"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[Mo,{type:"Texture",label:"bloom blur mip4"}],[Po,{type:"Texture",label:"bloom blur mip8"}],[wo,{type:"Texture",label:"bloom blur mip16"}],[Ro,{type:"Texture",label:"bloom blur mip32"}],[Do,{type:"Texture",label:"bloom blur mip64"}],[Fo,{type:"Texture",label:"bloom"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[Lo,{type:"Texture"}],[Bo,{type:"Texture"}],[Eo,{type:"Texture"}],[Io,{type:"Texture"}],[Ao,{type:"Texture"}],[No,{type:"Texture"}]])}),a.push({pass:qr({gpu:n,fragmentShader:lo,srcTextureEnabled:!1}),tiles:new Map([[ko,{type:"Texture"}],[Oo,{type:"Texture"}],[_o,{type:"Texture"}],[Vo,{type:"Texture"}],[Uo,{type:"Texture"}],[zo,{type:"Texture"}]])});const l=qr({gpu:n,name:"BufferVisualizerPass",fragmentShader:"#include <common>\r\n#include <buffer_visualizer_h>\n\nuniform vec2 uTiling;\r\nuniform sampler2D uRow0Texture;\r\nuniform sampler2D uRow1Texture;\r\nuniform sampler2D uRow2Texture;\r\nuniform sampler2D uRow3Texture;\r\nuniform sampler2D uRow4Texture;\r\nuniform sampler2D uRow5Texture;\r\nuniform sampler2D uRow6Texture;\r\nuniform sampler2D uFullViewTexture;\n\nuniform float uFullViewTextureEnabled;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\r\n    vec2 tiling = vec2(1., 7.);\r\n    \n    vec4 color0 = calcTextureAreaColor(uRow0Texture, vUv, tiling, vec2(0., -6.));\r\n    vec4 color1 = calcTextureAreaColor(uRow1Texture, vUv, tiling, vec2(0., -5.));\r\n    vec4 color2 = calcTextureAreaColor(uRow2Texture, vUv, tiling, vec2(0., -4.));\r\n    vec4 color3 = calcTextureAreaColor(uRow3Texture, vUv, tiling, vec2(0., -3.));\r\n    vec4 color4 = calcTextureAreaColor(uRow4Texture, vUv, tiling, vec2(0., -2.));\r\n    vec4 color5 = calcTextureAreaColor(uRow5Texture, vUv, tiling, vec2(0., -1.));\r\n    vec4 color6 = calcTextureAreaColor(uRow6Texture, vUv, tiling, vec2(0., 0.));\r\n    outColor = mix(\r\n        color0 + color1 + color2 + color3 + color4 + color5 + color6,\r\n        texture(uFullViewTexture, vUv),\r\n        step(.5, uFullViewTextureEnabled)\r\n    );\r\n}",srcTextureEnabled:!1,uniforms:[{name:"uFullViewTexture",type:y.Texture,value:n.dummyTextureBlack},{name:"uFullViewTextureEnabled",type:y.Float,value:0},...Vr.range(7).map(((e,t)=>[{name:`uRow${t}Texture`,type:y.Texture,value:n.dummyTextureBlack}])).flat(),...Nr()]});a.forEach((({pass:e})=>o.push(e.material))),o.push(l.material),a.forEach((({pass:e,tiles:t},r)=>{let a=0;tr(e.material,"uTiling",y.Vector2,ca(7,1));for(const[o,i]of t){const l=i.uniformNamePrefix||"uTextureCol",s=`${l}${a}`,u=`${s}UvOffset`,c=-a;i.uniformNamePrefix||(t.get(o).uniformNamePrefix=l),"Texture"===i.type&&(t.get(o).uniformNameTexture=s),t.get(o).uniformNameUvOffset=u,0===r?(tr(e.material,u,y.Vector2,ca(c,0)),"Texture"===i.type&&tr(e.material,s,y.Texture,n.dummyTextureBlack)):(tr(e.material,u,y.Vector2,ca(c,0)),tr(e.material,s,y.Texture,n.dummyTextureBlack)),a++}})),tr(l.material,"uTiling",y.Vector2,ca(1,7));const s=document.createElement("style");s.textContent="\n.buffer-visualizer-pass {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    display: grid;\n    grid-template-rows: repeat(7, 1fr);\n}\n.buffer-visualizer-pass.hidden {\n    display: none;\n}\n.buffer-visualizer-pass-tile {\n    display: flex;\n    justify-content: flex-start;\n    align-items: flex-end;\n    font-size: 9px;\n    line-height: 1em;\n    font-weight: bold;\n    text-shadow: 1px 1px #333;\n    padding: 4px;\n}\n\n.buffer-visualizer-pass-row {\n    // display: flex;\n    display: grid;\n    grid-template-columns: repeat(7, 1fr);\n}\n        ",document.head.appendChild(s);const u=document.createElement("div");u.classList.add("buffer-visualizer-pass");const c=document.createDocumentFragment();a.forEach((({tiles:e},n)=>{let t=0;const r=document.createElement("div");r.classList.add("buffer-visualizer-pass-row");for(const[a,o]of e){const e=`[${t}, ${n}] ${o.label||a}`,i=document.createElement("div");i.classList.add("buffer-visualizer-pass-tile");const l=document.createElement("p");l.textContent=e,i.appendChild(l),r.appendChild(i),t++}c.appendChild(r)})),u.appendChild(c),document.body.appendChild(u);const m={...Er({gpu:n,name:"BufferVisualizerPass",type:2,geometry:i,materials:o,enabled:t||!1}),dom:u,rowPasses:a,compositePass:l,toggleR:!0,fullViewTextureEnabled:r};return Go(m),window.addEventListener("keydown",(e=>{"b"===e.key&&(m.enabled=!m.enabled,m.toggleR=!m.toggleR,m.enabled?jo(m):Go(m))})),window.addEventListener("keydown",(e=>{"f"===e.key&&(m.fullViewTextureEnabled=!m.fullViewTextureEnabled)})),m}({gpu:ts});var fs;ms.enabled=!1,bi(cs,ms),cs.selfEnabled=!0,fs=cs,ls.postProcess=fs,(async()=>{Jl=await async function(e,n,t,r,a,o,i){return await Promise.all([{axis:0,path:"./assets/images/skybox/px.png"},{axis:1,path:"./assets/images/skybox/nx.png"},{axis:2,path:"./assets/images/skybox/py.png"},{axis:3,path:"./assets/images/skybox/ny.png"},{axis:4,path:"./assets/images/skybox/pz.png"},{axis:5,path:"./assets/images/skybox/nz.png"}].map((async({axis:e,path:n})=>({axis:e,img:await yr(n)})))).then((n=>Ge(e,...n.map((({img:e})=>e)))))}(ts);const e=function({gpu:e,cubeMap:n,baseIntensity:a=1,specularIntensity:o=1,rotationOffset:l=0,renderMesh:u=!0}){const c=function(e){const n=[],t=[],r=[],a=[];"\n# Blender 3.3.1\n# www.blender.org\nmtllib skybox-cube.mtl\nv -1.000000 -1.000000 1.000000\nv -1.000000 1.000000 1.000000\nv -1.000000 -1.000000 -1.000000\nv -1.000000 1.000000 -1.000000\nv 1.000000 -1.000000 1.000000\nv 1.000000 1.000000 1.000000\nv 1.000000 -1.000000 -1.000000\nv 1.000000 1.000000 -1.000000\nvn 0.5774 0.5774 0.5774\nvn 0.5774 -0.5774 -0.5774\nvn 0.5774 0.5774 -0.5774\nvn -0.5774 0.5774 0.5774\nvn 0.5774 -0.5774 0.5774\nvn -0.5774 0.5774 -0.5774\nvn -0.5774 -0.5774 0.5774\nvn -0.5774 -0.5774 -0.5774\nvt 0.375000 0.000000\nvt 0.375000 1.000000\nvt 0.125000 0.750000\nvt 0.625000 0.000000\nvt 0.625000 1.000000\nvt 0.875000 0.750000\nvt 0.125000 0.500000\nvt 0.375000 0.250000\nvt 0.625000 0.250000\nvt 0.875000 0.500000\nvt 0.375000 0.750000\nvt 0.625000 0.750000\nvt 0.375000 0.500000\nvt 0.625000 0.500000\ns 1\nf 3/8/1 2/4/2 1/1/3\nf 7/13/4 4/9/5 3/8/1\nf 5/11/6 8/14/7 7/13/4\nf 1/2/3 6/12/8 5/11/6\nf 1/3/3 7/13/4 3/7/1\nf 6/12/8 4/10/5 8/14/7\nf 3/8/1 4/9/5 2/4/2\nf 7/13/4 8/14/7 4/9/5\nf 5/11/6 6/12/8 8/14/7\nf 1/2/3 2/5/2 6/12/8\nf 1/3/3 5/11/6 7/13/4\nf 6/12/8 2/6/2 4/10/5\n".split("\n").forEach((e=>{const o=e.split(" ");switch(o[0]){case"v":n.push([Number.parseFloat(o[1]),Number.parseFloat(o[2]),Number.parseFloat(o[3])]);break;case"vn":t.push([Number.parseFloat(o[1]),Number.parseFloat(o[2]),Number.parseFloat(o[3])]);break;case"vt":r.push([Number.parseFloat(o[1]),Number.parseFloat(o[2])]);break;case"f":a.push([o[1],o[2],o[3]])}}));const o=[],i=[],l=[],s=[];return a.forEach(((e,a)=>{const u=e[0].split("/"),c=e[1].split("/"),m=e[2].split("/"),f=Number.parseInt(u[0],10)-1,p=Number.parseInt(u[1],10)-1,d=Number.parseInt(u[2],10)-1,g=Number.parseInt(c[0],10)-1,h=Number.parseInt(c[1],10)-1,v=Number.parseInt(c[2],10)-1,x=Number.parseInt(m[0],10)-1,T=Number.parseInt(m[1],10)-1,y=Number.parseInt(m[2],10)-1;o.push(n[f],n[g],n[x]),i.push(r[p],r[h],r[T]),l.push(t[d],t[v],t[y]);const S=2*a;s.push(a+S,a+S+1,a+S+2)})),{positions:o.flat(),uvs:i.flat(),normals:l.flat(),indices:s}}();return{...Sr({geometry:$t({gpu:e,attributes:[Ee({name:T.Position,data:new Float32Array(c.positions),size:3}),Ee({name:T.Uv,data:new Float32Array(c.uvs),size:2}),Ee({name:T.Normal,data:new Float32Array(c.normals),size:3})],indices:c.indices,drawCount:c.indices.length}),material:ar({name:"Skybox",vertexShader:"#pragma APPEND_ATTRIBUTES\n\n#pragma DEFINES\n\n#pragma ATTRIBUTES\n\n#include <lighting>\r\n#include <ub>\n\n#pragma APPEND_UNIFORMS\n\nout vec2 vUv;\r\nout vec3 vNormal;\r\nout vec3 vWorldPosition;\n\nvoid main() {\r\n    vUv = aUv;\r\n    vNormal = (uNormalMatrix * vec4(aNormal, 1)).xyz;\r\n    vec4 worldPosition = uWorldMatrix * vec4(aPosition, 1);\r\n    vWorldPosition = worldPosition.xyz;\r\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\r\n}",fragmentShader:"#pragma DEFINES\n\n#include <lighting>\r\n#include <ub>\r\n#include <tone>\r\n#include <gbuffer>\r\n#include <geometry_h>\r\n#include <skybox_h>\n\nin vec2 vUv;\r\nin vec3 vNormal;\r\nin vec3 vWorldPosition;\n\nuniform samplerCube uCubeTexture;\r\nuniform float uRotationOffset;\r\nuniform int uShadingModelId;\n\n#include <gbuffer_o>\n\nvoid main() {\r\n    \n    vec3 N = normalize(vNormal);\r\n    vec3 reflectDir = -N;\r\n    \r\n    \n    \n    \n    \r\n    \n    vec3 skyboxSampleDir = calcEnvMapSampleDir(reflectDir, uRotationOffset);\r\n    \n    \n    vec3 envMapColor = textureLod(uCubeTexture, skyboxSampleDir, 0.).xyz;\r\n  \r\n    \n    envMapColor = gamma(envMapColor); \r\n        \r\n    \n    \n    \n    outGBufferA = EncodeGBufferA(envMapColor);\r\n    outGBufferB = EncodeGBufferB(vec3(0.), uShadingModelId);\r\n    outGBufferC = EncodeGBufferC(0., 0.);\r\n    outGBufferD = EncodeGBufferD(vec3(0.));\r\n}",primitiveType:t.Triangles,renderQueueType:i.Skybox,depthTest:!0,depthWrite:!1,useEnvMap:!0,uniforms:[{name:S.CubeTexture,type:y.CubeMap,value:n},{name:S.RotationOffset,type:y.Float,value:l},{name:S.ShadingModelId,type:y.Int,value:r.Skybox}],uniformBlockNames:[b.Transformations,b.Camera]}),type:s.Skybox}),cubeMap:n,baseIntensity:a,specularIntensity:o,rotationOffset:l,renderMesh:u}}({gpu:ts,cubeMap:Jl,baseIntensity:20,specularIntensity:.2,rotationOffset:0});Xl=await(async()=>await vl({gpu:ts,dir:jl,path:"street-floor-separete.gltf"}))(),Cl(rs,Xl),Xl.children.forEach((e=>{e.enabled=!1,e.type===s.Mesh&&(e.castShadow=!0)})),Vt(Xl.transform,Ot(1));const n=(Xl?.children[0]).materials[0];er(n.uniforms,S.Metallic,.5),er(n.uniforms,S.Roughness,1),ql=await(async()=>await vl({gpu:ts,dir:jl,path:"bg-static.gltf"}))(),ql.children[0].materials=[Tr({emissiveColor:ir(2,2,2,1)})],Cl(rs,ql),Ut(ql.transform,ft(0,-6,-20)),Vt(ql.transform,Ot(8)),Yl=function(e){const{gpu:n,name:t,materialArgs:r,castShadow:a,size:o}=e,i=function({gpu:e,size:n=1}){const t=n/2,r=[-t,t,t],a=[-t,-t,t],o=[t,t,t],i=[t,-t,t],l=[t,t,-t],s=[t,-t,-t],u=[-t,t,-t],c=[-t,-t,-t],m=[...r,...a,...o,...i,...o,...i,...l,...s,...l,...s,...u,...c,...u,...c,...r,...a,...u,...r,...l,...o,...a,...c,...i,...s];return{...$t({gpu:e,attributes:[Ee({name:T.Position,data:new Float32Array(m),size:3}),Ee({name:T.Uv,data:new Float32Array(new Array(6).fill(0).map((()=>[0,1,0,0,1,1,1,0])).flat()),size:2}),Ee({name:T.Normal,data:new Float32Array([[0,0,1],[1,0,0],[0,0,-1],[-1,0,0],[0,1,0],[0,-1,0]].map((e=>new Array(4).fill(0).map((()=>e)))).flat(2)),size:3})],indices:Array.from(Array(6).keys()).map((e=>[4*e+0,4*e+1,4*e+2,4*e+2,4*e+1,4*e+3])).flat(),drawCount:36}),cornerPositions:[r,a,o,i,l,s,u,c]}}({gpu:n,size:o});return Sr({name:t,geometry:i,materials:e.materials?e.materials:[El({fragmentShaderContent:e.fragmentShaderContent,depthFragmentShaderContent:e.depthFragmentShaderContent,materialArgs:r})],castShadow:a,meshType:u.ObjectSpaceRaymarch})}({name:"object-space-raymarch-mesh",gpu:ts,materials:[zl({fragmentShaderContent:Ul,depthFragmentShaderContent:Ul,receiveShadow:!1,renderQueueType:i.Transparent,blendType:o.Transparent,depthTest:!0,depthWrite:!0,depthFuncType:a.Lequal,faceSide:m.Front,uniforms:[{name:S.SceneTexture,type:y.Texture,value:null},{name:"uMorphRate",type:y.Float,value:0}]})],castShadow:!0}),Yl.onUpdate.push((e=>{const{time:n}=e;var t,r,a;r="uMorphRate",a=Kl.morphingEnabled?n:Kl.morphRate,(t=Yl).materials.forEach((e=>nr(e,r,a))),t.depthMaterials.forEach((e=>nr(e,r,a)))})),Vt(Yl.transform,ft(10,10,10)),Ut(Yl.transform,ft(0,5,0)),Cl(rs,e),Cl(rs,Yl);const l=()=>{Hl=Ql.offsetWidth,$l=Ql.offsetHeight,function(e,n,t){e.width=n,e.height=t}(Zl,Hl,$l),function(e,n,t){const r=n*e.renderer.pixelRatio,a=t*e.renderer.pixelRatio,o=Math.floor(r),i=Math.floor(a);Pl(e.scene,(e=>{((e,n,t)=>{$i[e.type]?.(e,n,t)})(e,o,i)})),function(e,n,t){const r=Math.floor(n),a=Math.floor(t);e.realWidth=r,e.realHeight=a,e.canvas.width=r,e.canvas.height=a,Ke(e.gpu,0,0,r,a),wr(e.depthPrePassRenderTarget,r,a),Fr(e.gBufferRenderTargets,r,a),wr(e.afterDeferredShadingRenderTarget,r,a),wr(e.copyDepthSourceRenderTarget,r,a),wr(e.copyDepthDestRenderTarget,r,a),wr(e.copySceneSourceRenderTarget,r,a),wr(e.copySceneDestRenderTarget,r,a),$o(e.screenSpaceShadowPass,r,a),$o(e.ambientOcclusionPass,r,a),$o(e.deferredShadingPass,r,a),$o(e.ssrPass,r,a),$o(e.lightShaftPass,r,a),$o(e.volumetricLightPass,r,a),$o(e.fogPass,r,a),$o(e.depthOfFieldPass,r,a),$o(e.bloomPass,r,a),$o(e.streakPass,r,a),$o(e.toneMappingPass,r,a),$o(e.chromaticAberrationPass,r,a),$o(e.glitchPass,r,a),$o(e.vignettePass,r,a),$o(e.fxaaPass,r,a)}(e.renderer,r,a)}(is,Hl,$l)};!function(e,n){e.onBeforeStart=()=>{l(),window.addEventListener("resize",l),os.ambientOcclusionPass.enabled=!1,os.lightShaftPass.enabled=!1,os.screenSpaceShadowPass.enabled=!1,os.ssrPass.enabled=!1,os.depthOfFieldPass.focusDistance=18.5,os.depthOfFieldPass.focusRange=17,os.fogPass.fogColor=fr(),os.fogPass.fogDensity=.001,os.fogPass.fogDensityAttenuation=.001,os.fogPass.distanceFogStart=1e3,os.fogPass.distanceFogEnd=1e3,os.fogPass.distanceFogPower=.29,os.fogPass.sssFogRate=0,os.depthOfFieldPass.focusDistance=17.78,os.depthOfFieldPass.focusRange=9.8,os.depthOfFieldPass.bokehRadius=5.55,os.bloomPass.bloomAmount=.26,os.bloomPass.threshold=1.534,os.bloomPass.tone=.46,os.streakPass.threshold=.9,os.streakPass.verticalScale=1.12,os.streakPass.horizontalScale=1.9,os.streakPass.intensity=.03,os.glitchPass.enabled=!1,os.vignettePass.vignetteRadiusTo=5,((e,n=null,t=null)=>{e.cameraAngle.azimuth=null!==n?n:e.defaultAzimuth,e.cameraAngle.altitude=null!==t?t:e.defaultAltitude,wl(e,!0)})(ss)}}(is),function(e,n){e.onBeforeUpdate=()=>{Wl||(Wl=function(e,{debuggerStates:n,renderer:t,orbitCameraController:r,bufferVisualizerPass:a,directionalLight:o,objectSpaceRaymarchMesh:i}){const l=Il();_l(l,{label:"morph rate",minValue:0,maxValue:1,stepValue:.001,initialValue:n.morphRate,onChange:e=>{n.morphRate=9*e}}),Ol(l,{label:"auto morph",initialValue:n.morphingEnabled,onChange:e=>n.morphingEnabled=e}),Vl(l),Ol(l,{label:"orbit controls enabled",initialValue:r.enabled,onChange:e=>r.enabled=e}),Vl(l);const s=Nl(l,"object space raymarch",!1);var u;_l(s,{label:"pos x",minValue:-10,maxValue:10,stepValue:.001,initialValue:pt(i.transform.position),onChange:e=>{ht(i.transform.position,e)}}),_l(s,{label:"pos y",minValue:0,maxValue:10,stepValue:.001,initialValue:dt(i.transform.position),onChange:e=>{vt(i.transform.position,e)}}),_l(s,{label:"pos z",minValue:-10,maxValue:10,stepValue:.001,initialValue:gt(i.transform.position),onChange:e=>{xt(i.transform.position,e)}}),_l(s,{label:"scale x",minValue:0,maxValue:15,stepValue:.001,initialValue:pt(i.transform.scale),onChange:e=>{ht(i.transform.scale,e)}}),_l(s,{label:"scale y",minValue:0,maxValue:15,stepValue:.001,initialValue:dt(i.transform.scale),onChange:e=>{vt(i.transform.scale,e)}}),_l(s,{label:"scale z",minValue:0,maxValue:15,stepValue:.001,initialValue:gt(i.transform.scale),onChange:e=>{xt(i.transform.scale,e)}}),_l(s,{label:"rotation x",minValue:0,maxValue:360,stepValue:.01,initialValue:(u=i.transform.rotation,hn(u.quaternion).x),onChange:e=>{!function(e,n){const t=hn(e.quaternion);t.x=n;const r=vn(t.x,t.y,t.z);e.quaternion=r}(i.transform.rotation,e)}}),_l(s,{label:"rotation y",minValue:0,maxValue:360,stepValue:.01,initialValue:Sn(i.transform.rotation),onChange:e=>{Mn(i.transform.rotation,e)}}),_l(s,{label:"rotation z",minValue:0,maxValue:360,stepValue:.01,initialValue:bn(i.transform.rotation),onChange:e=>{!function(e,n){const t=hn(e.quaternion);t.z=n;const r=vn(t.x,t.y,t.z);e.quaternion=r}(i.transform.rotation,e)}}),Vl(l);const c=Nl(l,"volumetric light",!1);_l(c,{label:"ray step",initialValue:t.volumetricLightPass.rayStep,minValue:.001,maxValue:1,stepValue:.001,onChange:e=>{t.volumetricLightPass.rayStep=e}}),_l(c,{label:"density multiplier",initialValue:t.volumetricLightPass.densityMultiplier,minValue:.001,maxValue:10,stepValue:.001,onChange:e=>{t.volumetricLightPass.densityMultiplier=e}}),_l(c,{label:"jitter size x",initialValue:pt(t.volumetricLightPass.rayJitterSize),minValue:0,maxValue:1,stepValue:.001,onChange:e=>{ht(t.volumetricLightPass.rayJitterSize,e)}}),_l(c,{label:"jitter size y",initialValue:dt(t.volumetricLightPass.rayJitterSize),minValue:0,maxValue:1,stepValue:.001,onChange:e=>{vt(t.volumetricLightPass.rayJitterSize,e)}}),_l(c,{label:"blend rate",initialValue:t.volumetricLightPass.blendRate,minValue:0,maxValue:1,stepValue:.001,onChange:e=>{t.volumetricLightPass.blendRate=e}}),Vl(l);const m=Nl(l,"fog",!1);kl(m,{label:"fog color",initialValue:cr(t.fogPass.fogColor),onChange:e=>{t.fogPass.fogColor=dr(e)}}),_l(m,{label:"strength",minValue:0,maxValue:.2,stepValue:1e-4,initialValue:t.fogPass.fogStrength,onChange:e=>{t.fogPass.fogStrength=e}}),_l(m,{label:"density",minValue:0,maxValue:1,stepValue:1e-4,initialValue:t.fogPass.fogDensity,onChange:e=>{t.fogPass.fogDensity=e}}),_l(m,{label:"attenuation",minValue:0,maxValue:1,stepValue:1e-4,initialValue:t.fogPass.fogDensityAttenuation,onChange:e=>{t.fogPass.fogDensityAttenuation=e}}),_l(m,{label:"fog end height",minValue:-5,maxValue:5,stepValue:1e-4,initialValue:t.fogPass.fogEndHeight,onChange:e=>{t.fogPass.fogEndHeight=e}}),_l(m,{label:"distance fog start",minValue:0,maxValue:1e3,stepValue:1e-4,initialValue:t.fogPass.distanceFogStart,onChange:e=>{t.fogPass.distanceFogStart=e}}),_l(m,{label:"distance fog end",minValue:0,maxValue:1e3,stepValue:1e-4,initialValue:t.fogPass.distanceFogEnd,onChange:e=>{t.fogPass.distanceFogEnd=e}}),_l(m,{label:"distance fog power",minValue:0,maxValue:.2,stepValue:1e-4,initialValue:t.fogPass.distanceFogPower,onChange:e=>{t.fogPass.distanceFogPower=e}}),_l(m,{label:"sss fog rate",minValue:0,maxValue:1,stepValue:.001,initialValue:t.fogPass.sssFogRate,onChange:e=>{t.fogPass.sssFogRate=e}}),_l(m,{label:"blend rate",minValue:0,maxValue:1,stepValue:1e-4,initialValue:t.fogPass.blendRate,onChange:e=>{t.fogPass.blendRate=e}}),Vl(l);const f=Nl(l,"depth of field",!1);_l(f,{label:"DoF focus distance",minValue:.1,maxValue:100,stepValue:.001,initialValue:t.depthOfFieldPass.focusDistance,onChange:e=>{t.depthOfFieldPass.focusDistance=e}}),_l(f,{label:"DoF focus range",minValue:.1,maxValue:30,stepValue:.001,initialValue:t.depthOfFieldPass.focusRange,onChange:e=>{t.depthOfFieldPass.focusRange=e}}),_l(f,{label:"DoF bokeh radius",minValue:.01,maxValue:10,stepValue:.001,initialValue:t.depthOfFieldPass.bokehRadius,onChange:e=>{t.depthOfFieldPass.bokehRadius=e}}),Vl(l);const p=Nl(l,"bloom",!1);_l(p,{label:"bloom amount",minValue:0,maxValue:4,stepValue:.001,initialValue:t.bloomPass.bloomAmount,onChange:e=>{t.bloomPass.bloomAmount=e}}),_l(p,{label:"bloom threshold",minValue:0,maxValue:5,stepValue:.001,initialValue:t.bloomPass.threshold,onChange:e=>{t.bloomPass.threshold=e}}),_l(p,{label:"bloom tone",minValue:0,maxValue:1,stepValue:.001,initialValue:t.bloomPass.tone,onChange:e=>{t.bloomPass.tone=e}}),Vl(l);const d=Nl(l,"streak",!1);_l(d,{label:"threshold",minValue:0,maxValue:4,stepValue:.001,initialValue:t.streakPass.threshold,onChange:e=>{t.streakPass.threshold=e}}),_l(d,{label:"vertical scale",minValue:0,maxValue:10,stepValue:.001,initialValue:t.streakPass.verticalScale,onChange:e=>{t.streakPass.verticalScale=e}}),_l(d,{label:"horizontal scale",minValue:0,maxValue:2,stepValue:.001,initialValue:t.streakPass.horizontalScale,onChange:e=>{t.streakPass.horizontalScale=e}}),_l(d,{label:"stretch",minValue:0,maxValue:1,stepValue:.001,initialValue:t.streakPass.stretch,onChange:e=>{t.streakPass.stretch=e}}),kl(d,{label:"color",initialValue:cr(t.streakPass.color),onChange:e=>{t.streakPass.color=dr(e)}}),_l(d,{label:"intensity",minValue:0,maxValue:1,stepValue:.001,initialValue:t.streakPass.intensity,onChange:e=>{t.streakPass.intensity=e}}),Vl(l);const g=Nl(l,"chromatic aberration",!1);_l(g,{label:"scale",minValue:0,maxValue:.1,stepValue:.001,initialValue:t.chromaticAberrationPass.scale,onChange:e=>t.chromaticAberrationPass.scale=e}),Vl(l);const h=Nl(l,"vignette",!1);_l(h,{label:"radius from",minValue:0,maxValue:5,stepValue:.001,initialValue:t.vignettePass.vignetteRadiusFrom,onChange:e=>t.vignettePass.vignetteRadiusFrom=e}),_l(h,{label:"radius to",minValue:0,maxValue:5,stepValue:.001,initialValue:t.vignettePass.vignetteRadiusTo,onChange:e=>t.vignettePass.vignetteRadiusTo=e}),_l(h,{label:"power",minValue:.01,maxValue:8,stepValue:.001,initialValue:t.vignettePass.vignettePower,onChange:e=>t.vignettePass.vignettePower=e}),_l(h,{label:"blend rate",minValue:0,maxValue:1,stepValue:.001,initialValue:t.vignettePass.blendRate,onChange:e=>t.vignettePass.blendRate=e}),Vl(l);const v=Nl(l,"fxaa",!1);return Ol(v,{label:"fxaa pass enabled",initialValue:t.fxaaPass.enabled,onChange:e=>t.fxaaPass.enabled=e}),e.appendChild(l.rootElement),l}(Ql,{debuggerStates:Kl,renderer:os,orbitCameraController:ss,bufferVisualizerPass:ms,directionalLight:us,objectSpaceRaymarchMesh:Yl})),function(e){!function(e,{inputPosition:n,isDown:t}){(function(e,n){const t=e.isDown;e.isDown=n,!t&&e.isDown?(e.isPressed=!0,e.isReleased=!1):!t&&e.isDown?(e.isPressed=!1,e.isReleased=!1):t&&!e.isDown?(e.isPressed=!1,e.isReleased=!0):(e.isPressed=!1,e.isReleased=!1)})(e,t),function(e,n){(function(e){return!e.isDown})(e)||e.isPressed&&(va(e.currentInputPosition,n),va(e.beforeInputPosition,e.currentInputPosition),ga(e.deltaInputPosition,0,0),ga(e.deltaNormalizedInputPosition,0,0)),va(e.beforeInputPosition,e.currentInputPosition),va(e.currentInputPosition,n);const t=(r=e.currentInputPosition,a=e.beforeInputPosition,ca(ma(r)-ma(a),fa(r)-fa(a)));var r,a;va(e.deltaInputPosition,t);const o=Math.min(e.width,e.height);ga(e.deltaNormalizedInputPosition,ma(e.deltaInputPosition)/o,fa(e.deltaInputPosition)/o),ga(e.normalizedInputPosition,ma(e.currentInputPosition)/e.width,fa(e.currentInputPosition)/e.height)}(e,n)}(e,{inputPosition:e.tmpInputPosition,isDown:e.tmpIsDown})}(Zl)}}(is),function(e,n){e.onRender=n}(is,(e=>{!function(e,n,t,r,{time:a,onBeforePostProcess:l}){const u={[i.Opaque]:[],[i.AlphaTest]:[],[i.Skybox]:[],[i.Transparent]:[]},c={directionalLight:null,spotLights:[],pointLights:[]};Pl(n,(e=>{switch(e.type){case s.Skybox:if(!e.enabled)return;return void u[i.Skybox].push(pi(e,i.Skybox));case s.Mesh:if(!e.enabled)return;if(!e.renderEnabled)return;e.materials.forEach(((n,t)=>{if(null==n.alphaTest)switch(n.blendType){case o.Opaque:return void u[i.Opaque].push(pi(e,i.Opaque,t));case o.Transparent:case o.Additive:return void u[i.Transparent].push(pi(e,i.Transparent,t))}else u[i.AlphaTest].push(pi(e,i.AlphaTest,t))}));break;case s.Light:if(e.enabled){const n=e;switch(n.lightType){case 0:c.directionalLight=n;break;case 1:c.spotLights.push(n);break;case 2:c.pointLights.push(n)}}}}));const m=Ti(u,t);c.directionalLight&&function(e,n){xi(e,b.DirectionalLight,S.DirectionalLight,[{name:S.LightDirection,type:y.Vector3,value:St(Ct(Pt(n.transform.position)))},{name:S.LightIntensity,type:y.Float,value:n.intensity},{name:S.LightColor,type:y.Color,value:n.color},{name:S.ShadowMapProjectionMatrix,type:y.Matrix4,value:n.shadowMapProjectionMatrix}])}(e,c.directionalLight),c.spotLights.length>0&&function(e,n){xi(e,b.SpotLight,S.SpotLight,n.map((e=>[{name:S.LightColor,type:y.Color,value:e.color},{name:S.LightPosition,type:y.Vector3,value:e.transform.position},{name:S.LightDirection,type:y.Vector3,value:Pt(_t(e.transform))},{name:S.LightIntensity,type:y.Float,value:e.intensity},{name:S.LightDistance,type:y.Float,value:e.distance},{name:S.LightAttenuation,type:y.Float,value:e.attenuation},{name:S.LightConeCos,type:y.Float,value:ni(e)},{name:S.LightPenumbraCos,type:y.Float,value:ti(e)},{name:S.ShadowMapProjectionMatrix,type:y.Matrix4,value:e.shadowMapProjectionMatrix}])))}(e,c.spotLights),c.pointLights.length>0&&function(e,n){xi(e,b.PointLight,S.PointLight,n.map((e=>[{name:S.LightColor,type:y.Color,value:e.color},{name:S.LightPosition,type:y.Vector3,value:e.transform.position},{name:S.LightIntensity,type:y.Float,value:e.intensity},{name:S.LightDistance,type:y.Float,value:e.distance},{name:S.LightAttenuation,type:y.Float,value:e.attenuation}])),!0)}(e,c.pointLights),function(e,n,t){mi(e,e.depthPrePassRenderTarget,!1,!0),vi(e,t),n.forEach((({actor:n,materialIndex:t})=>{hi(e,n),n.depthMaterials.forEach(((r,a)=>{r&&r.canRender&&a===t&&(n.materials[a].skipDepthPrePass||(fi(e,n.geometry,r),e.stats&&ln(e.stats,"depth pre pass",n.name,n.geometry)))}))}))}(e,m.basePass,t),function(e,n){const t=e.gpu.gl;e.depthTexture=n,ze(e.framebuffer),t.framebufferTexture2D(B,xe,D,e.depthTexture.glObject,0),je(e.framebuffer)}(e.gBufferRenderTargets,e.depthPrePassRenderTarget.depthTexture),mi(e,e.gBufferRenderTargets,!0),function(e,n,t){vi(e,t),n.forEach((({actor:n,materialIndex:r})=>{n.renderMesh&&(Yi(n,t),n.materials.forEach(((a,o)=>{o===r&&a.canRender&&(hi(e,n),il(n,{camera:t}),fi(e,n.geometry,a),e.stats&&ln(e.stats,"skybox pass",n.name,n.geometry))})))}))}(e,m.skyboxPass,t),function(e,n,t,r){vi(e,n),t.forEach((({actor:t,materialIndex:a})=>{if(t.type===s.Skybox){if(!t.renderMesh)return;Yi(t,n)}t.materials.forEach(((o,i)=>{i===a&&o.canRender&&(o.skipDepthPrePass&&(mi(e,null,!1,!1),gi(e),mi(e,e.gBufferRenderTargets,!1,!1)),hi(e,t),nr(o,S.DepthTexture,e.copyDepthDestRenderTarget.depthTexture),il(t,{camera:n,skybox:0!==r.length?r[0].actor:null}),fi(e,t.geometry,o),e.stats&&ln(e.stats,"scene pass",t.name,t.geometry))}))}))}(e,t,m.basePass,m.skyboxPass);const f=[];c.directionalLight&&c.directionalLight.castShadow&&f.push(c.directionalLight),c.spotLights.forEach((e=>{e.castShadow&&f.push(e)})),f.length>0&&function(e,n,t){n.forEach((n=>{if(!n.shadowMap)return;if(!n.shadowCamera)return;const r=Ti(t,n.shadowCamera).basePass.filter((({actor:e})=>e.castShadow));r.length<1||(mi(e,n.shadowMap,!1,!0),vi(e,n.shadowCamera),r.forEach((({actor:t,materialIndex:r})=>{var a,o;hi(e,t),a=t,o={camera:n.shadowCamera},a.depthMaterials.forEach((e=>Qi(e))),ll[a.meshType]?.(a,o),t.depthMaterials.forEach(((n,a)=>{n&&a===r&&n.canRender&&(nr(n,S.DepthTexture,e.copyDepthDestRenderTarget.depthTexture),fi(e,t.geometry,n),e.stats&&ln(e.stats,"shadow pass",t.name,t.geometry))}))})))}))}(e,f,u);const p=e.scenePostProcess.postProcessCamera;var d,g,h,v,x,T,C,M,P;e.screenSpaceShadowPass.enabled&&Mi({pass:e.screenSpaceShadowPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:null,isLastPass:!1,time:a}),e.ambientOcclusionPass.enabled&&Mi({pass:e.ambientOcclusionPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:null,isLastPass:!1,time:a}),u[i.Skybox].forEach((n=>{const t=n.actor;$r(e.deferredShadingPass.material,t)})),ui(e.deferredShadingPass.material,c,e.gpu.dummyTextureBlack),nr(e.deferredShadingPass.material,"uScreenSpaceShadowTexture",e.screenSpaceShadowPass.enabled?e.screenSpaceShadowPass.renderTarget.texture:e.gpu.dummyTextureBlack),nr(e.deferredShadingPass.material,"uAmbientOcclusionTexture",e.ambientOcclusionPass.enabled?e.ambientOcclusionPass.renderTarget.texture:e.gpu.dummyTexture),Mi({pass:e.deferredShadingPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:null,isLastPass:!1,time:a,lightActors:c}),e.ssrPass.enabled&&Mi({pass:e.ssrPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:e.deferredShadingPass.renderTarget,isLastPass:!1,time:a}),c.directionalLight&&e.lightShaftPass.enabled&&(d=e.lightShaftPass,g=c.directionalLight,d.directionalLight=g,Mi({pass:e.lightShaftPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:e.deferredShadingPass.renderTarget,isLastPass:!1,time:a})),c.spotLights.length>0&&(h=e.volumetricLightPass,v=c.spotLights,h.spotLights=v,Mi({pass:e.volumetricLightPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:e.deferredShadingPass.renderTarget,isLastPass:!1,time:a})),x=e.fogPass,T=e.lightShaftPass.enabled?Ua(e.lightShaftPass).texture:e.gpu.dummyTextureBlack,C=e.volumetricLightPass.renderTarget.texture,M=e.screenSpaceShadowPass.enabled?e.screenSpaceShadowPass.renderTarget.texture:e.gpu.dummyTextureBlack,P=r.get(4).texture,nr(x.material,Ba,T),nr(x.material,Ea,C),nr(x.material,Ia,M),nr(x.material,La,P),Mi({pass:e.fogPass,renderer:e,targetCamera:t,gpu:e.gpu,camera:p,prevRenderTarget:e.ssrPass.enabled?e.ssrPass.renderTarget:e.deferredShadingPass.renderTarget,isLastPass:!1,time:a});const w=e.fogPass.renderTarget.texture;Rr(e.afterDeferredShadingRenderTarget,w),Dr(e.afterDeferredShadingRenderTarget,e.depthPrePassRenderTarget.depthTexture),function(e,n){const t=e.renderTarget;mi(e,null,!1,!1),Rr(e.copySceneSourceRenderTarget,n),function(e,n,t,r,a){const o=e.gl;o.bindFramebuffer(ye,n.framebuffer.glObject),o.bindFramebuffer(Se,t.framebuffer.glObject),o.clear(I),o.blitFramebuffer(0,0,r,a,0,0,r,a,I,we.NEAREST),o.bindFramebuffer(ye,null),o.bindFramebuffer(Se,null)}(e.gpu,e.copySceneSourceRenderTarget,e.copySceneDestRenderTarget,e.realWidth,e.realHeight),mi(e,t)}(e,w),gi(e),u[i.Transparent].forEach((n=>{nr(sl(n.actor),S.DepthTexture,e.copyDepthDestRenderTarget.depthTexture)})),mi(e,e.afterDeferredShadingRenderTarget),function(e,n,t,r,a,o){vi(e,n),t.forEach((({actor:t,materialIndex:i})=>{t.materials.forEach(((l,s)=>{s===i&&(hi(e,t),ui(l,a,e.gpu.dummyTextureBlack),nr(l,S.SceneTexture,o),il(t,{camera:n,skybox:0!==r.length?r[0].actor:null}),fi(e,t.geometry,l),e.stats&&ln(e.stats,"transparent pass",t.name,t.geometry))}))}))}(e,t,u[i.Transparent],u[i.Skybox],c,e.copySceneDestRenderTarget.texture),l&&l(),Si(e.scenePostProcess);let R=e.afterDeferredShadingRenderTarget;const F=!t.renderTarget&&!Di(t);Ci(e.scenePostProcess),Pi(e.scenePostProcess,{gpu:e.gpu,renderer:e,prevRenderTarget:R,gBufferRenderTargets:e.gBufferRenderTargets,targetCamera:t,time:a,isCameraLastPass:F}),F||(R=function(e){let n=null;for(let t=e.passes.length-1;t>=0;t--)if(e.passes[t].enabled){n=e.passes[t];break}return null==n?null:Qo(n)}(e.scenePostProcess),Di(t)&&t.postProcess&&(Ci(t.postProcess),Pi(t.postProcess,{gpu:e.gpu,renderer:e,prevRenderTarget:R,gBufferRenderTargets:e.gBufferRenderTargets,targetCamera:t,time:a,isCameraLastPass:!t.renderTarget,lightActors:c})))}(os,rs,ls,is.sharedTextures,{time:e})}));const c=e=>{(function(e,n){((e,n)=>{const t=1/e.targetFPS;if(n-t>=e.lastTime){const r=n-e.lastTime,a=Math.floor(r/t);if(a>e.maxChaseCount)return e.lastTime+=t*a,void e.callback(e.lastTime,t);const o=Math.min(e.maxChaseCount,a);for(let n=0;n<o;n++)e.lastTime+=t,e.callback(e.lastTime,t)}})(e.fixedUpdateFrameTimer,n/1e3),((e,n)=>{const t=1/e.targetFPS;if(n-t>=e.lastTime){const r=n-e.lastTime,a=t*Math.floor(r/t);e.lastTime+=a,e.callback(e.lastTime,a)}})(e.updateFrameTimer,n/1e3)})(is,e),requestAnimationFrame(c)};!function(e){e.onBeforeStart&&e.onBeforeStart();const n=performance.now()/1e3;var t;t=n,e.fixedUpdateFrameTimer.lastTime=t,((e,n)=>{e.lastTime=n})(e.updateFrameTimer,n),e.onAfterStart&&e.onAfterStart()}(is),requestAnimationFrame(c)})();
