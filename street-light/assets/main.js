!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();class e{constructor(e,t,n){this.elements=new Float32Array(3),this.set(e,t,n)}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}get magnitude(){return Math.max(1e-4,Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z))}set(e,t,n){return this.elements=new Float32Array([e,t,n]),this}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}normalize(){const e=this.magnitude;return this.x=this.x/e,this.y=this.y/e,this.z=this.z/e,this}add(e){return this.x+=e,this.y+=e,this.z+=e,this}addVector(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}sub(e){return this.x-=e,this.y-=e,this.z-=e,this}subVector(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}scale(e){return this.x*=e,this.y*=e,this.z*=e,this}scaleVector(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}clone(){return new e(this.x,this.y,this.z)}multiplyMatrix4(e){const t=this.x,n=this.y,r=this.z,a=e.m00*t+e.m01*n+e.m02*r+1*e.m03,i=e.m10*t+e.m11*n+e.m12*r+1*e.m13,o=e.m20*t+e.m21*n+e.m22*r+1*e.m23;return this.x=a,this.y=i,this.z=o,this}static multiplyVectors(t,n){return new e(t.x*n.x,t.y*n.y,t.z*n.z)}equals(e){const t=1e-7;return Math.abs(this.x-e.x)<t&&Math.abs(this.y-e.y)<t&&Math.abs(this.z-e.z)<t}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}static dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static get zero(){return new e(0,0,0)}static get one(){return new e(1,1,1)}static get up(){return new e(0,1,0)}static get down(){return new e(0,-1,0)}static get back(){return new e(0,0,-1)}static get forward(){return new e(0,0,1)}static get right(){return new e(1,0,0)}static get left(){return new e(-1,0,0)}static fromArray(t){return new e(t[0],t[1],t[2])}static addVectors(...t){const n=e.zero;return t.forEach((e=>{n.x+=e.x,n.y+=e.y,n.z+=e.z})),n}static subVectors(t,n){return new e(t.x-n.x,t.y-n.y,t.z-n.z)}static crossVectors(t,n){return new e(t.y*n.z-t.z*n.y,t.z*n.x-t.x*n.z,t.x*n.y-t.y*n.x)}static rotateVectorX(t,n){const r=t.x,a=t.y,i=t.z,o=n/180*Math.PI,s=Math.cos(o),l=Math.sin(o);return new e(r,a*s+i*-l,a*l+i*s)}static rotateVectorY(t,n){const r=t.x,a=t.y,i=t.z,o=n/180*Math.PI,s=Math.cos(o),l=Math.sin(o);return new e(r*s+i*l,a,r*-l+i*s)}static rotateVectorZ(t,n){const r=t.x,a=t.y,i=t.z,o=n/180*Math.PI,s=Math.cos(o),l=Math.sin(o);return new e(r*s+a*-l,r*l+a*l,i)}static getTangent(t){return t.equals(e.up)||t.equals(e.down)?e.right:e.crossVectors(t,e.down)}static getBinormalFromTangent(t,n){return e.crossVectors(t,n.clone().negate())}static fill(t){return new e(t,t,t)}static lerpVectors(t,n,r){return new e(t.x+(n.x-t.x)*r,t.y+(n.y-t.y)*r,t.z+(n.z-t.z)*r)}log(){}}class t{constructor(e,t,n,r,a,i,o,s,l,u,c,h,f,m,d,p){this.elements=new Float32Array(16),this.set(e,t,n,r,a,i,o,s,l,u,c,h,f,m,d,p)}get m00(){return this.elements[0]}get m01(){return this.elements[4]}get m02(){return this.elements[8]}get m03(){return this.elements[12]}get m10(){return this.elements[1]}get m11(){return this.elements[5]}get m12(){return this.elements[9]}get m13(){return this.elements[13]}get m20(){return this.elements[2]}get m21(){return this.elements[6]}get m22(){return this.elements[10]}get m23(){return this.elements[14]}get m30(){return this.elements[3]}get m31(){return this.elements[7]}get m32(){return this.elements[11]}get m33(){return this.elements[15]}set m00(e){this.elements[0]=e}set m01(e){this.elements[4]=e}set m02(e){this.elements[8]=e}set m03(e){this.elements[12]=e}set m10(e){this.elements[1]=e}set m11(e){this.elements[5]=e}set m12(e){this.elements[9]=e}set m13(e){this.elements[13]=e}set m20(e){this.elements[2]=e}set m21(e){this.elements[6]=e}set m22(e){this.elements[10]=e}set m23(e){this.elements[14]=e}set m30(e){this.elements[3]=e}set m31(e){this.elements[7]=e}set m32(e){this.elements[11]=e}set m33(e){this.elements[15]=e}get position(){return new e(this.m03,this.m13,this.m23)}set(e,t,n,r,a,i,o,s,l,u,c,h,f,m,d,p){return this.elements=new Float32Array([e,a,l,f,t,i,u,m,n,o,c,d,r,s,h,p]),this}static get identity(){return new t(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}setTranslation(e){return this.m03=e.x,this.m13=e.y,this.m23=e.z,this}static translationMatrix(e){return new t(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1)}static scalingMatrix(e){return new t(e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1)}static rotationXMatrix(e){const n=Math.cos(e),r=Math.sin(e);return new t(1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1)}static rotationYMatrix(e){const n=Math.cos(e),r=Math.sin(e);return new t(n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1)}static rotationZMatrix(e){const n=Math.cos(e),r=Math.sin(e);return new t(n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1)}static multiplyMatrices(...e){const n=t.identity;return e.forEach((e=>n.multiply(e))),n}multiply(e){const n=this.elements,r=e.elements,a=n[0],i=n[4],o=n[8],s=n[12],l=n[1],u=n[5],c=n[9],h=n[13],f=n[2],m=n[6],d=n[10],p=n[14],g=n[3],v=n[7],x=n[11],T=n[15],w=r[0],b=r[4],P=r[8],y=r[12],S=r[1],C=r[5],D=r[9],B=r[13],M=r[2],E=r[6],R=r[10],A=r[14],F=r[3],V=r[7],L=r[11],_=r[15],I=new t(a*w+i*S+o*M+s*F,a*b+i*C+o*E+s*V,a*P+i*D+o*R+s*L,a*y+i*B+o*A+s*_,l*w+u*S+c*M+h*F,l*b+u*C+c*E+h*V,l*P+u*D+c*R+h*L,l*y+u*B+c*A+h*_,f*w+m*S+d*M+p*F,f*b+m*C+d*E+p*V,f*P+m*D+d*R+p*L,f*y+m*B+d*A+p*_,g*w+v*S+x*M+T*F,g*b+v*C+x*E+T*V,g*P+v*D+x*R+T*L,g*y+v*B+x*A+T*_);return this.copy(I),this}copy(e){return this.m00=e.m00,this.m01=e.m01,this.m02=e.m02,this.m03=e.m03,this.m10=e.m10,this.m11=e.m11,this.m12=e.m12,this.m13=e.m13,this.m20=e.m20,this.m21=e.m21,this.m22=e.m22,this.m23=e.m23,this.m30=e.m30,this.m31=e.m31,this.m32=e.m32,this.m33=e.m33,this}clone(){const e=t.identity;return e.m00=this.m00,e.m01=this.m01,e.m02=this.m02,e.m03=this.m03,e.m10=this.m10,e.m11=this.m11,e.m12=this.m12,e.m13=this.m13,e.m20=this.m20,e.m21=this.m21,e.m22=this.m22,e.m23=this.m23,e.m30=this.m30,e.m31=this.m31,e.m32=this.m32,e.m33=this.m33,e}transpose(){const e=this.m01,t=this.m10;this.m01=t,this.m10=e;const n=this.m02,r=this.m20;this.m02=r,this.m20=n;const a=this.m03,i=this.m30;this.m03=i,this.m30=a;const o=this.m12,s=this.m21;this.m12=s,this.m21=o;const l=this.m13,u=this.m31;this.m13=u,this.m31=l;const c=this.m23,h=this.m32;return this.m23=h,this.m32=c,this}invert(){const e=this.elements,n=e[0],r=e[1],a=e[2],i=e[3],o=e[4],s=e[5],l=e[6],u=e[7],c=e[8],h=e[9],f=e[10],m=e[11],d=e[12],p=e[13],g=e[14],v=e[15],x=h*g*u-p*f*u+p*l*m-s*g*m-h*l*v+s*f*v,T=d*f*u-c*g*u-d*l*m+o*g*m+c*l*v-o*f*v,w=c*p*u-d*h*u+d*s*m-o*p*m-c*s*v+o*h*v,b=d*h*l-c*p*l-d*s*f+o*p*f+c*s*g-o*h*g,P=n*x+r*T+a*w+i*b;if(0===P)return new t(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const y=1/P;return e[0]=x*y,e[1]=(p*f*i-h*g*i-p*a*m+r*g*m+h*a*v-r*f*v)*y,e[2]=(s*g*i-p*l*i+p*a*u-r*g*u-s*a*v+r*l*v)*y,e[3]=(h*l*i-s*f*i-h*a*u+r*f*u+s*a*m-r*l*m)*y,e[4]=T*y,e[5]=(c*g*i-d*f*i+d*a*m-n*g*m-c*a*v+n*f*v)*y,e[6]=(d*l*i-o*g*i-d*a*u+n*g*u+o*a*v-n*l*v)*y,e[7]=(o*f*i-c*l*i+c*a*u-n*f*u-o*a*m+n*l*m)*y,e[8]=w*y,e[9]=(d*h*i-c*p*i-d*r*m+n*p*m+c*r*v-n*h*v)*y,e[10]=(o*p*i-d*s*i+d*r*u-n*p*u-o*r*v+n*s*v)*y,e[11]=(c*s*i-o*h*i-c*r*u+n*h*u+o*r*m-n*s*m)*y,e[12]=b*y,e[13]=(c*p*a-d*h*a+d*r*f-n*p*f-c*r*g+n*h*g)*y,e[14]=(d*s*a-o*p*a-d*r*l+n*p*l+o*r*g-n*s*g)*y,e[15]=(o*h*a-c*s*a+c*r*l-n*h*l-o*r*f+n*s*f)*y,this}static getOrthographicMatrix(e,n,r,a,i,o){return new t(2/(n-e),0,0,-(n+e)/(n-e),0,2/(a-r),0,-(a+r)/(a-r),0,0,-2/(o-i),-(o+i)/(o-i),0,0,0,1)}static getPerspectiveMatrix(e,n,r,a){const i=1/Math.tan(e/2),o=t.identity;if(o.m00=i/n,o.m10=0,o.m20=0,o.m30=0,o.m01=0,o.m11=i,o.m21=0,o.m31=0,o.m02=0,o.m12=0,o.m32=-1,o.m03=0,o.m13=0,o.m33=0,null!=a&&a!==1/0){const e=1/(r-a);o.m22=(a+r)*e,o.m23=2*a*r*e}else o.m22=-1,o.m23=-2*r;return o}static getLookAtMatrix(n,r,a=new e(0,1,0),i=!1){const o=i?e.subVectors(n,r).normalize():e.subVectors(r,n).normalize(),s=e.crossVectors(a.normalize(),o).normalize(),l=e.crossVectors(o,s);return new t(s.x,l.x,o.x,n.x,s.y,l.y,o.y,n.y,s.z,l.z,o.z,n.z,0,0,0,1)}static fromTRS(e,n,r){const a=n.getAxesRadians();return t.multiplyMatrices(t.translationMatrix(e),t.rotationYMatrix(a.y),t.rotationXMatrix(a.x),t.rotationZMatrix(a.z),t.scalingMatrix(r))}static fromQuaternion(e){const n=e.toEulerRadian();return t.multiplyMatrices(t.rotationYMatrix(n.y),t.rotationXMatrix(n.x),t.rotationZMatrix(n.z))}static fromArray(e){return new t(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}log(){}getPrettyLine(){return`--------------------\n${this.m00}, ${this.m01}, ${this.m02}, ${this.m03},\n${this.m10}, ${this.m11}, ${this.m12}, ${this.m13},\n${this.m20}, ${this.m21}, ${this.m22}, ${this.m23},\n${this.m30}, ${this.m31}, ${this.m32}, ${this.m33},\n--------------------`}}const n=0,r=1,a=4,i=1,o=2,s=3,l=0,u=1,c=0,h=1,f=2,m="s",d="o",p="a",g="t",v={[m]:0,[d]:1,[p]:2,[g]:3},x=0,T=0,w=1,b=0,P=1,y=2,S=3,C=4,D=5,B=0,M=1,E=0,R=1,A=2,F=3,V=4,L=5,_=0,I=1,N=2,U=0,O=1,z=2,k=3,j=4,G=5,H={Repeat:0,ClampToEdge:1,MirroredRepeat:2},W={Nearest:0,Linear:1,NearestMipmapNearest:2,NearestMipmapLinear:3,LinearMipmapNearest:4,LinearMipmapLinear:5},X=1,$=0,Y=1,q=2,J=3,K=4,Z=5,Q=0,ee=1,te=0,ne=1,re=2,ae={Position:"aPosition",Color:"aColor",Uv:"aUv",Normal:"aNormal",Tangent:"aTangent",Binormal:"aBinormal",BoneIndices:"aBoneIndices",BoneWeights:"aBoneWeighs",InstancePosition:"aInstancePosition",InstanceScale:"aInstanceScale",InstanceRotation:"aInstanceRotation",InstanceAnimationOffset:"aInstanceAnimationOffset",InstanceVertexColor:"aInstanceVertexColor",InstanceVelocity:"aInstanceVelocity"},ie=0,oe=1,se=2,le=3,ue=4,ce=5,he=6,fe=7,me=8,de=9,pe=10,ge=11,ve=12,xe=13,Te=14,we=15,be=16,Pe=17,ye="uWorldMatrix",Se="uViewMatrix",Ce="uProjectionMatrix",De="uViewProjectionMatrix",Be="uNormalMatrix",Me="uInverseWorldMatrix",Ee="uInverseViewMatrix",Re="uInverseViewProjectionMatrix",Ae="uInverseProjectionMatrix",Fe="uTransposeInverseViewMatrix",Ve="uViewPosition",Le="uViewDirection",_e="uAspect",Ie="uFov",Ne="uGBufferATexture",Ue="uGBufferBTexture",Oe="uGBufferCTexture",ze="uGBufferDTexture",ke="uShadingModelId",je="uDepthTexture",Ge="uMetallic",He="uRoughness",We="uJointTexture",Xe="uBoneCount",$e="uJointTextureColNum",Ye="uTotalFrameCount",qe="uSrcTexture",Je="uTime",Ke="uViewport",Ze="uTargetWidth",Qe="uTargetHeight",et="uAspect",tt="uTexelSize",nt="uNearClip",rt="uFarClip",at="uCubeTexture",it="uDirectionalLight",ot="uSpotLight",st="direction",lt="intensity",ut="color",ct="shadowMapProjectionMatrix",ht="uDirectionalLightShadowMap",ft="uSpotLightShadowMap",mt="position",dt="distance",pt="attenuation",gt="coneCos",vt="penumbraCos",xt="uSkybox",Tt="uRotationOffset",wt="ubCommon",bt="ubTransformations",Pt="ubCamera",yt="ubDirectionalLight",St="ubSpotLight",Ct={BEGIN_MAIN:"BEGIN_MAIN",END_MAIN:"END_MAIN",APPEND_ATTRIBUTES:"APPEND_ATTRIBUTES",APPEND_UNIFORMS:"APPEND_UNIFORMS"},Dt={LOCAL_POSITION_POST_PROCESS:"LOCAL_POSITION_POST_PROCESS",INSTANCE_TRANSFORM_PRE_PROCESS:"INSTANCE_TRANSFORM_PRE_PROCESS",WORLD_POSITION_POST_PROCESS:"WORLD_POSITION_POST_PROCESS",VIEW_POSITION_POST_PROCESS:"VIEW_POSITION_POST_PROCESS",OUT_CLIP_POSITION_PRE_PROCESS:"OUT_CLIP_POSITION_PRE_PROCESS",...Ct},Bt={...Ct},Mt={DEPTH_FUNCTIONS:"DEPTH_FUNCTIONS",ENGINE_UNIFORMS:"ENGINE_UNIFORMS",TRANSFORM_VERTEX_UNIFORMS:"TRANSFORM_VERTEX_UNIFORMS",CAMERA_UNIFORMS:"CAMERA_UNIFORMS",PSEUDO_HDR:"PSEUDO_HDR"},Et={DEFINES:"DEFINES",ATTRIBUTES:"ATTRIBUTES",...Ct,...Mt},Rt=36064,At=36053,Ft="EXT_color_buffer_float",Vt={NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_NEAREST:9985,LINEAR_MIPMAP_LINEAR:9987};class Lt{constructor(e,t,n){this.elements=new Float32Array(3),this.rawMatrix=null,this.set(e,t,n)}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}get roll(){return this.elements[2]}get pitch(){return this.elements[0]}get yaw(){return this.elements[1]}getAxes(){return{x:this.elements[0],y:this.elements[1],z:this.elements[2]}}getAxesRadians(){return{x:this.elements[0]*Math.PI/180,y:this.elements[1]*Math.PI/180,z:this.elements[2]*Math.PI/180}}set(e,t,n){return this.elements=new Float32Array([e,t,n]),this}setV(e){return this.elements=new Float32Array([e.x,e.y,e.z]),this}copy(e){return this.set(e.x,e.y,e.z),this}setRadian(e,t,n){const r=Lt.fromRadian(e,t,n);return this.copy(r)}static get zero(){return new Lt(0,0,0)}static fromRadian(e,t,n){return Lt.zero.set(180*e/Math.PI,180*t/Math.PI,180*n/Math.PI)}static fromQuaternion(e){const t=e.toEulerDegree();return new Lt(t.x,t.y,t.z)}static fromMatrix4(e){const t=new Lt(0,0,0);return t.rawMatrix=e,t}setRotationX(e){this.elements[0]=e}setRotationY(e){this.elements[1]=e}setRotationZ(e){this.elements[2]=e}}class _t{constructor(n){this.parent=null,this.children=[],this.#e=t.identity,this.#t=t.identity,this.#n=t.identity,this.position=e.zero,this.rotation=Lt.zero,this.scale=e.one,this.lookAtTarget=null,this.#r=t.identity,this.actor=n}#e;#t;#n;#r;get childCount(){return this.children.length}get hasChild(){return this.childCount>0}get inverseWorldMatrix(){return this.#e}get worldMatrix(){return this.#t}get normalMatrix(){return this.#r}get localMatrix(){return this.#n}get worldPosition(){return this.#t.position}get worldRight(){return new e(this.#t.m00,this.#t.m10,this.#t.m20).normalize()}get worldUp(){return new e(this.#t.m01,this.#t.m11,this.#t.m21).normalize()}get worldForward(){return new e(this.#t.m02,this.#t.m12,this.#t.m22).normalize()}addChild(e){this.children.push(e)}updateMatrix(){if(this.lookAtTarget){const n=this.actor.type===D?t.getLookAtMatrix(this.position,this.lookAtTarget,e.up,!0):t.getLookAtMatrix(this.position,this.lookAtTarget),r=t.scalingMatrix(this.scale);this.#n=t.multiplyMatrices(n,r)}else{const e=t.translationMatrix(this.position),n=this.rotation.getAxes(),r=t.rotationXMatrix(n.x/180*Math.PI),a=t.rotationYMatrix(n.y/180*Math.PI),i=t.rotationZMatrix(n.z/180*Math.PI),o=t.multiplyMatrices(a,r,i),s=t.scalingMatrix(this.scale);this.#n=t.multiplyMatrices(e,o,s)}this.#t=this.parent?t.multiplyMatrices(this.parent.worldMatrix,this.#n):this.#n,this.#e=this.#t.clone().invert(),this.#r=this.#t.clone().invert().transpose()}setScaling(e){this.scale=e}setRotationX(e){this.rotation.setRotationX(e)}setRotationY(e){this.rotation.setRotationY(e)}setRotationZ(e){this.rotation.setRotationZ(e)}setTranslation(e){this.position=e}lookAt(e){this.lookAtTarget=e}}class It{constructor(e=[]){this.playingAnimationClip=null,this._animationClips=e}get animationClips(){return this._animationClips}setAnimationClips(e){this._animationClips=e}play(e,t=!1){const n=this._animationClips.find((t=>e===t.name));n&&(n.play(),n.loop=t,this.playingAnimationClip=n)}update(e){this.playingAnimationClip&&(this.playingAnimationClip.loop=!0,this.playingAnimationClip.update(e))}}class Nt{constructor({name:e="",type:t=b}={}){this.isStarted=!1,this._onStart=[],this._onFixedUpdate=null,this._onUpdate=null,this._enabled=!0,this.name=e,this.transform=new _t(this),this.type=t||b,this.uuid=([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))),this.animator=new It}set enabled(e){this._enabled=e}get enabled(){return this._enabled}subscribeOnStart(e){this._onStart.push(e)}set onFixedUpdate(e){this._onFixedUpdate=e}set onUpdate(e){this._onUpdate=e}addChild(e){this.transform.addChild(e),e.transform.parent=this.transform}setSize(e,t){}#a({gpu:e}){this.isStarted||(this.isStarted=!0,this.start({gpu:e}))}updateTransform(e){this.transform.updateMatrix()}start({gpu:e}){this._onStart.forEach((t=>{t({actor:this,gpu:e})}))}fixedUpdate({gpu:e,fixedTime:t,fixedDeltaTime:n}){this.#a({gpu:e}),this.animator&&this.animator.update(n),this._onFixedUpdate&&this._onFixedUpdate({actor:this,gpu:e,fixedTime:t,fixedDeltaTime:n})}update({gpu:e,time:t,deltaTime:n}){this.#a({gpu:e}),this._onUpdate&&this._onUpdate({actor:this,gpu:e,time:t,deltaTime:n})}beforeRender({gpu:e}){}}class Ut{constructor(e=0,t=0,n=0,r=1){this.elements=new Float32Array(4),this.set(e,t,n,r)}get r(){return this.elements[0]}get g(){return this.elements[1]}get b(){return this.elements[2]}get a(){return this.elements[3]}get r255(){return 255*this.elements[0]}get g255(){return 255*this.elements[1]}get b255(){return 255*this.elements[2]}get a255(){return 255*this.elements[3]}get rgbArray(){return[this.r,this.g,this.b]}set r(e){this.elements[0]=e}set g(e){this.elements[1]=e}set b(e){this.elements[2]=e}set a(e){this.elements[3]=e}set(e,t,n,r){this.elements=new Float32Array([e,t,n,r])}multiplyScalar(e,t=!1){return this.elements[0]*=e,this.elements[1]*=e,this.elements[2]*=e,t&&(this.elements[3]*=e),this}getRGB(){return{r:this.r255,g:this.g255,b:this.b255}}getHexCoord(e=!0){const t=this.getRGB(),n=t.r.toString(16).padStart(2,"0"),r=t.g.toString(16).padStart(2,"0"),a=t.b.toString(16).padStart(2,"0");return e?`#${n}${r}${a}`:`${n}${r}${a}`}static get white(){return new Ut(1,1,1,1)}static get black(){return new Ut(0,0,0,1)}static get green(){return new Ut(0,0,1,1)}static fromRGB(e,t,n,r=255){return new Ut(e/255,t/255,n/255,r/255)}static fromArray(e){return new Ut(e[0],e[1],e[2],e[3]?e[3]:1)}static fromHex(e){const t="#"===e.slice(0,1)?e.slice(1):e,n=t.slice(0,2),r=t.slice(2,4),a=t.slice(4,6);return new Ut(Number.parseInt(n,16)/255,Number.parseInt(r,16)/255,Number.parseInt(a,16)/255,1)}}class Ot extends Nt{constructor({name:e,intensity:n,color:r,lightType:a}){super({name:e,type:S}),this.intensity=1,this.color=Ut.white,this.castShadow=!1,this.shadowCamera=null,this.shadowMap=null,this.lightViewProjectionMatrix=t.identity,this.shadowMapProjectionMatrix=t.identity,this.intensity=n,this.color=r,this.lightType=a}setSize(e,t){super.setSize(e,t)}setShadowSize(){throw"should implementation"}updateShadowCamera(){if(!this.shadowCamera)return;const e=new t(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);this.lightViewProjectionMatrix=t.multiplyMatrices(this.shadowCamera.projectionMatrix.clone(),this.shadowCamera.viewMatrix.clone()),this.shadowMapProjectionMatrix=t.multiplyMatrices(e,this.lightViewProjectionMatrix.clone())}}class zt{constructor(e,t,n,r){this.elements=new Float32Array(4),this.set(e,t,n,r)}static get one(){return new zt(1,1,1,1)}static get zero(){return new zt(0,0,0,0)}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}get w(){return this.elements[3]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set z(e){this.elements[2]=e}set w(e){this.elements[3]=e}set(e,t,n,r){this.elements=new Float32Array([e,t,n,r])}multiplyMatrix4(e){const t=this.x,n=this.y,r=this.z,a=this.w,i=e.m00*t+e.m01*n+e.m02*r+e.m03*a,o=e.m10*t+e.m11*n+e.m12*r+e.m13*a,s=e.m20*t+e.m21*n+e.m22*r+e.m23*a,l=e.m30*t+e.m31*n+e.m32*r+e.m33*a;return this.x=i,this.y=o,this.z=s,this.w=l,this}}class kt{get glObject(){throw"[GLObject.glObject] should implementation"}bind(){throw"[GLObject.bind] should implementation"}unbind(){throw"[GLObject.unbind] should implementation"}dispose(){throw"[GLObject.dispose] should implementation"}}function jt(e,t,n){const r=e.createShader(t);if(!r)throw new Error("invalid shader");e.shaderSource(r,n),e.compileShader(r);const a=e.getShaderInfoLog(r);if(a&&a.length>0)throw Gt.buildErrorInfo(a,n,"[Shader] shader has error");return r}class Gt extends kt{constructor({gpu:e,vertexShader:t,fragmentShader:n,transformFeedbackVaryings:r}){super(),this.gpu=e;const{gl:a}=e,i=a.createProgram();if(!i)throw new Error("invalid program");const o=jt(a,a.VERTEX_SHADER,t);a.attachShader(i,o);const s=jt(a,a.FRAGMENT_SHADER,n);a.attachShader(i,s),r&&r.length>0&&a.transformFeedbackVaryings(i,r,a.SEPARATE_ATTRIBS),a.linkProgram(i);const l=a.getProgramInfoLog(i);if(l&&l.length>0)throw l;this.program=i}get glObject(){return this.program}dispose(){this.gpu.gl.deleteShader(this.program),this.program=null}static buildErrorInfo(e,t,n){return`${n}\n            \n---\n\n${e}\n\n---\n            \n${t.split("\n").map(((e,t)=>`${t+1}: ${e}`)).join("\n")}       \n`}}const Ht={[Mt.DEPTH_FUNCTIONS]:"float viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}",[Mt.ENGINE_UNIFORMS]:"layout (std140) uniform ubCommon {\n    float uTime;\n    vec4 uViewport;\n};",[Mt.TRANSFORM_VERTEX_UNIFORMS]:"layout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};",[Mt.CAMERA_UNIFORMS]:"layout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};",[Mt.PSEUDO_HDR]:"vec4 encodePseudoHDR(vec3 color) {\n    float base = .25;\n    float l = max(max(color.r, color.g), max(color.b, base));\n    return vec4(\n        color.r / l,\n        color.g / l,\n        color.b / l,\n        base / l\n    );\n}\n\nvec4 decodePseudoHDR(vec4 encodedColor) {\n    float base = .25;\n    float rl = encodedColor.a;\n    return vec4(\n        (encodedColor.r / rl) * base,\n        (encodedColor.g / rl) * base,\n        (encodedColor.b / rl) * base,\n        rl * base\n    );\n}"},Wt=({receiveShadow:e,isSkinning:t,gpuSkinning:n,useNormalMap:r,useEnvMap:a,useVertexColor:i,useAlphaTest:o,isInstancing:s,useInstanceLookDirection:l})=>{const u=[];return e&&u.push("#define USE_RECEIVE_SHADOW"),t&&(n?u.push("#define USE_SKINNING_GPU"):u.push("#define USE_SKINNING_CPU")),r&&u.push("#define USE_NORMAL_MAP"),a&&u.push("#define USE_ENV_MAP"),i&&u.push("#define USE_VERTEX_COLOR"),o&&u.push("#define USE_ALPHA_TEST"),s&&u.push("#define USE_INSTANCING"),l&&u.push("#define USE_INSTANCE_LOOK_DIRECTION"),u},Xt=(e,t,n,r)=>{let a=e;return a=a.replaceAll(new RegExp(`#pragma ${Et.DEFINES}`,"g"),(()=>Wt(n).join("\n"))),a=a.replaceAll(new RegExp(`#pragma ${Et.ATTRIBUTES}`,"g"),(()=>{const e=(e=>[...e].sort(((e,t)=>e.location-t.location)).map((({location:e,size:t,name:n,dataType:r})=>{let a;switch(r){case Float32Array:switch(t){case 1:a="float";break;case 2:a="vec2";break;case 3:a="vec3";break;case 4:a="vec4";break;default:throw"[buildVertexAttributeLayouts] invalid attribute float"}break;case Uint16Array:switch(t){case 1:a="uint";break;case 2:a="uvec2";break;case 3:a="uvec3";break;case 4:a="uvec4";break;default:throw"[buildVertexAttributeLayouts] invalid attribute int"}break;default:throw"[buildVertexAttributeLayouts] invalid attribute data type"}return`layout(location = ${e}) in ${a} ${n};`})))(t);return e.join("\n")})),Object.values(Dt).forEach((e=>{const t=e;a=a.replaceAll(new RegExp(`#pragma ${t}`,"g"),(()=>r[t]&&r[t]||""))})),Object.values(Mt).forEach((e=>{const t=e;a=a.replaceAll(new RegExp(`#pragma ${t}`,"g"),(()=>Ht[t]))})),a};class $t{constructor(...e){this.uniformBlocks=[],this.data=[];for(let t=0;t<e.length;t++)for(let n=0;n<e[t].length;n++){const r=e[t][n],a=this.data.findIndex((e=>e.name===r.name));a<0?this.data.push(r):this.data[a].value=r.value}}find(e){return this.data.find((t=>t.name===e))}addValue(e,t,n){this.data.push({name:e,type:t,value:n})}setValue(e,t,n=!1){const r=this.find(e);r&&(r.type===de?t.forEach((e=>{const t=r.value.findIndex((t=>t.name===e.name));t>=0&&(r.value[t].value=e.value)})):r.type===pe?t.forEach(((e,t)=>{e.forEach((e=>{const n=r.value[t].findIndex((t=>t.name===e.name));n>=0&&(r.value[t][n].value=e.value)}))})):r.value=t)}setValues(){}addUniformBlock(e,t,n){this.uniformBlocks.push({blockIndex:e,uniformBufferObject:t,data:n})}}const Yt=0;class qt{constructor({name:e="",type:n=Yt,vertexShader:r="",fragmentShader:i="",depthFragmentShader:o,rawVertexShader:s,rawFragmentShader:u,vertexShaderGenerator:m,fragmentShaderGenerator:p,depthFragmentShaderGenerator:x,vertexShaderModifier:T,fragmentShaderModifier:w,primitiveType:b,depthTest:P=!0,depthWrite:y=!0,skipDepthPrePass:S=!1,depthFuncType:C=l,alphaTest:D=null,faceSide:B=_,receiveShadow:M=!1,blendType:E=c,renderQueue:R,useNormalMap:A=null,isSkinning:F=null,gpuSkinning:V=null,jointNum:L=null,isInstancing:I=!1,useInstanceLookDirection:N=!1,useVertexColor:U=!1,useEnvMap:O=!1,queue:z,uniforms:k=[],uniformBlockNames:j=[],depthUniforms:G=[],showLog:H=!1}){if(this.name="",this.type=Yt,this.shader=null,this.uniformBlockNames=[],this.isAddedUniformBlock=!1,this.depthFragmentShader=null,this.rawVertexShader=null,this.rawFragmentShader=null,this.rawDepthFragmentShader=null,this.vertexShaderGenerator=null,this.fragmentShaderGenerator=null,this.depthFragmentShaderGenerator=null,this._vertexShaderModifier={},this._fragmentShaderModifier={},this.boundUniformBufferObjects=!1,this.name=e||"",this.type=n,this.vertexShader=r||"",this.fragmentShader=i||"",o&&(this.depthFragmentShader=o),s&&(this.rawVertexShader=s),u&&(this.rawFragmentShader=u),m&&(this.vertexShaderGenerator=m),p&&(this.fragmentShaderGenerator=p),x&&(this.depthFragmentShaderGenerator=x),T&&(this._vertexShaderModifier=T),w&&(this._fragmentShaderModifier=w),this.primitiveType=b||a,this.blendType=E||c,this.depthTest=!!P,this.depthWrite=!!y,this.depthFuncType=C,this.skipDepthPrePass=!!S,this.alphaTest="number"==typeof D?D:null,this.faceSide=B||_,this.receiveShadow=!!M,R)this.renderQueue=R;else switch(this.blendType){case c:this.renderQueue=v[d];break;case h:case f:this.renderQueue=v[g]}this.renderQueue,this.isSkinning=!!F,this.gpuSkinning=!!V,this.jointNum="number"==typeof L?L:null,this.isInstancing=!!I,this.useInstanceLookDirection=!!N,this.useVertexColor=!!U,this.useNormalMap=!!A,this.useEnvMap=!!O;const W=[{name:Me,type:ie,value:t.identity},{name:Je,type:ge,value:0},...this.alphaTest?[{name:"uAlphaTestThreshold",type:ge,value:this.alphaTest}]:[]],X=(this.receiveShadow,[]);this.queue=z||null,this.uniforms=new $t(W,X,k),this.depthUniforms=new $t(W,G),this.uniformBlockNames=j,this.showLog=H}get isCompiledShader(){return!!this.shader}get vertexShaderModifier(){return this._vertexShaderModifier}get fragmentShaderModifier(){return this._fragmentShaderModifier}get useAlphaTest(){return null!==this.alphaTest}start({gpu:e,attributeDescriptors:t}){!this.depthFragmentShader&&this.depthFragmentShaderGenerator&&(this.depthFragmentShader=this.depthFragmentShaderGenerator());const n={receiveShadow:!!this.receiveShadow,isSkinning:!!this.isSkinning,gpuSkinning:!!this.gpuSkinning,useNormalMap:!!this.useNormalMap,useEnvMap:!!this.useEnvMap,useReceiveShadow:!!this.receiveShadow,useVertexColor:!!this.useVertexColor,isInstancing:!!this.isInstancing,useAlphaTest:!!this.alphaTest,useInstanceLookDirection:!!this.useInstanceLookDirection};if(!this.rawVertexShader){!this.vertexShader&&this.vertexShaderGenerator&&(this.vertexShader=this.vertexShaderGenerator({attributeDescriptors:t,isSkinning:!!this.isSkinning,jointNum:this.jointNum,gpuSkinning:this.gpuSkinning,isInstancing:this.isInstancing,useInstanceLookDirection:this.useInstanceLookDirection}));const e=Xt(this.vertexShader,t,n,this.vertexShaderModifier);this.rawVertexShader=e}if(!this.rawFragmentShader){!this.fragmentShader&&this.fragmentShaderGenerator&&(this.fragmentShader=this.fragmentShaderGenerator({attributeDescriptors:t}));const e=((e,t,n)=>{let r=e;return r=r.replaceAll(new RegExp(`#pragma ${Et.DEFINES}`,"g"),(()=>Wt(t).join("\n"))),Object.values(Bt).forEach((e=>{const t=e;r=r.replaceAll(new RegExp(`#pragma ${t}`,"g"),(()=>n[t]&&n[t]||""))})),Object.values(Mt).forEach((e=>{const t=e;r=r.replaceAll(new RegExp(`#pragma ${t}`,"g"),(()=>Ht[t]))})),r})(this.fragmentShader,n,this.fragmentShaderModifier);this.rawFragmentShader=e}this.showLog,this.shader=new Gt({gpu:e,vertexShader:this.rawVertexShader,fragmentShader:this.rawFragmentShader})}updateUniforms(){}}class Jt{constructor({name:e,data:t,location:n,size:r,offset:a=0,usageType:i=te,divisor:o=0}){this.name=e,this.data=t,this.location=n||0,this.size=r,this.offset=a||0,this.usageType=i||te,this.divisor=o||0}getDescriptor(){return{name:this.name,location:this.location,size:this.size,dataType:this.data.constructor}}}class Kt extends kt{constructor({gpu:e,indices:t}){super(),this.gpu=e;const n=this.gpu.gl;this.ibo=n.createBuffer(),this.bind(),n.bufferData(n.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),n.STATIC_DRAW)}get glObject(){return this.ibo}bind(){const e=this.gpu.gl;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.ibo)}unbind(){const e=this.gpu.gl;e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)}}function Zt(e){switch(e){case Vt.NEAREST:return W.Nearest;case Vt.LINEAR:return W.Linear;case Vt.NEAREST_MIPMAP_NEAREST:return W.NearestMipmapNearest;case Vt.LINEAR_MIPMAP_NEAREST:return W.LinearMipmapNearest;case Vt.NEAREST_MIPMAP_LINEAR:return W.NearestMipmapLinear;case Vt.LINEAR_MIPMAP_LINEAR:return W.LinearMipmapLinear;default:throw"[resolveGLEnumTextureFilterType] invalid glTextureFilter"}}function Qt(e){switch(e){case WebGLRenderingContext.CLAMP_TO_EDGE:return H.ClampToEdge;case WebGLRenderingContext.REPEAT:return H.Repeat;case WebGLRenderingContext.MIRRORED_REPEAT:return H.MirroredRepeat;default:throw"[resolveGLEnumTextureWrapType] invalid glTextureWrap"}}class en extends kt{constructor({gpu:e,img:t,type:n=U,width:r,height:a,mipmap:i=!1,minFilter:o=W.Nearest,magFilter:s=W.Nearest,wrapS:l=H.Repeat,wrapT:u=H.Repeat,flipY:c,depthPrecision:h}){super(),this.img=null,this.gpu=e;const f=this.gpu.gl;this.img=t||null,this.type=n,this.mipmap=i,this.minFilter=o,this.magFilter=s,this.wrapS=l,this.wrapT=u,this.width=r,this.height=a,this.flipY=!(!this.img||void 0!==c)||!!c,this.depthPrecision=this.type===O&&void 0!==h?h:void 0,this.img,this.img;const m=f.createTexture();if(!m)throw"[Texture.constructor] invalid texture";switch(this.texture=m,f.bindTexture(f.TEXTURE_2D,this.texture),i&&f.generateMipmap(f.TEXTURE_2D),this.type){case U:case z:case k:case j:case G:switch(this.minFilter){case W.Nearest:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.NEAREST);break;case W.Linear:default:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.LINEAR)}switch(this.magFilter){case W.Nearest:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.NEAREST);break;case W.Linear:default:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.LINEAR)}break;case O:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MIN_FILTER,f.NEAREST),f.texParameteri(f.TEXTURE_2D,f.TEXTURE_MAG_FILTER,f.NEAREST);break;default:throw"[Texture.constructor] invalid texture type"}switch(l){case H.ClampToEdge:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,f.CLAMP_TO_EDGE);break;case H.Repeat:default:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_S,f.REPEAT)}switch(u){case H.ClampToEdge:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,f.CLAMP_TO_EDGE);break;case H.Repeat:default:f.texParameteri(f.TEXTURE_2D,f.TEXTURE_WRAP_T,f.REPEAT)}switch(this.flipY?f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL,!0):f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL,!1),this.type){case U:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,f.RGBA,r,a,0,f.RGBA,f.UNSIGNED_BYTE,this.img):f.texImage2D(f.TEXTURE_2D,0,f.RGBA,r,a,0,f.RGBA,f.UNSIGNED_BYTE,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,f.RGBA,f.RGBA,f.UNSIGNED_BYTE,this.img);break;case O:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,this.depthPrecision===X?f.DEPTH_COMPONENT32F:f.DEPTH_COMPONENT16,r,a,0,f.DEPTH_COMPONENT,this.depthPrecision===X?f.FLOAT:f.UNSIGNED_SHORT,this.img):f.texImage2D(f.TEXTURE_2D,0,this.depthPrecision===X?f.DEPTH_COMPONENT32F:f.DEPTH_COMPONENT16,r,a,0,f.DEPTH_COMPONENT,this.depthPrecision===X?f.FLOAT:f.UNSIGNED_SHORT,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,this.depthPrecision===X?f.DEPTH_COMPONENT32F:f.DEPTH_COMPONENT16,f.DEPTH_COMPONENT,this.depthPrecision===X?f.FLOAT:f.UNSIGNED_SHORT,this.img);break;case z:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,f.RGBA16F,r,a,0,f.RGBA,f.FLOAT,this.img):f.texImage2D(f.TEXTURE_2D,0,f.RGBA16F,r,a,0,f.RGBA,f.FLOAT,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,f.RGBA16F,f.RGBA,f.FLOAT,this.img);break;case k:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,f.RGBA32F,r,a,0,f.RGBA,f.FLOAT,this.img):f.texImage2D(f.TEXTURE_2D,0,f.RGBA32F,r,a,0,f.RGBA,f.FLOAT,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,f.RGBA32F,f.RGBA,f.FLOAT,this.img);break;case j:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,f.R11F_G11F_B10F,r,a,0,f.RGB,f.FLOAT,this.img):f.texImage2D(f.TEXTURE_2D,0,f.R11F_G11F_B10F,r,a,0,f.RGB,f.FLOAT,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,f.R11F_G11F_B10F,f.RGB,f.FLOAT,this.img);break;case G:r&&a?this.img?f.texImage2D(f.TEXTURE_2D,0,f.R16F,r,a,0,f.RED,f.FLOAT,this.img):f.texImage2D(f.TEXTURE_2D,0,f.R16F,r,a,0,f.RED,f.FLOAT,null):this.img&&f.texImage2D(f.TEXTURE_2D,0,f.R16F,f.RED,f.FLOAT,this.img);break;default:throw"[Texture.constructor] invalid type"}f.bindTexture(f.TEXTURE_2D,null)}get glObject(){return this.texture}setSize(e,t){this.width=Math.floor(e),this.height=Math.floor(t);const n=this.gpu.gl;switch(n.bindTexture(n.TEXTURE_2D,this.texture),this.type){case U:this.img?n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,this.img):n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null);break;case O:this.img?n.texImage2D(n.TEXTURE_2D,0,this.depthPrecision===X?n.DEPTH_COMPONENT32F:n.DEPTH_COMPONENT16,e,t,0,n.DEPTH_COMPONENT,this.depthPrecision===X?n.FLOAT:n.UNSIGNED_SHORT,this.img):n.texImage2D(n.TEXTURE_2D,0,this.depthPrecision===X?n.DEPTH_COMPONENT32F:n.DEPTH_COMPONENT16,e,t,0,n.DEPTH_COMPONENT,this.depthPrecision===X?n.FLOAT:n.UNSIGNED_SHORT,null);break;case z:this.img?n.texImage2D(n.TEXTURE_2D,0,n.RGBA16F,e,t,0,n.RGBA,n.FLOAT,this.img):n.texImage2D(n.TEXTURE_2D,0,n.RGBA16F,e,t,0,n.RGBA,n.FLOAT,null);break;case k:this.img?n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,e,t,0,n.RGBA,n.FLOAT,this.img):n.texImage2D(n.TEXTURE_2D,0,n.RGBA32F,e,t,0,n.RGBA,n.FLOAT,null);break;case j:this.img?n.texImage2D(n.TEXTURE_2D,0,n.R11F_G11F_B10F,e,t,0,n.RGB,n.FLOAT,this.img):n.texImage2D(n.TEXTURE_2D,0,n.R11F_G11F_B10F,e,t,0,n.RGB,n.FLOAT,null);break;case G:this.img?n.texImage2D(n.TEXTURE_2D,0,n.R16F,e,t,0,n.RED,n.FLOAT,this.img):n.texImage2D(n.TEXTURE_2D,0,n.R16F,e,t,0,n.RED,n.FLOAT,null);break;default:throw"[Texture.setSize] invalid type"}n.bindTexture(n.TEXTURE_2D,null)}update({width:e,height:t,data:n}){this.width=e,this.height=t;const r=this.gpu.gl;if(r.bindTexture(r.TEXTURE_2D,this.texture),this.type!==k)throw"[Texture.update] invalid type";r.texImage2D(r.TEXTURE_2D,0,r.RGBA32F,e,t,0,r.RGBA,r.FLOAT,n),r.bindTexture(r.TEXTURE_2D,null)}generate(){return new en({gpu:this.gpu,img:this.img,type:this.type,width:this.width,height:this.height,mipmap:this.mipmap,minFilter:this.minFilter,magFilter:this.magFilter,wrapS:this.wrapS,wrapT:this.wrapT,flipY:this.flipY})}}async function tn(e){return new Promise(((t,n)=>{const r=new Image;r.onload=()=>{t(r)},r.onerror=()=>{n(r)},r.src=e}))}class nn extends kt{constructor(e,t,n,r,a,i,o,s,l){super();const u=e.gl;this.width=t,this.height=n,this.maxLodLevel=Math.log2(Math.max(this.width,this.height)),this.#i=u.createTexture(),u.bindTexture(u.TEXTURE_CUBE_MAP,this.#i),u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL,!1),u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,r),u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,a),u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,i),u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,o),u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,s),u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,l),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_MIN_FILTER,u.LINEAR_MIPMAP_LINEAR),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_MAG_FILTER,u.LINEAR),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE),u.generateMipmap(u.TEXTURE_CUBE_MAP),u.bindTexture(u.TEXTURE_CUBE_MAP,null)}#i;get glObject(){return this.#i}}function rn(e,t,n,r,a,i,o){return new nn(e,t.width,t.height,t,n,r,a,i,o)}function an(e,t){const n=[];switch(e){case ge:case xe:n.push(t),n.push(0),n.push(0),n.push(0);break;case Pe:n.push(t?1:0),n.push(0),n.push(0),n.push(0);break;case ue:case he:n.push(...t.elements),n.push(0);break;case fe:case ie:case Te:n.push(...t.elements);break;default:throw`invalid uniform type: ${e}`}return n}class on extends kt{constructor(e,t,n,r,a,i,o,s){super(),this.gpu=e,this.blockName=t,this.blockSize=n,this.dataSize=o,this.bindingPoint=s;const{gl:l}=this.gpu;this.ubo=l.createBuffer(),this.bind(),l.bufferData(l.UNIFORM_BUFFER,this.dataSize,l.DYNAMIC_DRAW),this.unbind(),l.bindBufferBase(l.UNIFORM_BUFFER,this.bindingPoint,this.ubo),this.variableInfo=r.map(((e,t)=>({name:e,index:a[t],offset:i[t]})))}get glObject(){return this.ubo}bind(){const{gl:e}=this.gpu;e.bindBuffer(e.UNIFORM_BUFFER,this.ubo)}unbind(){const{gl:e}=this.gpu;e.bindBuffer(e.UNIFORM_BUFFER,null)}updateBufferData(e,t){const n=this.variableInfo.find((t=>t.name===e));if(!n)throw new Error(`variableName ${e} not found`);this.bind(),this.gpu.gl.bufferSubData(this.gpu.gl.UNIFORM_BUFFER,n.offset,t,0),this.unbind()}updateUniformValue(e,t,n){switch(t){case de:n.forEach((t=>{const n=`${e}.${t.name}`,r=an(t.type,t.value);this.updateBufferData(n,new Float32Array(r))}));break;case pe:n.forEach(((t,n)=>{t.forEach((t=>{const r=`${e}[${n}].${t.name}`,a=an(t.type,t.value);this.updateBufferData(r,new Float32Array(a))}))}));break;default:if(Array.isArray(n)){const t=[];n.forEach((e=>{"number"==typeof e?(t.push(e),t.push(0),t.push(0),t.push(0)):"boolean"==typeof e?(t.push(e?1:0),t.push(0),t.push(0),t.push(0)):t.push(...e.elements)})),this.updateBufferData(e,new Float32Array(t))}else this.updateBufferData(e,"number"==typeof n?new Float32Array([n]):n.elements)}}}const sn=(e="black")=>{const t=document.createElement("canvas"),n=t.getContext("2d");if(!n)throw"invalid context";return t.width=1,t.height=1,n.fillStyle=e,n.fillRect(0,0,1,1),t},ln=(e,t)=>{switch(t){case te:return e.STATIC_DRAW;case ne:return e.DYNAMIC_DRAW;case re:return e.DYNAMIC_COPY;default:throw"[getAttributeUsage] invalid usage"}};class un extends kt{constructor({gpu:e,attributes:t=[],indices:n}){super(),this.vboList=[],this.ibo=null,this.gpu=e;const r=this.gpu.gl.createVertexArray();if(!r)throw"invalid vao";this.vao=r,this.bind(),t.forEach((e=>{this.setAttribute(e)})),n&&(this.ibo=new Kt({gpu:e,indices:n})),this.unbind(),this.ibo&&this.ibo.unbind()}get hasIndices(){return!!this.ibo}get glObject(){return this.vao}bind(){const{gl:e}=this.gpu;e.bindVertexArray(this.glObject)}unbind(){const{gl:e}=this.gpu;e.bindVertexArray(null)}setAttribute(e){const t=this.gpu.gl;t.bindVertexArray(this.vao);const{name:n,data:r,size:a,location:i,usageType:o,divisor:s}=e,l=null!=i?i:this.vboList.length,u=t.createBuffer();if(!u)throw"invalid vbo";t.bindBuffer(t.ARRAY_BUFFER,u);const c=ln(t,o);switch(t.bufferData(t.ARRAY_BUFFER,r,c),t.enableVertexAttribArray(l),r.constructor){case Float32Array:t.vertexAttribPointer(l,a,t.FLOAT,!1,0,0);break;case Uint16Array:t.vertexAttribIPointer(l,a,t.UNSIGNED_SHORT,0,0);break;default:throw"[VertexArrayObject.setAttribute] invalid data type"}s&&t.vertexAttribDivisor(l,s),this.vboList.push({name:n,vbo:u,usage:c,location:i,size:a,divisor:s}),t.bindVertexArray(null),t.bindBuffer(t.ARRAY_BUFFER,null)}updateBufferData(e,t){const{gl:n}=this.gpu,r=this.findVertexBufferObjectInfo(e);n.bindBuffer(n.ARRAY_BUFFER,r.vbo),n.bufferSubData(n.ARRAY_BUFFER,0,t),n.bindBuffer(n.ARRAY_BUFFER,null)}replaceBuffer(e,t){const{gl:n}=this.gpu,r=this.findVertexBufferObjectInfoIndex(e),{location:a,size:i}=this.vboList[r];this.bind(),n.bindBuffer(n.ARRAY_BUFFER,t),n.enableVertexAttribArray(a),n.vertexAttribPointer(a,i,n.FLOAT,!1,0,0),n.bindBuffer(n.ARRAY_BUFFER,null),this.unbind(),this.vboList[r].vbo=t}getBuffers(){return this.vboList.map((({vbo:e})=>e))}findVertexBufferObjectInfo(e){const t=this.vboList.find((({name:t})=>e===t));if(!t)throw"invalid target vbo";return t}findVertexBufferObjectInfoIndex(e){for(let t=0;t<this.vboList.length;t++)if(e===this.vboList[t].name)return t;throw"invalid target vbo"}findBuffer(e){const t=this.findVertexBufferObjectInfo(e);if(!t)throw"invalid name";return t.vbo}}class cn{constructor({gpu:e,attributes:t,indices:n,drawCount:r,instanceCount:a=null}){this.attributes=[],this.vertexCount=0,this.indices=null,this.gpu=e,this.instanceCount="number"==typeof a?a:null,this.drawCount=r,n&&(this.indices=n),t.forEach(((e,t)=>{e.location=t,e.divisor=e.divisor||0})),this.vertexArrayObject=new un({gpu:e,attributes:[],indices:this.indices}),t.filter((e=>Object.keys(e).length>0)).forEach((e=>{this.setAttribute(e)}))}setAttribute(e){const t=e.location?e.location:this.attributes.length,n=new Jt({name:e.name,data:e.data,location:t,size:e.size,offset:e.offset,usageType:e.usageType||te,divisor:e.divisor});this.attributes.push(n),this.vertexArrayObject.setAttribute(n)}#o({gpu:e}){this.attributes.forEach(((e,t)=>{e.location=t,e.divisor=0})),this.vertexArrayObject=new un({gpu:e,attributes:this.attributes,indices:this.indices})}start(){this.vertexArrayObject||this.#o({gpu:this.gpu})}update(){this.vertexArrayObject||this.#o({gpu:this.gpu})}updateAttribute(e,t){const n=this.attributes.find((({name:t})=>t===e));if(!n)throw"invalid attribute";n.data=t,this.vertexArrayObject.updateBufferData(e,n.data)}getAttribute(e){return this.attributes.find((({name:t})=>t===e))}getAttributeDescriptors(){return this.attributes.map((e=>e.getDescriptor()))}static createTangentsAndBinormals(t){const n=[],r=[];for(let a=0;a<t.length/3;a++){const i=t[3*a+0],o=t[3*a+1],s=t[3*a+2],l=new e(i,o,s),u=e.getTangent(l),c=e.getBinormalFromTangent(u,l);n.push(...u.elements),r.push(...c.elements)}return{tangents:n,binormals:r}}static createBinormals(t,n){const r=[];for(let a=0;a<t.length/3;a++){const i=new e(t[3*a+0],t[3*a+1],t[3*a+2]),o=new e(n[3*a+0],n[3*a+1],n[3*a+2]),s=e.getBinormalFromTangent(o,i);r.push(...s.elements)}return r}}class hn extends Nt{constructor({name:e,geometry:t,material:n,materials:r=[],depthMaterial:a,actorType:i,castShadow:o=!1,instanced:s=!1,autoGenerateDepthMaterial:l=!0}){super({name:e,type:i||P}),this.materials=[],this.geometry=t,this.materials=n?[n]:r||[],this.depthMaterial=a||null,this.castShadow=!!o,this.instanced=!!s,this.autoGenerateDepthMaterial=!!l}get material(){return this.hasMaterials,this.mainMaterial}set material(e){this.materials=[e]}get mainMaterial(){return this.materials[0]}get hasMaterials(){return this.materials.length>1}start({gpu:e}){super.start({gpu:e}),this.geometry.start(),this.materials.forEach((t=>{t.isCompiledShader||t.start({gpu:e,attributeDescriptors:this.geometry.getAttributeDescriptors()})})),!this.depthMaterial&&this.autoGenerateDepthMaterial&&(this.depthMaterial=new qt({name:`${this.material.name}/depth`,vertexShader:this.mainMaterial.rawVertexShader,fragmentShader:this.mainMaterial.depthFragmentShader||"#version 300 es\n\nprecision mediump float;\n\nout vec4 outColor;\n\nvoid main() {\n    outColor = vec4(1., 1., 1., 1.);\n}",uniforms:this.mainMaterial.depthUniforms.data,faceSide:this.mainMaterial.faceSide,depthTest:!0,depthWrite:!0,depthFuncType:l,alphaTest:this.mainMaterial.alphaTest,skipDepthPrePass:!!this.mainMaterial.skipDepthPrePass,uniformBlockNames:this.mainMaterial.uniformBlockNames})),this.depthMaterial&&!this.depthMaterial.isCompiledShader&&this.depthMaterial.start({gpu:e,attributeDescriptors:this.geometry.getAttributeDescriptors()})}updateMaterial(e){}updateDepthMaterial(e){}}class fn{constructor(e,t){this.origin=e,this.dir=t}}const mn={nearLeftTop:"nearLeftTop",nearRightTop:"nearRightTop",nearLeftBottom:"nearLeftBottom",nearRightBottom:"nearRightBottom",farLeftTop:"farLeftTop",farRightTop:"farRightTop",farLeftBottom:"farLeftBottom",farRightBottom:"farRightBottom"};class dn extends Nt{constructor({name:e,cameraType:n,clearColor:r,postProcess:a}){super({name:e,type:D}),this.viewMatrix=t.identity,this.projectionMatrix=t.identity,this.viewProjectionMatrix=t.identity,this.inverseViewProjectionMatrix=t.identity,this.inverseViewMatrix=t.identity,this.inverseProjectionMatrix=t.identity,this.#s=null,this.near=1,this.far=10,this.visibleFrustum=!1,this.visibleFrustumMesh=null,this.cameraType=n,this.clearColor=r||new zt(0,0,0,1),this.#l=a||null}#s;#l;get cameraForward(){return this.transform.worldForward.negate()}get postProcess(){return this.#l}get enabledPostProcess(){return!!this.postProcess&&this.postProcess.enabled}get hasEnabledPostProcessPass(){return!!this.enabledPostProcess&&this.postProcess.hasEnabledPass}get renderTarget(){return this.#s}get writeRenderTarget(){return this.#s?this.#s.isSwappable?this.#s.write:this.#s:null}setSize(e,t){this.#s&&this.#s.setSize(e,t),this.#l&&this.#l.setSize(e,t)}setPostProcess(e){this.#l=e}setClearColor(e){this.clearColor=e}update({gpu:e,time:t,deltaTime:n}){if(super.update({gpu:e,time:t,deltaTime:n}),this.visibleFrustumMesh||(this.visibleFrustumMesh=new hn({geometry:new cn({gpu:e,attributes:[new Jt({name:ae.Position,data:new Float32Array(new Array(24).fill(0)),size:3,usageType:ne})],drawCount:36,indices:[6,7,4,4,7,5,0,1,2,2,1,3,0,4,5,5,1,0,0,2,4,2,6,4,2,3,6,6,3,7,1,5,7,7,1,3]}),material:new qt({vertexShader:`#version 300 es\n                    \n                    layout (location = 0) in vec3 ${ae.Position};\n\n                    #pragma TRANSFORM_VERTEX_UNIFORMS\n                   \n                    void main() {\n                        gl_Position = ${Ce} * ${Se} * ${ye} * vec4(${ae.Position}, 1.);\n                    }\n                    `,fragmentShader:"#version 300 es\n                   \n                    precision mediump float;\n                    \n                    out vec4 outColor;\n                    \n                    void main() {\n                        outColor = vec4(0, 1., 0, 1.);\n                    }\n                    ",primitiveType:r,blendType:h,depthWrite:!1})}),this.addChild(this.visibleFrustumMesh)),this.visibleFrustumMesh){const e=this.getFrustumLocalPositions();this.visibleFrustumMesh.geometry.updateAttribute(ae.Position,new Float32Array([...e.nearLeftTop.elements,...e.nearLeftBottom.elements,...e.nearRightTop.elements,...e.nearRightBottom.elements,...e.farLeftTop.elements,...e.farLeftBottom.elements,...e.farRightTop.elements,...e.farRightBottom.elements])),this.visibleFrustumMesh.enabled=this.visibleFrustum}}updateTransform(){super.updateTransform(),this.viewMatrix=this.transform.worldMatrix.clone().invert(),this.inverseProjectionMatrix=this.projectionMatrix.clone().invert(),this.inverseViewMatrix=this.viewMatrix.clone().invert(),this.viewProjectionMatrix=t.multiplyMatrices(this.projectionMatrix,this.viewMatrix),this.inverseViewProjectionMatrix=this.viewProjectionMatrix.clone().invert()}isPerspective(){return this.cameraType===B}transformScreenPoint(n){const r=t.multiplyMatrices(this.projectionMatrix,this.viewMatrix,t.translationMatrix(n)),a=r.position,i=0===r.m33?1e-4:r.m33;return new e(a.x/i,a.y/i,a.z/i)}setRenderTarget(e){this.#s=e}updateProjectionMatrix(){throw"[Camera.updateProjectionMatrix] should implementation"}getFrustumLocalPositions(){throw"[Camera.getFrustumLocalPosition] should implementation"}getFrustumWorldPositions(){throw"[Camera.getFrustumWorldPositions] should implementation"}getWorldForward(){return this.transform.worldForward.clone().negate()}viewpointToRay(t){const n=new zt(2*t.x-1,2*t.y-1,1,1).multiplyMatrix4(this.inverseViewProjectionMatrix);n.x=n.x/n.w,n.y=n.y/n.w,n.z=n.z/n.w;const r=new e(n.x,n.y,n.z),a=this.transform.worldPosition,i=r.subVector(a).normalize();return new fn(a,i)}}class pn extends dn{constructor(e,t,n,r,a,i){super({cameraType:M}),this.left=0,this.right=0,this.bottom=0,this.top=0,this.near=0,this.far=0,this.aspect=1,this.left=e,this.right=t,this.bottom=n,this.top=r,this.near=a,this.far=i,this.setOrthoSize(1,1,e,t,n,r)}setOrthoSize(e,t,n,r,a,i){n&&r&&i&&a&&(this.left=n,this.right=r,this.bottom=a,this.top=i),null!==e&&null!==t&&this.setSize(e,t),this.aspect=(r-n)/(i-a)}setSize(e,t){super.setSize(e,t),this.updateProjectionMatrix()}updateProjectionMatrix(){this.projectionMatrix=t.getOrthographicMatrix(this.left,this.right,this.bottom,this.top,this.near,this.far)}getFrustumLocalPositions(){const t=e.back,n=e.right,r=e.up,a=(Math.abs(this.left)+Math.abs(this.right))/2,i=(Math.abs(this.top)+Math.abs(this.right))/2,o=t.clone().scale(this.near),s=t.clone().scale(this.far),l=n.clone().scale(a),u=r.clone().scale(i);return{nearLeftTop:e.addVectors(o,l.clone().negate(),u),nearRightTop:e.addVectors(o,l,u),nearLeftBottom:e.addVectors(o,l.clone().negate(),u.clone().negate()),nearRightBottom:e.addVectors(o,l,u.clone().negate()),farLeftTop:e.addVectors(s,l.clone().negate(),u),farRightTop:e.addVectors(s,l,u),farLeftBottom:e.addVectors(s,l.clone().negate(),u.clone().negate()),farRightBottom:e.addVectors(s,l,u.clone().negate())}}getFrustumWorldPositions(){const t={nearLeftTop:e.zero,nearRightTop:e.zero,nearLeftBottom:e.zero,nearRightBottom:e.zero,farLeftTop:e.zero,farRightTop:e.zero,farLeftBottom:e.zero,farRightBottom:e.zero},n=this.getFrustumLocalPositions();for(const e in mn){const r=e,a=n[r].multiplyMatrix4(this.transform.worldMatrix);t[r]=a}return t}static CreateFullQuadOrthographicCamera(){const t=new pn(-1,1,-1,1,0,2);return t.transform.setTranslation(new e(0,0,1)),t}}class gn extends dn{constructor(e,t,n,r,a){super({name:a,cameraType:B}),this.aspect=1,this.fixedAspect=!1,this.fov=e,this.aspect=t,this.near=n,this.far=r,this.setPerspectiveSize(t)}setPerspectiveSize(e){this.aspect=e,this.updateProjectionMatrix()}setSize(e,t){super.setSize(e,t),this.fixedAspect||this.setPerspectiveSize(e/t)}updateProjectionMatrix(){this.projectionMatrix=t.getPerspectiveMatrix(this.fov*Math.PI/180,this.aspect,this.near,this.far)}getFrustumLocalPositions(){const t=e.back,n=e.right,r=e.up,a=this.fov/2*Math.PI/180,i=this.near*a,o=i*this.aspect,s=this.far*a,l=s*this.aspect,u=t.clone().scale(this.near),c=t.clone().scale(this.far),h=n.clone().scale(o),f=r.clone().scale(i),m=n.clone().scale(l),d=r.clone().scale(s);return{nearLeftTop:e.addVectors(u,h.clone().negate(),f),nearRightTop:e.addVectors(u,h,f),nearLeftBottom:e.addVectors(u,h.clone().negate(),f.clone().negate()),nearRightBottom:e.addVectors(u,h,f.clone().negate()),farLeftTop:e.addVectors(c,m.clone().negate(),d),farRightTop:e.addVectors(c,m,d),farLeftBottom:e.addVectors(c,m.clone().negate(),d.clone().negate()),farRightBottom:e.addVectors(c,m,d.clone().negate())}}}class vn extends hn{constructor({gpu:e,cubeMap:t,diffuseIntensity:n,specularIntensity:r,rotationOffset:i=0,renderMesh:o=!0}){const l=function(e){const t=[],n=[],r=[],a=[];e.split("\n").forEach((e=>{const i=e.split(" ");switch(i[0]){case"v":t.push([Number.parseFloat(i[1]),Number.parseFloat(i[2]),Number.parseFloat(i[3])]);break;case"vn":n.push([Number.parseFloat(i[1]),Number.parseFloat(i[2]),Number.parseFloat(i[3])]);break;case"vt":r.push([Number.parseFloat(i[1]),Number.parseFloat(i[2])]);break;case"f":a.push([i[1],i[2],i[3]])}}));const i=[],o=[],s=[],l=[];return a.forEach(((e,a)=>{const u=e[0].split("/"),c=e[1].split("/"),h=e[2].split("/"),f=Number.parseInt(u[0],10)-1,m=Number.parseInt(u[1],10)-1,d=Number.parseInt(u[2],10)-1,p=Number.parseInt(c[0],10)-1,g=Number.parseInt(c[1],10)-1,v=Number.parseInt(c[2],10)-1,x=Number.parseInt(h[0],10)-1,T=Number.parseInt(h[1],10)-1,w=Number.parseInt(h[2],10)-1;i.push(t[f],t[p],t[x]),o.push(r[m],r[g],r[T]),s.push(n[d],n[v],n[w]);const b=2*a;l.push(a+b,a+b+1,a+b+2)})),{positions:i.flat(),uvs:o.flat(),normals:s.flat(),indices:l}}("\n# Blender 3.3.1\n# www.blender.org\nmtllib skybox-cube.mtl\nv -1.000000 -1.000000 1.000000\nv -1.000000 1.000000 1.000000\nv -1.000000 -1.000000 -1.000000\nv -1.000000 1.000000 -1.000000\nv 1.000000 -1.000000 1.000000\nv 1.000000 1.000000 1.000000\nv 1.000000 -1.000000 -1.000000\nv 1.000000 1.000000 -1.000000\nvn 0.5774 0.5774 0.5774\nvn 0.5774 -0.5774 -0.5774\nvn 0.5774 0.5774 -0.5774\nvn -0.5774 0.5774 0.5774\nvn 0.5774 -0.5774 0.5774\nvn -0.5774 0.5774 -0.5774\nvn -0.5774 -0.5774 0.5774\nvn -0.5774 -0.5774 -0.5774\nvt 0.375000 0.000000\nvt 0.375000 1.000000\nvt 0.125000 0.750000\nvt 0.625000 0.000000\nvt 0.625000 1.000000\nvt 0.875000 0.750000\nvt 0.125000 0.500000\nvt 0.375000 0.250000\nvt 0.625000 0.250000\nvt 0.875000 0.500000\nvt 0.375000 0.750000\nvt 0.625000 0.750000\nvt 0.375000 0.500000\nvt 0.625000 0.500000\ns 1\nf 3/8/1 2/4/2 1/1/3\nf 7/13/4 4/9/5 3/8/1\nf 5/11/6 8/14/7 7/13/4\nf 1/2/3 6/12/8 5/11/6\nf 1/3/3 7/13/4 3/7/1\nf 6/12/8 4/10/5 8/14/7\nf 3/8/1 4/9/5 2/4/2\nf 7/13/4 8/14/7 4/9/5\nf 5/11/6 6/12/8 8/14/7\nf 1/2/3 2/5/2 6/12/8\nf 1/3/3 5/11/6 7/13/4\nf 6/12/8 2/6/2 4/10/5\n");super({geometry:new cn({gpu:e,attributes:[new Jt({name:ae.Position,data:new Float32Array(l.positions),size:3}),new Jt({name:ae.Uv,data:new Float32Array(l.uvs),size:2}),new Jt({name:ae.Normal,data:new Float32Array(l.normals),size:3})],indices:l.indices,drawCount:l.indices.length}),material:new qt({name:"Skybox",vertexShader:"#version 300 es\n\n#pragma APPEND_ATTRIBUTES\n\n#pragma DEFINES\n\n#pragma ATTRIBUTES\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\n#pragma APPEND_UNIFORMS\n\nout vec2 vUv;\nout vec3 vNormal;\nout vec3 vWorldPosition;\n\nvoid main() {\n    vUv = aUv;\n    vNormal = (uNormalMatrix * vec4(aNormal, 1)).xyz;\n    vec4 worldPosition = uWorldMatrix * vec4(aPosition, 1);\n    vWorldPosition = worldPosition.xyz;\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n}",fragmentShader:"#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\nin vec2 vUv;\nin vec3 vNormal;\nin vec3 vWorldPosition;\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\nuniform samplerCube uCubeTexture;\n\nuniform float uRotationOffset;\nuniform int uShadingModelId;\n\nvec3 reinhard(vec3 x) {\n    return x / (x + vec3(1.));\n}\n\nvec3 reinhardExposure(vec3 x, float exposure) {\n    float l2 = exposure * exposure;\n    return (x / (x + vec3(1.))) * (1. + (x / exposure));\n}\n\nvec3 aces(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    vec3 y = (x * (a * x + b)) / (x * (c * x + d) + e);\n    return clamp(y, 0., 1.);\n}\n\nvec3 degamma(vec3 color) {\n    return pow(color, vec3(1. / 2.2));\n}\n\nvec3 gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvec3 calcEnvMapSampleDir(vec3 reflectDir, float rotationOffset) {\n    reflectDir.x *= -1.;\n    float c = cos(3.14 + rotationOffset);\n    float s = sin(3.14 + rotationOffset);\n    reflectDir.xz *= mat2(c, s, -s, c);\n    return reflectDir;\n}\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n\nlayout (location = 0) out vec4 outGBufferA;\nlayout (location = 1) out vec4 outGBufferB;\nlayout (location = 2) out vec4 outGBufferC;\nlayout (location = 3) out vec4 outGBufferD;\n\nvoid main() {\n    \n    vec3 N = normalize(vNormal);\n    vec3 reflectDir = -N;\n    \n    \n    \n    \n    \n    \n    vec3 skyboxSampleDir = calcEnvMapSampleDir(reflectDir, uRotationOffset);\n    \n    \n    vec3 envMapColor = textureLod(uCubeTexture, skyboxSampleDir, 0.).xyz;\n  \n    \n    envMapColor = gamma(envMapColor); \n        \n    \n    \n    \n    outGBufferA = EncodeGBufferA(envMapColor);\n    outGBufferB = EncodeGBufferB(vec3(0.), uShadingModelId);\n    outGBufferC = EncodeGBufferC(0., 0.);\n    outGBufferD = EncodeGBufferD(vec3(0.));\n}",primitiveType:a,depthTest:!0,depthWrite:!1,useEnvMap:!0,uniforms:[{name:at,type:le,value:t},{name:Tt,type:ge,value:i},{name:ke,type:xe,value:s}],uniformBlockNames:[bt,Pt]}),actorType:C}),this.diffuseIntensity=1,this.specularIntensity=1,this.rotationOffset=0,this.renderMesh=!0,this.cubeMap=t,this.diffuseIntensity=n,this.specularIntensity=r,this.rotationOffset=i,this.renderMesh=o}updateTransform(t){t&&(this.transform.setTranslation(t.transform.position),this.transform.setScaling(e.fill(t.far/1.733))),super.updateTransform()}}class xn{constructor(e,t){this.lastTime=-1/0,this.targetFPS=e,this.callback=t}start(e){this.lastTime=e}exec(e){const t=1/this.targetFPS;if(e-t>=this.lastTime){const n=e-this.lastTime,r=t*Math.floor(n/t);this.lastTime+=r,this.callback(this.lastTime,r)}}}class Tn{constructor(e,t,n=60){this.lastTime=-1/0,this.targetFPS=e,this.callback=t,this.maxChaseCount=n}start(e){this.lastTime=e}exec(e){const t=1/this.targetFPS;if(e-t>=this.lastTime){const n=e-this.lastTime,r=Math.floor(n/t);if(r>this.maxChaseCount)return this.lastTime+=t*r,void this.callback(this.lastTime,t);const a=Math.min(this.maxChaseCount,r);for(let e=0;e<a;e++)this.lastTime+=t,this.callback(this.lastTime,t)}}}class wn{constructor(e=1){this.renderCount=0,this.startCountTime=-1/0,this.calculateInterval=1,this._currentFPS=0,this.calculateInterval=e}get currentFPS(){return this._currentFPS}start(e){this.renderCount=0,this.startCountTime=e}calculate(e){if(this.startCountTime<0)return void this.start(e);this.renderCount++;const t=e-this.startCountTime;t>this.calculateInterval&&(this._currentFPS=this.renderCount/t,this.start(e))}}class bn{constructor(e={}){this.passes=[],this.drawVertexCount=0,this.drawCallCount=0,this.showPassDetails=!1;const{wrapperElement:t}=e;this.domElement=document.createElement("div"),this.domElement.style.cssText="\nposition: absolute;\ntop: 0;\nleft: 0;\npadding: 0.2em 0.5em;\nfont-size: 9px;\ncolor: white;\nfont-weight: bold;\ntext-shadow: rgba(0, 0, 0, 0.7) 1px 1px;\nwhite-space: break-spaces;\n",this.fpsCounterView=document.createElement("p"),this.domElement.appendChild(this.fpsCounterView),this.passInfoView=document.createElement("p"),this.domElement.appendChild(this.passInfoView),this.drawVertexCountView=document.createElement("p"),this.domElement.appendChild(this.drawVertexCountView),this.drawCallCountView=document.createElement("p"),this.domElement.appendChild(this.drawCallCountView),(t||document.body).appendChild(this.domElement),this.showPassDetails=!!e.showPassDetails,this.fpsCounter=new wn}clear(){this.passes=[],this.drawVertexCount=0,this.drawCallCount=0}addPassInfo(e,t,n){const r=this.passes.findIndex((t=>t.groupLabel===e)),a=n.getAttribute(ae.Position);if(!a)throw"invalid position attribute";const i=a.data.length/3;r<0?this.addPassGroup(e,{passLabel:t,vertexCount:i}):this.passes[r].passInfos.push({passLabel:t,vertexCount:i})}addDrawVertexCount(e){const t=e.getAttribute(ae.Position);t&&(this.drawVertexCount+=t.data.length/3)}incrementDrawCall(){this.drawCallCount++}update(e){this.fpsCounter.calculate(e),this.updateView()}updateView(){this.fpsCounterView.textContent=`FPS: ${Math.floor(this.fpsCounter.currentFPS)}`;const e=[];e.push("-------------");for(let t=0;t<this.passes.length;t++){let n=0,r=0;const a=[];for(let e=0;e<this.passes[t].passInfos.length;e++){const i=this.passes[t].passInfos[e];if(this.showPassDetails){const e=`${i.passLabel} - vertex count: ${i.vertexCount}`;a.push(e)}n++,r+=i.vertexCount}a.unshift(`[${this.passes[t].groupLabel}]\ndraw calls: ${n}, vertex count: ${r}`),e.push(...a)}e.push("-------------"),this.passInfoView.textContent=e.join("\n"),this.drawVertexCountView.textContent=`vertex count: ${this.drawVertexCount}`,this.drawCallCountView.textContent=`draw call count: ${this.drawCallCount}`}addPassGroup(e,t){this.passes.push({groupLabel:e,passInfos:[t]})}}class Pn{constructor(e){this.passes=[],this.#u=!0,this.#c=e||pn.CreateFullQuadOrthographicCamera()}#c;#u;get enabled(){if(!this.#u)return!1;for(let e=0;e<this.passes.length;e++)if(this.passes[e].enabled)return!0;return!1}get postProcessCamera(){return this.#c}set enabled(e){this.#u=e}get hasEnabledPass(){for(let e=0;e<this.passes.length;e++)if(this.passes[e].enabled)return!0;return!1}get lastRenderTarget(){let e=null;for(let t=this.passes.length-1;t>=0;t--)if(this.passes[t].enabled){e=this.passes[t];break}return null==e?null:e.renderTarget}setSize(e,t){this.#c.setSize(e,t),this.passes.forEach((n=>n.setSize(e,t)))}addPass(e){this.passes.push(e)}update(){this.passes.forEach((e=>{e.update()}))}static updatePassMaterial({pass:e,renderer:t,targetCamera:n,lightActors:r}){e.materials.forEach((e=>{r&&hr(e,r),e.uniforms.setValue(De,n.viewProjectionMatrix),e.uniforms.setValue(Re,n.inverseViewProjectionMatrix),e.uniforms.setValue(Ee,n.inverseViewMatrix),e.uniforms.setValue(Ae,n.inverseProjectionMatrix),e.uniforms.setValue(Fe,n.viewMatrix.clone().invert().transpose()),e.uniforms.setValue(Ne,t.gBufferRenderTargets.gBufferATexture),e.uniforms.setValue(Ue,t.gBufferRenderTargets.gBufferBTexture),e.uniforms.setValue(Oe,t.gBufferRenderTargets.gBufferCTexture),e.uniforms.setValue(ze,t.gBufferRenderTargets.gBufferDTexture),e.uniforms.setValue(je,t.depthPrePassRenderTarget.depthTexture)}))}static renderPass({pass:e,gpu:t,renderer:n,camera:r,prevRenderTarget:a,targetCamera:i,gBufferRenderTargets:o,time:s,isLastPass:l,lightActors:u}){Pn.updatePassMaterial({pass:e,renderer:n,targetCamera:i,lightActors:u}),n.updateCameraUniforms(i),e.render({gpu:t,renderer:n,camera:r,prevRenderTarget:a,isLastPass:l,targetCamera:i,gBufferRenderTargets:o,time:s,lightActors:u})}render({gpu:e,renderer:t,prevRenderTarget:n,gBufferRenderTargets:r,targetCamera:a,time:i,isCameraLastPass:o,lightActors:s}){this.#c.updateTransform();const l=this.passes.filter((e=>e.enabled));l.forEach(((u,c)=>{const h=o&&c===l.length-1;Pn.renderPass({pass:u,gpu:e,renderer:t,camera:this.#c,prevRenderTarget:n,isLastPass:h,targetCamera:a,gBufferRenderTargets:r,time:i,lightActors:s}),n=u.renderTarget}))}}class yn extends kt{#h;#f=[];#m;get drawBufferList(){return this.#f}get glObject(){return this.#h}get hasMultipleDrawBuffers(){return this.#f.length>=2}registerDrawBuffer(e){this.#f.push(e)}constructor({gpu:e}){super(),this.#m=e;const t=this.#m.gl.createFramebuffer();if(!t)throw"invalid framebuffer";this.#h=t}bind(){const e=this.#m.gl;e.bindFramebuffer(e.FRAMEBUFFER,this.#h)}unbind(){const e=this.#m.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}}class Sn extends kt{#m;#d;#p;get glObject(){return this.#p}constructor({gpu:e,type:t,width:n,height:r}){super(),this.#m=e,this.#d=t;const a=this.#m.gl,i=a.createRenderbuffer();if(!i)throw"invalid render buffer";if(this.#p=i,a.bindRenderbuffer(a.RENDERBUFFER,this.#p),this.#d!==x)throw"[Renderbuffer.constructor] invalid render buffer type.";a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,n,r),a.bindRenderbuffer(a.RENDERBUFFER,null)}setSize(e,t){const n=this.#m.gl;if(n.bindRenderbuffer(n.RENDERBUFFER,this.#p),this.#d===x)n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,e,t);n.bindRenderbuffer(n.RENDERBUFFER,null)}}class Cn{constructor({isSwappable:e=!1}={isSwappable:!1}){this.isSwappable=e}get read(){throw"[AbstractRenderTarget] should implementation 'read' getter"}get write(){throw"[AbstractRenderTarget] should implementation 'write' getter"}}class Dn extends Cn{constructor({gpu:e,name:t="",type:n=$,width:r=1,height:a=1,useDepthBuffer:i=!1,writeDepthTexture:o=!1,minFilter:s=W.Linear,magFilter:l=W.Linear,wrapT:u=H.ClampToEdge,wrapS:c=H.ClampToEdge,mipmap:h=!1,depthPrecision:f}){super(),this.depthRenderbuffer=null,this._texture=null,this._depthTexture=null,this.gpu=e;const m=this.gpu.gl;switch(this.name=t,this.type=n,this.width=r,this.height=a,this._framebuffer=new yn({gpu:e}),this._framebuffer.bind(),i&&(this.depthRenderbuffer=new Sn({gpu:e,type:x,width:r,height:a})),this.depthRenderbuffer&&m.framebufferRenderbuffer(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.RENDERBUFFER,this.depthRenderbuffer.glObject),this.type){case $:this._texture=new en({gpu:e,width:this.width,height:this.height,mipmap:h,type:U,minFilter:s,magFilter:l,wrapS:c,wrapT:u}),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,this._texture.glObject,0);break;case J:if(!e.checkExtension(Ft))throw"EXT_color_buffer_float not supported";this._texture=new en({gpu:e,width:this.width,height:this.height,mipmap:h,type:z,minFilter:s,magFilter:l,wrapS:c,wrapT:u}),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,this._texture.glObject,0);break;case K:if(!e.checkExtension(Ft))throw"EXT_color_buffer_float not supported";this._texture=new en({gpu:e,width:this.width,height:this.height,mipmap:h,type:j,minFilter:s,magFilter:l,wrapS:c,wrapT:u}),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,this._texture.glObject,0);break;case Z:this._texture=new en({gpu:e,width:this.width,height:this.height,mipmap:h,type:G,minFilter:s,magFilter:l,wrapS:c,wrapT:u}),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,this._texture.glObject,0)}if(this._texture){if(m.checkFramebufferStatus(m.FRAMEBUFFER)!==At)throw"framebuffer not completed";this._framebuffer.registerDrawBuffer(Rt)}if((this.type===Y||o)&&(this._depthTexture=new en({gpu:e,width:this.width,height:this.height,mipmap:!1,type:O,minFilter:s,magFilter:l,wrapS:c,wrapT:u,depthPrecision:f}),m.framebufferTexture2D(m.FRAMEBUFFER,m.DEPTH_ATTACHMENT,m.TEXTURE_2D,this._depthTexture.glObject,0)),this._depthTexture&&this.depthRenderbuffer)throw"[RenderTarget.constructor] depth texture and depth render buffer are active.";m.bindTexture(m.TEXTURE_2D,null),this.depthRenderbuffer&&m.bindRenderbuffer(m.RENDERBUFFER,null),this._framebuffer.unbind()}get texture(){return this._texture}get depthTexture(){return this._depthTexture}get framebuffer(){return this._framebuffer}get read(){return this}get write(){return this}setSize(e,t){this.width=Math.floor(e),this.height=Math.floor(t),this._texture&&this._texture.setSize(this.width,this.height),this._depthTexture&&this._depthTexture.setSize(this.width,this.height),this.depthRenderbuffer&&this.depthRenderbuffer.setSize(e,t)}setTexture(e){const t=this.gpu.gl;this._texture=e,t.bindFramebuffer(t.FRAMEBUFFER,this._framebuffer.glObject),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this._texture.glObject,0),t.bindFramebuffer(t.FRAMEBUFFER,null)}setDepthTexture(e){const t=this.gpu.gl;this._depthTexture=e,this._framebuffer.bind(),t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,this._depthTexture.glObject,0),this._framebuffer.unbind()}static blitDepth({gpu:e,sourceRenderTarget:t,destRenderTarget:n,width:r,height:a}){const i=e.gl;i.bindFramebuffer(i.READ_FRAMEBUFFER,t.framebuffer.glObject),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,n.framebuffer.glObject),i.clear(i.DEPTH_BUFFER_BIT),i.checkFramebufferStatus(i.READ_FRAMEBUFFER)===i.FRAMEBUFFER_COMPLETE&&(i.blitFramebuffer(0,0,r,a,0,0,r,a,i.DEPTH_BUFFER_BIT,i.NEAREST),i.bindFramebuffer(i.READ_FRAMEBUFFER,null),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,null))}}class Bn extends Cn{constructor({gpu:e,name:t,width:n=1,height:r=1}){super(),this._gBufferTextures=[],this._depthTexture=null,this.gpu=e;const a=W.Linear,i=W.Linear,o=e.gl;this.name=t,this.width=n,this.height=r,this._framebuffer=new yn({gpu:e}),this._framebuffer.bind();const s=o.COLOR_ATTACHMENT0+0;this._gBufferATexture=new en({gpu:e,width:this.width,height:this.height,mipmap:!1,type:U,minFilter:a,magFilter:i}),o.framebufferTexture2D(o.FRAMEBUFFER,s,o.TEXTURE_2D,this._gBufferATexture.glObject,0),this._gBufferTextures.push(this._gBufferATexture),this.framebuffer.registerDrawBuffer(s);const l=o.COLOR_ATTACHMENT0+1;this._gBufferBTexture=new en({gpu:e,width:this.width,height:this.height,mipmap:!1,type:U,minFilter:a,magFilter:i}),o.framebufferTexture2D(o.FRAMEBUFFER,l,o.TEXTURE_2D,this._gBufferBTexture.glObject,0),this.framebuffer.registerDrawBuffer(l),this._gBufferTextures.push(this._gBufferBTexture);const u=o.COLOR_ATTACHMENT0+2;this._gBufferCTexture=new en({gpu:e,width:this.width,height:this.height,mipmap:!1,type:U,minFilter:a,magFilter:i}),o.framebufferTexture2D(o.FRAMEBUFFER,u,o.TEXTURE_2D,this._gBufferCTexture.glObject,0),this.framebuffer.registerDrawBuffer(u),this._gBufferTextures.push(this._gBufferCTexture);const c=o.COLOR_ATTACHMENT0+3;this._gBufferDTexture=new en({gpu:e,width:this.width,height:this.height,mipmap:!1,type:j,minFilter:a,magFilter:i}),o.framebufferTexture2D(o.FRAMEBUFFER,c,o.TEXTURE_2D,this._gBufferDTexture.glObject,0),this.framebuffer.registerDrawBuffer(c),this._gBufferTextures.push(this._gBufferDTexture),o.bindTexture(o.TEXTURE_2D,null),this.framebuffer.unbind()}get gBufferATexture(){return this._gBufferATexture}get gBufferBTexture(){return this._gBufferBTexture}get gBufferCTexture(){return this._gBufferCTexture}get gBufferDTexture(){return this._gBufferDTexture}get depthTexture(){return this._depthTexture}get framebuffer(){return this._framebuffer}get read(){return this}get write(){return this}setSize(e,t){this.width=e,this.height=t,this._gBufferTextures.forEach((e=>e.setSize(this.width,this.height))),this._depthTexture&&this._depthTexture.setSize(this.width,this.height)}setDepthTexture(e){const t=this.gpu.gl;this._depthTexture=e,this._framebuffer.bind(),t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,this._depthTexture.glObject,0),this._framebuffer.unbind()}}function Mn(t){const n=function({calculateTangent:t,calculateBinormal:n,flipUvY:r,width:a=2,height:i=2,offset:o=e.zero}){const s=[0,0,1,0,0,1,0,0,1,0,0,1],l=a/2,u=i/2,c=new Float32Array([-l+o.x,u+o.y,0+o.z,-l+o.x,-u+o.y,0+o.z,l+o.x,u+o.y,0+o.z,l+o.x,-u+o.y,0+o.z]),h=new Float32Array(r?[0,0,0,1,1,0,1,1]:[0,1,0,0,1,1,1,0]),f=new Float32Array(s);let m=new Float32Array,d=new Float32Array;if(t||n){const e=cn.createTangentsAndBinormals(s);t&&(m=new Float32Array(e.tangents)),n&&(d=new Float32Array(e.binormals))}return{positions:c,uvs:h,normals:f,tangents:m,binormals:d,indices:[0,1,2,2,1,3],drawCount:6}}(t),r=[new Jt({name:ae.Position,data:n.positions,size:3}),new Jt({name:ae.Uv,data:n.uvs,size:2}),new Jt({name:ae.Normal,data:n.normals,size:3})];return t.calculateTangent&&r.push(new Jt({name:ae.Tangent,data:n.tangents,size:3})),t.calculateBinormal&&r.push(new Jt({name:ae.Binormal,data:n.binormals,size:3})),{attributes:r,indices:[0,1,2,2,1,3],drawCount:6}}class En extends cn{constructor({gpu:e,...t}){const{attributes:n,indices:r,drawCount:a}=Mn(t);super({gpu:e,attributes:n,indices:r,drawCount:a})}}class Rn{constructor({gpu:e,vertexShader:t,fragmentShader:n,rawVertexShader:r,rawFragmentShader:i,uniforms:o=[],uniformBlockNames:s=[],useEnvMap:l=!1,receiveShadow:u=!1,name:c="",renderTargetType:h=$,minFilter:f=W.Linear,magFilter:m=W.Linear,wrapT:d=H.ClampToEdge,wrapS:p=H.ClampToEdge,srcTextureEnabled:g=!0}){this.enabled=!0,this.width=1,this.height=1,this.materials=[],this.beforeRender=null,this.name=c;t=t||Rn.baseVertexShader,this.geometry=new En({gpu:e}),this.material=new qt({name:c,vertexShader:t,fragmentShader:n,rawVertexShader:r,rawFragmentShader:i,uniforms:[...o,...Rn.commonUniforms,...g?[{name:qe,type:se,value:null}]:[]],uniformBlockNames:s,useEnvMap:!!l,receiveShadow:!!u,primitiveType:a}),this.materials.push(this.material),this.mesh=new hn({geometry:this.geometry,material:this.material}),this._renderTarget=new Dn({gpu:e,width:1,height:1,type:h,minFilter:f,magFilter:m,wrapS:p,wrapT:d})}get renderTarget(){return this._renderTarget}static get baseVertexShader(){return"#version 300 es\n\n#pragma DEFINES\n\n#pragma ATTRIBUTES\n\nout vec2 vUv;\n\nvoid main() {\n    vUv = aUv;\n    gl_Position = vec4(aPosition, 1);\n}"}static get commonUniforms(){return[{name:Ze,type:ge,value:1},{name:Qe,type:ge,value:1},{name:Je,type:ge,value:0}]}setSize(e,t){this.width=e,this.height=t,this._renderTarget.setSize(e,t),this.material.uniforms.setValue("uTargetWidth",this.width),this.material.uniforms.setValue("uTargetHeight",this.height)}setRenderTarget(e,t,n){n?e.setRenderTarget(t.renderTarget,!0):e.setRenderTarget(this._renderTarget,!0)}update(){}render({gpu:e,targetCamera:t,renderer:n,prevRenderTarget:r,isLastPass:a}){this.setRenderTarget(n,t,a),this.mesh.updateTransform(),this.materials.forEach((t=>{t.isCompiledShader||(t.start({gpu:e,attributeDescriptors:this.geometry.getAttributeDescriptors()}),n.checkNeedsBindUniformBufferObjectToMaterial(t))})),r&&this.material.uniforms.setValue(qe,r.texture),this.beforeRender&&this.beforeRender(),n.renderMesh(this.geometry,this.material)}}function An(e,t){const n=[...e];for(let r=0;r<e.length;r++)n[r]=t;return n}function Fn(e,t=!1){const n=new Array(e).fill(0);return t?n.map(((e,t)=>t)):n}const Vn=(e=[])=>function(e){const t=e;return{value:()=>t,fill:function(...e){return An(t,e[0]),this},range:function(e){return Fn(e),this}}}(e);Vn.fill=An,Vn.range=Fn;class Ln extends Rn{constructor({gpu:e}){super({gpu:e,name:"DeferredShadingPass",fragmentShader:"#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n#define MAX_SPOT_LIGHT_COUNT 4\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\nstruct DirectionalLight {\n    vec3 direction; \n    float intensity;\n    vec4 color;\n    mat4 shadowMapProjectionMatrix;\n};\n\nlayout (std140) uniform ubDirectionalLight {\n    DirectionalLight uDirectionalLight;\n};\nstruct SpotLight {\n    vec4 color;\n    vec3 position;\n    vec3 direction; \n    float intensity;\n    float distance;\n    float attenuation;\n    float coneCos;\n    float penumbraCos;\n    mat4 shadowMapProjectionMatrix;\n};\n\nlayout (std140) uniform ubSpotLight {\n    SpotLight uSpotLight[MAX_SPOT_LIGHT_COUNT];\n};\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nstruct IncidentLight {\n    vec3 color;\n    vec3 direction; \n    bool visible;\n    float intensity;\n};\n\nstruct IncidentSkyboxLight {\n    \n    \n    vec3 diffuseDirection;\n    float diffuseIntensity;\n    \n    vec3 specularDirection;\n    float specularIntensity;\n    float maxLodLevel;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\n\nstruct Material {\n    vec3 baseColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float roughness;\n    float metallic;\n    \n    \n    \n    \n};\n\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\n    return any(bvec2(cutoffDistance == 0., lightDistance < cutoffDistance));\n}\n\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float attenuationComponent) {\n    if (attenuationComponent > 0.) {\n        return pow(saturate(-lightDistance / cutoffDistance + 1.), attenuationComponent);\n    }\n\n    return 1.;\n}\n\nvoid getDirectionalLightIrradiance(const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight) {\n    directLight.color = directionalLight.color.xyz;\n    directLight.direction = -directionalLight.direction; \n    directLight.visible = true;\n    directLight.intensity = directionalLight.intensity;\n}\n\nstruct PointLight {\n    vec3 position;\n    vec4 color;\n    float distance;\n    float attenuation;\n};\n\nvoid getPointLightIrradiance(const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight) {\n    vec3 L = pointLight.position - geometry.position;\n    directLight.direction = normalize(L);\n\n    float lightDistance = length(L);\n    if (testLightInRange(lightDistance, pointLight.distance)) {\n        directLight.color = pointLight.color.xyz;\n        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.attenuation);\n        directLight.visible = true;\n    } else {\n        directLight.color = vec3(0.);\n        directLight.visible = false;\n    }\n}\n\nvoid getSpotLightIrradiance(const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight) {\n    \n    vec3 surfaceToLight = spotLight.position - geometry.position;\n    vec3 PtoL = normalize(surfaceToLight);\n    vec3 LtoP = -PtoL;\n    directLight.direction = PtoL;\n    directLight.intensity = spotLight.intensity;\n\n    float lightDistance = length(surfaceToLight);\n    \n    float angleCos = dot(LtoP, spotLight.direction);\n    \n    \n    \n    \n\n    if (all(\n        bvec2(\n            angleCos > spotLight.coneCos,\n            testLightInRange(lightDistance, spotLight.distance)\n        )\n    )) {\n        float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\n        directLight.color = spotLight.color.xyz;\n        directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.attenuation);\n        directLight.visible = true;\n    } else {\n        directLight.color = vec3(0.);\n        directLight.visible = false;\n    }\n}\n\nstruct SkyboxLight {\n    \n    float diffuseIntensity;\n    float specularIntensity;\n    float rotationOffset;\n    float maxLodLevel;\n    \n    \n    \n    \n    \n};\n\nvec3 calcEnvMapSampleDir(vec3 reflectDir, float rotationOffset) {\n    reflectDir.x *= -1.;\n    float c = cos(3.14 + rotationOffset);\n    float s = sin(3.14 + rotationOffset);\n    reflectDir.xz *= mat2(c, s, -s, c);\n    return reflectDir;\n}\n\nvoid getSkyboxLightIrradiance(const in SkyboxLight skyboxLight, const in GeometricContext geometry, out IncidentSkyboxLight directLight) {\n    vec3 envDir = reflect(\n        -geometry.viewDir,\n        \n        normalize(geometry.normal)\n    );\n                \n    \n    vec3 envDiffuseDir = calcEnvMapSampleDir(geometry.normal, skyboxLight.rotationOffset);\n    vec3 envSpecularDir = calcEnvMapSampleDir(envDir, skyboxLight.rotationOffset);\n\n    \n    directLight.diffuseDirection = envDiffuseDir;\n    directLight.diffuseIntensity = skyboxLight.diffuseIntensity;\n    directLight.specularDirection = envSpecularDir;\n    directLight.specularIntensity = skyboxLight.specularIntensity;\n    directLight.maxLodLevel = skyboxLight.maxLodLevel;\n}\n\nvec3 DiffuseBRDF(vec3 diffuseColor) {\n    return diffuseColor / PI;\n}\n\n        \nvec3 F_Shhlick(vec3 specularColor, vec3 H, vec3 V) {\n    return (specularColor + (1. - specularColor) * pow(1. - saturate(dot(V, H)), 5.));\n}\n\nvec3 schlick(vec3 f0, float product) {\n    return f0 + (1. - f0) * pow((1. - product), 5.);\n}\n\nfloat D_GGX(float a, float dotNH) {\n    float a2 = a * a;\n    float dotNH2 = dotNH * dotNH;\n    float d = dotNH2 * (a2 - 1.) + 1.;\n    return a2 / (PI * d * d);\n}\n\nfloat G_Smith_Schlick_GGX(float a, float dotNV, float dotNL) {\n    float k = a * a * .5 + EPSILON;\n    float gl = dotNL / (dotNL * (1. - k) + k);\n    float gv = dotNV / (dotNV * (1. - k) + k);\n    return gl * gv;\n}\n\nvec3 SpecularBRDF(const vec3 lightDirection, const in GeometricContext geometry, vec3 specularColor, float roughnessFactor) {\n    vec3 N = normalize(geometry.normal);\n    vec3 V = normalize(geometry.viewDir);\n    vec3 L = normalize(lightDirection);\n\n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    vec3 H = normalize(L + V);\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV = saturate(dot(L, V));\n    \n    float a = roughnessFactor * roughnessFactor;\n    \n    float D = D_GGX(a, dotNH);\n    float G = G_Smith_Schlick_GGX(a, dotNV, dotNL);\n    vec3 F = F_Shhlick(specularColor, V, H);\n  \n    return (F * (G * D)) / (4. * dotNL * dotNV + EPSILON);\n}\n\nvoid RE_Direct(\n    const in IncidentLight directLight,\n    const in GeometricContext geometry,\n    const in Material material,\n    inout ReflectedLight reflectedLight,\n    const in float shadow\n) {\n    \n    float dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n   \n    \n    irradiance *= PI;\n    irradiance *= directLight.intensity;\n    irradiance *= (1. - shadow);\n\n    \n    reflectedLight.directDiffuse +=\n        irradiance *\n        DiffuseBRDF(material.diffuseColor);\n    \n    \n    reflectedLight.directSpecular +=\n        irradiance *\n        SpecularBRDF(\n            directLight.direction,\n            geometry,\n            material.specularColor,\n            material.roughness\n        );\n}\n\nvoid RE_DirectSkyboxFakeIBL(\n    samplerCube cubeMap,\n    const in IncidentSkyboxLight skyboxLight,\n    const in GeometricContext geometry,\n    const in Material material,\n    inout ReflectedLight reflectedLight\n) {\n    \n    \n    \n            \n    vec3 envDiffuseColor = textureLod(\n        cubeMap,\n        skyboxLight.diffuseDirection,\n        skyboxLight.maxLodLevel\n    ).xyz;\n        \n    \n    reflectedLight.directDiffuse +=\n        material.diffuseColor\n        * envDiffuseColor\n        * skyboxLight.diffuseIntensity;\n\n    \n    \n    \n\n    \n    \n    float specularLod = log2(material.roughness * pow(2., skyboxLight.maxLodLevel));\n    vec3 envSpecularColor = textureLod(\n        cubeMap,\n        skyboxLight.specularDirection,\n        specularLod\n    ).xyz;\n\n    \n\n    vec3 fresnel = schlick(material.specularColor, max(0., dot(geometry.viewDir, geometry.normal)));\n        \n    \n    \n    \n      \n    reflectedLight.directSpecular += mix(\n        envSpecularColor * skyboxLight.specularIntensity * material.specularColor,\n        envSpecularColor * skyboxLight.specularIntensity,\n        fresnel\n    );\n    \n    \n    \n    \n}\n\nstruct Camera {\n    vec3 worldPosition;\n};\n\nstruct Surface {\n    vec3 worldNormal;\n    vec3 worldPosition;\n    vec4 diffuseColor;\n    float specularAmount;\n};\n        \nstruct Skybox {\n    samplerCube cubeMap;\n    float diffuseIntensity;\n    float specularIntensity;\n    float rotationOffset;\n    float maxLodLevel;\n};\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nconst vec2 poissonDisk[4] = vec2[](\n    vec2(-0.94201624, -0.39906216),\n    vec2(0.94558609, -0.76890725),\n    vec2(-0.094184101, -0.92938870),\n    vec2(0.34495938, 0.29387760)\n);\n\nfloat calcDirectionalLightShadowAttenuation(\n    vec3 worldPosition,\n    vec3 worldNormal,\n    vec3 lightDirection, \n    mat4 shadowMapProjectionMatrix,\n    sampler2D shadowMap,\n    float shadowBias,\n    vec4 shadowColor,\n    float shadowBlendRate\n) {\n    float NoL = max(dot(worldNormal, -lightDirection), 0.);\n    float bias = .005 * tan(acos(NoL));\n    bias = clamp(bias, .1, .5); \n    \n    vec4 lightPos = shadowMapProjectionMatrix * vec4(worldPosition, 1.);\n    vec2 uv = lightPos.xy;\n    float depthFromWorldPos = lightPos.z;\n\n    float shadowAreaSmooth = .25;\n    float shadowAreaRect =\n        \n        \n        \n        \n        \n        smoothstep(0., shadowAreaSmooth, uv.x) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.x)) *\n        smoothstep(0., shadowAreaSmooth, uv.y) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.y)) *\n        step(0., depthFromWorldPos) * (1. - step(1., depthFromWorldPos));\n\n    float visibility = 1.;\n\n    for(int i = 0; i < 4; i++) {\n        vec2 offset = poissonDisk[i] / 800.;\n        float readDepth = texture(shadowMap, uv + offset).r;\n        if(readDepth < lightPos.z - bias) {\n            visibility -= .25;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n\n    float shadow = (1. - visibility) * shadowAreaRect * shadowBlendRate;\n    return clamp(shadow, 0., 1.);\n}\n\nfloat calcSpotLightShadowAttenuation(\n    vec3 worldPosition,\n    vec3 worldNormal,\n    vec3 lightDirection, \n    mat4 lightViewProjectionTextureMatrix,\n    sampler2D shadowMap,\n    float shadowBias,\n    vec4 shadowColor,\n    float shadowBlendRate\n) {\n    float NoL = max(dot(worldNormal, -lightDirection), 0.);\n    float bias = .005 * tan(acos(NoL));\n    bias = clamp(bias, .01, .02); \n\n    vec4 lightPos = lightViewProjectionTextureMatrix * vec4(worldPosition, 1.);\n    vec2 uv = lightPos.xy / lightPos.w;\n    float depthFromWorldPos = lightPos.z / lightPos.w;\n    \n    float shadowAreaSmooth = .25;\n    float shadowAreaRect =\n        \n        \n        \n        \n        \n        smoothstep(0., shadowAreaSmooth, uv.x) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.x)) *\n        smoothstep(0., shadowAreaSmooth, uv.y) * (1. - smoothstep(1. - shadowAreaSmooth, 1., uv.y)) *\n        step(0., depthFromWorldPos) * (1. - step(1., depthFromWorldPos));\n\n    float visibility = 1.;\n\n    \n    \n    \n    for(int i = 0; i < 4; i++) {\n        vec2 offset = poissonDisk[i] / 100.;\n        float readDepth = texture(shadowMap, uv + offset).r;\n        if(readDepth < depthFromWorldPos - bias) {\n            visibility -= .25;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    float shadow = (1. - visibility) * shadowAreaRect * shadowBlendRate;\n    return clamp(shadow, 0., 1.);\n}\n\nin vec2 vUv;\n#ifdef USE_RECEIVE_SHADOW\nin vec4 vShadowMapProjectionUv;\n#endif\n\nuniform sampler2D uDirectionalLightShadowMap;\nuniform sampler2D uSpotLightShadowMap[MAX_SPOT_LIGHT_COUNT];\n\n#ifdef USE_RECEIVE_SHADOW\nuniform sampler2D uShadowMap;\nuniform float uShadowBias;\n#endif\n\nuniform sampler2D uGBufferATexture;\nuniform sampler2D uGBufferBTexture;\nuniform sampler2D uGBufferCTexture;\nuniform sampler2D uGBufferDTexture;\nuniform sampler2D uDepthTexture;\nuniform sampler2D uAmbientOcclusionTexture;\n\nuniform float uTime;\n\n       \n\nuniform Skybox uSkybox;\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n        \nlayout (location = 0) out vec4 outColor;\n\nvoid main() {\n    float eps = .0001;\n\n    vec4 resultColor = vec4(0, 0, 0, 1);\n\n    vec2 uv = vUv;\n\n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\n    GBufferB gBufferB = DecodeGBufferB(uGBufferBTexture, uv);\n    GBufferC gBufferC = DecodeGBufferC(uGBufferCTexture, uv);\n    GBufferD gBufferD = DecodeGBufferD(uGBufferDTexture, uv);\n\n    \n    \n    vec3 baseColor = gBufferA.baseColor;\n    float metallic = gBufferC.metallic;\n    float roughness = gBufferC.roughness;\n    vec3 emissiveColor = gBufferD.emissiveColor;\n    float shadingModelId = gBufferB.shadingModelId;\n    vec3 worldNormal = gBufferB.normal;\n\n    \n    float rawDepth = texture(uDepthTexture, uv).r;\n    float depth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n\n    \n    vec3 worldPosition = reconstructWorldPositionFromDepth(uv, rawDepth, uInverseViewProjectionMatrix);\n\n    \n    if (step(rawDepth, 1. - eps) < .5) {\n        outColor = vec4(baseColor, 1.);\n        \n        \n        return;\n    }\n\n    \n    \n    if (1.5 < shadingModelId && shadingModelId < 2.5) {\n        resultColor = vec4(emissiveColor, 1.);\n        \n        \n        \n        \n        \n        \n        \n        outColor = resultColor;\n        return;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    float aoRate = texture(uAmbientOcclusionTexture, uv).r;\n\n    \n    \n    \n    \n    \n    \n    \n\n    Surface surface;\n    surface.worldPosition = worldPosition;\n    surface.worldNormal = worldNormal;\n    surface.diffuseColor = vec4(baseColor, 1.);\n\n    \n    surface.specularAmount = .5;\n\n    Camera camera;\n    camera.worldPosition = uViewPosition;\n\n    \n    \n    \n\n    \n    GeometricContext geometry;\n    geometry.position = surface.worldPosition;\n    geometry.normal = surface.worldNormal;\n    geometry.viewDir = normalize(camera.worldPosition - surface.worldPosition);\n    Material material;\n    vec3 albedo = baseColor;\n    material.baseColor = albedo;\n    material.diffuseColor = mix(albedo, vec3(0.), metallic);\n    material.specularColor = mix(vec3(.04), albedo, metallic);\n    material.roughness = roughness;\n    material.metallic = metallic;\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.), vec3(0.), vec3(0.), vec3(0.));\n    \n    float opacity = 1.;\n\n    IncidentLight directLight;\n    float shadow = 0.;\n\n    \n    \n    \n\n    DirectionalLight directionalLight;\n    directionalLight.direction = uDirectionalLight.direction;\n    directionalLight.color = uDirectionalLight.color;\n    directionalLight.intensity = uDirectionalLight.intensity;\n    getDirectionalLightIrradiance(directionalLight, geometry, directLight);\n    shadow = calcDirectionalLightShadowAttenuation(\n        worldPosition,\n        surface.worldNormal,\n        uDirectionalLight.direction,\n        uDirectionalLight.shadowMapProjectionMatrix,\n        uDirectionalLightShadowMap,\n        uShadowBias,\n        vec4(0., 0., 0., 1.),\n        0.5\n    );\n    RE_Direct(directLight, geometry, material, reflectedLight, shadow);\n    \n    \n    \n    \n\n    SpotLight spotLight;\n    \n    \n    \n        getSpotLightIrradiance(uSpotLight[0], geometry, directLight);\n        shadow = calcSpotLightShadowAttenuation(\n            worldPosition,\n            surface.worldNormal,\n            uSpotLight[0].direction,\n            uSpotLight[0].shadowMapProjectionMatrix,\n            uSpotLightShadowMap[0], \n            uShadowBias,\n            vec4(0., 0., 0., 1.),\n            .5\n        );\n        RE_Direct(directLight, geometry, material, reflectedLight, shadow);\n    \n        getSpotLightIrradiance(uSpotLight[1], geometry, directLight);\n        shadow = calcSpotLightShadowAttenuation(\n            worldPosition,\n            surface.worldNormal,\n            uSpotLight[1].direction,\n            uSpotLight[1].shadowMapProjectionMatrix,\n            uSpotLightShadowMap[1], \n            uShadowBias,\n            vec4(0., 0., 0., 1.),\n            .5\n        );\n        RE_Direct(directLight, geometry, material, reflectedLight, shadow);\n    \n        getSpotLightIrradiance(uSpotLight[2], geometry, directLight);\n        shadow = calcSpotLightShadowAttenuation(\n            worldPosition,\n            surface.worldNormal,\n            uSpotLight[2].direction,\n            uSpotLight[2].shadowMapProjectionMatrix,\n            uSpotLightShadowMap[2], \n            uShadowBias,\n            vec4(0., 0., 0., 1.),\n            .5\n        );\n        RE_Direct(directLight, geometry, material, reflectedLight, shadow);\n    \n        getSpotLightIrradiance(uSpotLight[3], geometry, directLight);\n        shadow = calcSpotLightShadowAttenuation(\n            worldPosition,\n            surface.worldNormal,\n            uSpotLight[3].direction,\n            uSpotLight[3].shadowMapProjectionMatrix,\n            uSpotLightShadowMap[3], \n            uShadowBias,\n            vec4(0., 0., 0., 1.),\n            .5\n        );\n        RE_Direct(directLight, geometry, material, reflectedLight, shadow);\n    \n    \n    \n\n    SkyboxLight skyboxLight;\n    \n    skyboxLight.diffuseIntensity = uSkybox.diffuseIntensity;\n    skyboxLight.specularIntensity = uSkybox.specularIntensity;\n    skyboxLight.rotationOffset = uSkybox.rotationOffset;\n    skyboxLight.maxLodLevel = uSkybox.maxLodLevel;\n    IncidentSkyboxLight directSkyboxLight;\n    getSkyboxLightIrradiance(skyboxLight, geometry, directSkyboxLight);\n    RE_DirectSkyboxFakeIBL(uSkybox.cubeMap, directSkyboxLight, geometry, material, reflectedLight);\n\nvec3 outgoingLight =\n    reflectedLight.directDiffuse +\n    reflectedLight.directSpecular +\n    reflectedLight.indirectDiffuse +\n    reflectedLight.indirectSpecular;\nresultColor = vec4(outgoingLight, opacity);\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    resultColor.xyz *= aoRate;\n  \n    \n    resultColor.xyz += emissiveColor;\n    \n    outColor = resultColor;\n\n    \n    \n\n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n}",uniforms:[{name:Ne,type:se,value:null},{name:Ue,type:se,value:null},{name:Oe,type:se,value:null},{name:ze,type:se,value:null},{name:je,type:se,value:null},{name:"uAmbientOcclusionTexture",type:se,value:null},{name:ht,type:se,value:null},{name:ft,type:be,value:Vn.range(4).map((()=>null))},{name:xt,type:de,value:[{name:"cubeMap",type:le,value:null},{name:"diffuseIntensity",type:ge,value:0},{name:"specularIntensity",type:ge,value:0},{name:"rotationOffset",type:ge,value:0},{name:"maxLodLevel",type:ge,value:0}]}],receiveShadow:!0,renderTargetType:K,uniformBlockNames:[Pt,yt,St]})}updateSkyboxUniforms(e){this.material.uniforms.setValue(xt,[{name:"cubeMap",type:le,value:e.cubeMap},{name:"diffuseIntensity",type:ge,value:e.diffuseIntensity},{name:"specularIntensity",type:ge,value:e.specularIntensity},{name:"rotationOffset",type:ge,value:e.rotationOffset},{name:"maxLodLevel",type:ge,value:e.cubeMap.maxLodLevel}])}render(e){super.render(e)}}function _n(e,t,n){return Math.min(n,Math.max(e,t))}const In=e=>{const t=[.1*Math.PI,Math.PI*(1/3*4+.1),Math.PI*(1/3*2+.1),Math.PI*(1/3*1+.1),1.1*Math.PI,Math.PI*(1/3*5+.1)],n=1/16*Math.PI*2,r=new Array(16).fill(0).map(((e,t)=>[function(e,t,n){return e+(t-e)*Math.random()}(n*(4*t),n*(4*t+4))%(2*Math.PI),1+.0625*t,1,1])).flat(),a=new en({gpu:e,width:4,height:4,type:k,wrapS:H.Repeat,wrapT:H.Repeat});return a.update({width:4,height:4,data:new Float32Array(r)}),{samplingRotations:t,samplingDistances:[.1,.8/6*4+.1,.8/6*2+.1,.8/6*1+.1,.5,.8/6*5+.1],samplingTexture:a}};class Nn extends Rn{constructor({gpu:e}){const{samplingRotations:t,samplingDistances:n,samplingTexture:r}=In(e);super({gpu:e,fragmentShader:"#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\nuniform sampler2D uDepthTexture;\nuniform sampler2D uGBufferBTexture;\nuniform float[6] uSamplingRotations;\nuniform float[6] uSamplingDistances;\nuniform mat4 uSamplingTableMatrix;\nuniform sampler2D uSamplingTexture;\nuniform float uOcclusionSampleLength;\nuniform float uOcclusionBias;\nuniform float uOcclusionMinDistance;\nuniform float uOcclusionMaxDistance;\nuniform vec4 uOcclusionColor;\nuniform float uOcclusionPower;\nuniform float uOcclusionStrength;\nuniform float uBlendRate;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nmat2 getRotationMatrix(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nvoid main() {\n\n    float occludedAcc = 0.;\n    int samplingCount = 6;\n\n    float eps = .0001;\n\n    vec2 uv = vUv;\n    \n    \n    vec4 baseColor = vec4(1., 1., 1., 0.);\n    \n    \n    \n\n    float rawDepth = texture(uDepthTexture, uv).x;\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n    \n    vec3 worldNormal = normalize(texture(uGBufferBTexture, uv).xyz * 2. - 1.);\n    vec3 viewNormal = normalize((uTransposeInverseViewMatrix * vec4(worldNormal, 1.)).xyz);\n    \n    vec3 viewPosition = reconstructViewPositionFromDepth(\n        uv,\n        texture(uDepthTexture, uv).x,\n        uInverseProjectionMatrix\n    );\n   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    vec2 samplingTableCoord = gl_FragCoord.xy / 4.; \n    vec4 samplingTable = texture(uSamplingTexture, samplingTableCoord);\n    float samplingOffsetRad = samplingTable.x;\n    float samplingOffsetLen = samplingTable.y;\n   \n    \n    \n    \n\n    if (sceneDepth > 1. - eps) {\n        outColor = baseColor;\n        return;\n    }\n\n    for (int i = 0; i < samplingCount; i++) {\n        mat2 rot = getRotationMatrix(uSamplingRotations[i] + samplingOffsetRad);\n\n        float offsetLen = uSamplingDistances[i] * samplingOffsetLen * uOcclusionSampleLength;\n        vec3 offsetA = vec3(rot * vec2(1., 0.), 0.) * offsetLen;\n        vec3 offsetB = -offsetA;\n    \n        float rawDepthA = sampleRawDepthByViewPosition(uDepthTexture, viewPosition, uProjectionMatrix, offsetA);\n        float rawDepthB = sampleRawDepthByViewPosition(uDepthTexture, viewPosition, uProjectionMatrix, offsetB);\n\n        float depthA = perspectiveDepthToLinearDepth(rawDepthA, uNearClip, uFarClip);\n        float depthB = perspectiveDepthToLinearDepth(rawDepthB, uNearClip, uFarClip);\n\n        vec3 viewPositionA = reconstructViewPositionFromDepth(\n            uv,\n            rawDepthA,\n            uInverseProjectionMatrix\n        );\n        vec3 viewPositionB = reconstructViewPositionFromDepth(\n            uv,\n            rawDepthB,\n            uInverseProjectionMatrix\n        );\n\n        float distA = distance(viewPositionA, viewPosition);\n        float distB = distance(viewPositionB, viewPosition);\n\n        \n        \n        \n        \n        \n        \n        \n        if (distA < uOcclusionMinDistance || uOcclusionMaxDistance < distA) {\n            continue;\n        }\n        if (distB < uOcclusionMinDistance || uOcclusionMaxDistance < distB) {\n            continue;\n        }\n\n        vec3 surfaceToCameraDir = -normalize(viewPosition);\n        \n        vec3 angleDirA = normalize(viewPositionA - viewPosition);\n        vec3 angleDirB = normalize(viewPositionB - viewPosition);\n        \n        float cameraDirDotA = dot(angleDirA, surfaceToCameraDir);\n        float cameraDirDotB = dot(angleDirB, surfaceToCameraDir);\n        \n        float normalDotA = dot(viewNormal, angleDirA);\n        float normalDotB = dot(viewNormal, angleDirB);\n        \n        float clampedDotA = cameraDirDotA - min(normalDotA, 0.);\n        float clampedDotB = cameraDirDotB - min(normalDotB, 0.);\n        \n        \n        \n        \n        \n        \n        float ao = max(0., clampedDotA + clampedDotB);\n        \n\n        occludedAcc += ao;\n    }\n    \n    float aoRate = occludedAcc / float(samplingCount);\n  \n    aoRate = clamp(aoRate, 0., 1.);\n    \n    aoRate = pow(aoRate, uOcclusionPower);\n\n    vec4 color = mix(\n        baseColor,\n        uOcclusionColor,\n        clamp(aoRate * uBlendRate * uOcclusionStrength, 0., 1.)\n    );\n\n    color.a = 1.;\n    \n    outColor = color;\n\n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:Ue,type:se,value:null},{name:je,type:se,value:null},{name:"uSamplingRotations",type:ve,value:new Float32Array(t)},{name:"uSamplingDistances",type:ve,value:new Float32Array(n)},{name:"uSamplingTexture",type:se,value:r},{name:"uOcclusionSampleLength",type:ge,value:1},{name:"uOcclusionBias",type:ge,value:1},{name:"uOcclusionMinDistance",type:ge,value:1},{name:"uOcclusionMaxDistance",type:ge,value:1},{name:"uOcclusionColor",type:Te,value:new Ut(0,0,0,1)},{name:"uOcclusionPower",type:ge,value:1},{name:"uOcclusionStrength",type:ge,value:1},{name:"uBlendRate",type:ge,value:1}],uniformBlockNames:[bt,Pt]}),this.occlusionSampleLength=.121,this.occlusionBias=1e-4,this.occlusionMinDistance=.006,this.occlusionMaxDistance=.2,this.occlusionColor=new Ut(0,0,0,1),this.occlusionPower=1.85,this.occlusionStrength=.448,this.blendRate=1,this.samplingTexture=r}setSize(e,t){super.setSize(e,t),this.material.uniforms.setValue(Ze,e),this.material.uniforms.setValue(Qe,t)}render(e){this.material.uniforms.setValue("uOcclusionSampleLength",this.occlusionSampleLength),this.material.uniforms.setValue("uOcclusionBias",this.occlusionBias),this.material.uniforms.setValue("uOcclusionMinDistance",this.occlusionMinDistance),this.material.uniforms.setValue("uOcclusionMaxDistance",this.occlusionMaxDistance),this.material.uniforms.setValue("uOcclusionColor",this.occlusionColor),this.material.uniforms.setValue("uOcclusionPower",this.occlusionPower),this.material.uniforms.setValue("uOcclusionStrength",this.occlusionStrength),this.material.uniforms.setValue("uBlendRate",this.blendRate),this.material.uniforms.setValue("uSamplingTexture",this.samplingTexture),super.render(e)}}class Un extends Rn{constructor({gpu:e}){super({gpu:e,fragmentShader:"#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\nin vec2 vUv;\n\nout vec4 outColor;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nlayout (std140) uniform ubCommon {\n    float uTime;\n    vec4 uViewport;\n};\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uDepthTexture;\nuniform sampler2D uGBufferATexture;\nuniform sampler2D uGBufferBTexture;\nuniform sampler2D uGBufferCTexture;\nuniform float uBlendRate;\n\nuniform float uRayDepthBias;\nuniform float uRayNearestDistance;\nuniform float uRayMaxDistance;\nuniform float uReflectionRayThickness;\n\nuniform float uReflectionRayJitterSizeX;\nuniform float uReflectionRayJitterSizeY;\n\nuniform float uReflectionFadeMinDistance;\nuniform float uReflectionFadeMaxDistance;\n\nuniform float uReflectionScreenEdgeFadeFactorMinX;\nuniform float uReflectionScreenEdgeFadeFactorMaxX;\nuniform float uReflectionScreenEdgeFadeFactorMinY;\nuniform float uReflectionScreenEdgeFadeFactorMaxY;\n\nuniform float uReflectionRoughnessPower;\n\nuniform float uReflectionAdditionalRate;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nvoid main() {\n    float eps = .001;\n\n    int maxIterationNum = 16;\n    int binarySearchNum = 4;\n\n    \n\n    vec2 uv = vUv;\n   \n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\n    GBufferB gBufferB = DecodeGBufferB(uGBufferBTexture, uv);\n    GBufferC gBufferC = DecodeGBufferC(uGBufferCTexture, uv);\n\n    vec3 worldNormal = gBufferB.normal;\n    vec3 viewNormal = normalize((uTransposeInverseViewMatrix * vec4(worldNormal, 1.)).xyz);\n    \n    vec4 baseColor = texture(uSrcTexture, uv);\n    vec4 reflectionColor = vec4(0., 0., 0., 1.);\n\n    vec3 viewPosition = reconstructViewPositionFromDepth(\n        vUv,\n        texture(uDepthTexture, uv).r,\n        uInverseProjectionMatrix\n    );\n   \n    \n    vec3 randomDir = normalize(vec3(\n        noise(uv + .1),\n        noise(uv + .2),\n        noise(uv + .3)\n    ) * 2. - 1.);\n\n    vec3 incidentViewDir = normalize(viewPosition);\n    vec3 reflectViewDir = reflect(incidentViewDir, viewNormal);\n    vec3 rayViewDir = reflectViewDir + randomDir * gBufferC.roughness * uReflectionRoughnessPower;\n\n    vec3 rayViewOrigin = viewPosition;\n\n    float rayDeltaStep = uRayMaxDistance / float(maxIterationNum);\n\n    vec3 currentRayInView = rayViewOrigin;\n\n    bool isHit = false;\n\n    float fadeFactor = 1.;\n\n    float jitter = noise(uv + uTime) * 2. - 1.;\n\n    vec2 jitterOffset = vec2(\n        jitter * uReflectionRayJitterSizeX,\n        jitter * uReflectionRayJitterSizeY\n    );\n\n    float rawDepth = texture(uDepthTexture, uv).x;\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n    if (sceneDepth > 1. - eps) {\n        outColor = baseColor;\n        return;\n    }\n\n    for (int i = 0; i < maxIterationNum; i++) {\n        float stepLength = rayDeltaStep * (float(i) + 1.) + uRayNearestDistance;\n        currentRayInView = rayViewOrigin + vec3(jitterOffset, 0.) + rayViewDir * stepLength;\n        \n        float sampledDepth = sampleRawDepthByViewPosition(\n            uDepthTexture,\n            currentRayInView,\n            uProjectionMatrix,\n            vec3(0.)\n        );\n        vec3 sampledViewPosition = reconstructViewPositionFromDepth(uv, sampledDepth, uInverseProjectionMatrix);\n\n        vec4 currentRayInClip = uProjectionMatrix * vec4(currentRayInView, 1.);\n        currentRayInClip.xyz = currentRayInClip.xyz / currentRayInClip.w;\n\n        if (abs(currentRayInClip.x) > 1. || abs(currentRayInClip.y) > 1.) {\n            break;\n        }\n\n        float dist = sampledViewPosition.z - currentRayInView.z;\n\n        if (uRayDepthBias < dist && dist < uReflectionRayThickness) {\n            isHit = true;\n            break;\n        }\n    }\n\n    if (isHit) {\n        currentRayInView -= rayViewDir * rayDeltaStep;\n\n        float rayBinaryStep = rayDeltaStep;\n        float stepSign = 1.;\n        vec3 sampledViewPosition = viewPosition;\n\n        for (int i = 0; i < binarySearchNum; i++) {\n            rayBinaryStep *= .5 * stepSign;\n            currentRayInView += rayViewDir * rayBinaryStep;\n            float sampledRawDepth = sampleRawDepthByViewPosition(\n                uDepthTexture,\n                currentRayInView,\n                uProjectionMatrix,\n                vec3(0.)\n            );\n            sampledViewPosition = reconstructViewPositionFromDepth(\n                uv,\n                sampledRawDepth,\n                uInverseProjectionMatrix\n            );\n            float dist = sampledViewPosition.z - currentRayInView.z;\n            stepSign = uRayDepthBias < dist ? -1. : 1.;\n        }\n\n        vec4 currentRayInClip = uProjectionMatrix * vec4(currentRayInView, 1.);\n        vec2 rayUV = (currentRayInClip.xy / currentRayInClip.w) * .5 + .5;\n\n        float screenEdgeFadeFactorX = (abs(uv.x * 2. - 1.) - uReflectionScreenEdgeFadeFactorMinX) / max(uReflectionScreenEdgeFadeFactorMaxX - uReflectionScreenEdgeFadeFactorMinX, eps);\n        float screenEdgeFadeFactorY = (abs(uv.y * 2. - 1.) - uReflectionScreenEdgeFadeFactorMinY) / max(uReflectionScreenEdgeFadeFactorMaxY - uReflectionScreenEdgeFadeFactorMinY, eps);\n\n        screenEdgeFadeFactorX = 1. - clamp(screenEdgeFadeFactorX, 0., 1.);\n        screenEdgeFadeFactorY = 1. - clamp(screenEdgeFadeFactorY, 0., 1.);\n\n        float rayWithSampledPositionDistance = distance(viewPosition, sampledViewPosition);\n        float distanceFadeRate = (rayWithSampledPositionDistance - uReflectionFadeMinDistance) / max(uReflectionFadeMaxDistance - uReflectionFadeMinDistance, eps);\n        distanceFadeRate = clamp(distanceFadeRate, 0., 1.);\n        distanceFadeRate = 1. - distanceFadeRate * distanceFadeRate;\n\n        fadeFactor = distanceFadeRate * screenEdgeFadeFactorX * screenEdgeFadeFactorY;\n    \n        \n        vec4 surfaceCoefficient = vec4(\n            mix(\n                vec3(.04),\n                gBufferA.baseColor * gBufferC.metallic,\n                gBufferC.metallic\n            ),\n            1.\n        );\n        reflectionColor += texture(uSrcTexture, rayUV) * surfaceCoefficient * fadeFactor * uReflectionAdditionalRate;\n        \n        \n        \n    }\n\n    vec4 color = mix(baseColor, baseColor + reflectionColor, uBlendRate);\n    outColor = color;\n    \n    \n    \n}",uniforms:[{name:Ne,type:se,value:null},{name:Ue,type:se,value:null},{name:Oe,type:se,value:null},{name:je,type:se,value:null},{name:"uRayDepthBias",type:ge,value:0},{name:"uRayNearestDistance",type:ge,value:0},{name:"uRayMaxDistance",type:ge,value:0},{name:"uReflectionAdditionalRate",type:ge,value:0},{name:"uReflectionRayThickness",type:ge,value:0},{name:"uReflectionRayJitterSizeX",type:ge,value:0},{name:"uReflectionRayJitterSizeY",type:ge,value:0},{name:"uReflectionFadeMinDistance",type:ge,value:0},{name:"uReflectionFadeMaxDistance",type:ge,value:0},{name:"uReflectionScreenEdgeFadeFactorMinX",type:ge,value:0},{name:"uReflectionScreenEdgeFadeFactorMaxX",type:ge,value:0},{name:"uReflectionScreenEdgeFadeFactorMinY",type:ge,value:0},{name:"uReflectionScreenEdgeFadeFactorMaxY",type:ge,value:0},{name:"uReflectionRoughnessPower",type:ge,value:0},{name:"uBlendRate",type:ge,value:1}],renderTargetType:K,uniformBlockNames:[wt]}),this.rayDepthBias=.0099,this.rayNearestDistance=.13,this.rayMaxDistance=3.25,this.reflectionRayThickness=.3,this.reflectionRayJitterSizeX=.05,this.reflectionRayJitterSizeY=.05,this.reflectionFadeMinDistance=0,this.reflectionFadeMaxDistance=4.2,this.reflectionScreenEdgeFadeFactorMinX=.42,this.reflectionScreenEdgeFadeFactorMaxX=.955,this.reflectionScreenEdgeFadeFactorMinY=.444,this.reflectionScreenEdgeFadeFactorMaxY=1,this.reflectionRoughnessPower=.5,this.reflectionAdditionalRate=.355,this.blendRate=1}setSize(e,t){super.setSize(e,t),this.material.uniforms.setValue(Ze,e),this.material.uniforms.setValue(Qe,t)}render(e){this.material.uniforms.setValue("uRayDepthBias",this.rayDepthBias),this.material.uniforms.setValue("uRayNearestDistance",this.rayNearestDistance),this.material.uniforms.setValue("uRayMaxDistance",this.rayMaxDistance),this.material.uniforms.setValue("uReflectionRayThickness",this.reflectionRayThickness),this.material.uniforms.setValue("uReflectionRayJitterSizeX",this.reflectionRayJitterSizeX),this.material.uniforms.setValue("uReflectionRayJitterSizeY",this.reflectionRayJitterSizeY),this.material.uniforms.setValue("uReflectionFadeMinDistance",this.reflectionFadeMinDistance),this.material.uniforms.setValue("uReflectionFadeMaxDistance",this.reflectionFadeMaxDistance),this.material.uniforms.setValue("uReflectionScreenEdgeFadeFactorMinX",this.reflectionScreenEdgeFadeFactorMinX),this.material.uniforms.setValue("uReflectionScreenEdgeFadeFactorMaxX",this.reflectionScreenEdgeFadeFactorMaxX),this.material.uniforms.setValue("uReflectionScreenEdgeFadeFactorMinY",this.reflectionScreenEdgeFadeFactorMinY),this.material.uniforms.setValue("uReflectionScreenEdgeFadeFactorMaxY",this.reflectionScreenEdgeFadeFactorMaxY),this.material.uniforms.setValue("uReflectionAdditionalRate",this.reflectionAdditionalRate),this.material.uniforms.setValue("uReflectionRoughnessPower",this.reflectionRoughnessPower),this.material.uniforms.setValue("uBlendRate",this.blendRate),super.render(e)}}class On extends Rn{constructor({gpu:e}){super({gpu:e,name:"ToneMappingPass",fragmentShader:"#version 300 es\n\nprecision mediump float;\n\nvec4 encodePseudoHDR(vec3 color) {\n    float base = .25;\n    float l = max(max(color.r, color.g), max(color.b, base));\n    return vec4(\n        color.r / l,\n        color.g / l,\n        color.b / l,\n        base / l\n    );\n}\n\nvec4 decodePseudoHDR(vec4 encodedColor) {\n    float base = .25;\n    float rl = encodedColor.a;\n    return vec4(\n        (encodedColor.r / rl) * base,\n        (encodedColor.g / rl) * base,\n        (encodedColor.b / rl) * base,\n        rl * base\n    );\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\n\nvec3 reinhard(vec3 x) {\n    return x / (x + vec3(1.));\n}\n\nvec3 reinhardExposure(vec3 x, float exposure) {\n    float l2 = exposure * exposure;\n    return (x / (x + vec3(1.))) * (1. + (x / exposure));\n}\n\nvec3 aces(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    vec3 y = (x * (a * x + b)) / (x * (c * x + d) + e);\n    return clamp(y, 0., 1.);\n}\n\nvec3 degamma(vec3 color) {\n    return pow(color, vec3(1. / 2.2));\n}\n\nvec3 gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nvoid main() {\n    \n    \n    \n    \n\n    vec3 resultColor = texture(uSrcTexture, vUv).xyz;\n    \n    \n\n    \n    \n    resultColor = aces(resultColor);\n    \n    \n    resultColor = degamma(resultColor);\n\n    \n    if(\n        resultColor.r > 1.\n        || resultColor.g > 1.\n        || resultColor.b > 1.\n    ) {\n        resultColor = vec3(1., 0., 1.);\n    }\n    \n    outColor = vec4(resultColor, 1.);\n}",uniforms:[{name:qe,type:se,value:null}]})}render(e){super.render(e)}}class zn extends Rn{constructor({gpu:e,fragmentShader:t,uniforms:n=[],uniformBlockNames:r=[],name:a,renderTargetType:i,srcTextureEnabled:o}){super({gpu:e,fragmentShader:t,uniforms:n,uniformBlockNames:r,name:a,renderTargetType:i,srcTextureEnabled:o})}}function kn(e,t){const n=Math.floor(e/2);let r=0;const a=new Array(e).fill(0).map(((e,a)=>{const i=function(e,t){const n=e*e;return Math.exp(-t*t/(2*n))}(t,a-n);return r+=i,i}));return a.map((e=>e/r))}var jn="#version 300 es\n\nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform float uTargetWidth;\nuniform float uTargetHeight;\nuniform float[7] uBlurWeights;\nuniform float uIsHorizontal;\n\nvoid main() {\n    vec4 textureColor = texture(uSrcTexture, vUv);\n    vec4 sampleColor = vec4(0.);\n    vec2 texelSize = vec2(1. / uTargetWidth, 1. / uTargetHeight);\n\n    const int pixelNum = 7;\n    float width = floor(float(pixelNum) / 2.);\n    for(int i = 0; i < pixelNum; i++) {\n        float index = float(i) - width;\n        float weight = uBlurWeights[i];\n        \n        sampleColor += texture(\n            uSrcTexture,\n            vUv + vec2(\n                step(.5, uIsHorizontal) > .5 ? index : 0.,\n                step(.5, uIsHorizontal) > .5 ? 0. : index\n            ) * texelSize\n        ) * weight;\n    }\n    \n    outColor = sampleColor;\n    \n    \n    \n}";class Gn{constructor({gpu:e,threshold:t=0,tone:n=1,bloomAmount:r=1}){this.name="BloomPass",this.enabled=!0,this.width=1,this.height=1,this.materials=[],this.threshold=0,this.tone=1,this.bloomAmount=.8,this.threshold=t,this.tone=n,this.bloomAmount=r,this.geometry=new En({gpu:e}),this.renderTargetBlurMip4_Horizontal=new Dn({gpu:e,type:K}),this.renderTargetBlurMip4_Vertical=new Dn({gpu:e,type:K}),this.renderTargetBlurMip8_Horizontal=new Dn({gpu:e,type:K}),this.renderTargetBlurMip8_Vertical=new Dn({gpu:e,type:K}),this.renderTargetBlurMip16_Horizontal=new Dn({gpu:e,type:K}),this.renderTargetBlurMip16_Vertical=new Dn({gpu:e,type:K}),this.renderTargetBlurMip32_Horizontal=new Dn({gpu:e,type:K}),this.renderTargetBlurMip32_Vertical=new Dn({gpu:e,type:K}),this.renderTargetBlurMip64_Horizontal=new Dn({gpu:e,type:K}),this.renderTargetBlurMip64_Vertical=new Dn({gpu:e,type:K}),this.extractBrightnessPass=new zn({gpu:e,fragmentShader:"#version 300 es\n            \nprecision mediump float;\n\nout vec4 outColor;\n\nin vec2 vUv;\n\nuniform sampler2D uSrcTexture;\nuniform float uThreshold;\n\nvoid main() {\n    vec4 color = texture(uSrcTexture, vUv);\n\n    float k = uThreshold;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    vec3 b = max(color.xyz - vec3(1. + uThreshold), vec3(0.));\n    \n\n    outColor = vec4(b, 1.);\n}",uniforms:[{name:"uThreshold",type:ge,value:this.threshold}],renderTargetType:K}),this.materials.push(...this.extractBrightnessPass.materials);const a=kn(7,.92);this.horizontalBlurMaterial=new qt({vertexShader:Rn.baseVertexShader,fragmentShader:jn,uniforms:[{name:qe,type:se,value:null},{name:"uBlurWeights",type:ve,value:new Float32Array(a)},{name:"uIsHorizontal",type:ge,value:1},...Rn.commonUniforms]}),this.materials.push(this.horizontalBlurMaterial),this.verticalBlurMaterial=new qt({vertexShader:Rn.baseVertexShader,fragmentShader:jn,uniforms:[{name:qe,type:se,value:null},{name:"uBlurWeights",type:ve,value:new Float32Array(a)},{name:"uIsHorizontal",type:ge,value:0},...Rn.commonUniforms]}),this.materials.push(this.verticalBlurMaterial),this.compositePass=new zn({gpu:e,fragmentShader:"#version 300 es\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uBlur4Texture;\nuniform sampler2D uBlur8Texture;\nuniform sampler2D uBlur16Texture;\nuniform sampler2D uBlur32Texture;\nuniform sampler2D uBlur64Texture;\nuniform sampler2D uExtractTexture;\nuniform float uTone;\nuniform float uBloomAmount;\n\nvoid main() {\n    \n    vec4 blur4Color = texture(uBlur4Texture, vUv);\n    vec4 blur8Color = texture(uBlur8Texture, vUv);\n    vec4 blur16Color = texture(uBlur16Texture, vUv);\n    vec4 blur32Color = texture(uBlur32Texture, vUv);\n    vec4 blur64Color = texture(uBlur64Texture, vUv);\n    vec4 sceneColor = texture(uSrcTexture, vUv) * uTone;\n    vec4 extractColor = texture(uExtractTexture, vUv) * uTone;\n\n    vec4 blurColor = ((blur4Color + blur8Color + blur16Color + blur32Color + blur64Color) * .2) * uBloomAmount;\n\n    outColor = sceneColor + blurColor;\n\n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:qe,type:se,value:null},{name:"uBlur4Texture",type:se,value:null},{name:"uBlur8Texture",type:se,value:null},{name:"uBlur16Texture",type:se,value:null},{name:"uBlur32Texture",type:se,value:null},{name:"uTone",type:ge,value:this.tone},{name:"uBloomAmount",type:ge,value:this.bloomAmount},{name:"uExtractTexture",type:se,value:null},...Rn.commonUniforms],renderTargetType:K}),this.materials.push(...this.compositePass.materials)}get renderTargetBlurMip4(){return this.renderTargetBlurMip4_Vertical}get renderTargetBlurMip8(){return this.renderTargetBlurMip8_Vertical}get renderTargetBlurMip16(){return this.renderTargetBlurMip16_Vertical}get renderTargetBlurMip32(){return this.renderTargetBlurMip32_Vertical}get renderTargetBlurMip64(){return this.renderTargetBlurMip64_Vertical}get renderTarget(){return this.compositePass.renderTarget}setSize(e,t){this.width=e,this.height=t,this.extractBrightnessPass.setSize(e,t),this.renderTargetBlurMip4_Horizontal.setSize(this.width/4,this.height/4),this.renderTargetBlurMip4_Vertical.setSize(this.width/4,this.height/4),this.renderTargetBlurMip8_Horizontal.setSize(this.width/8,this.height/8),this.renderTargetBlurMip8_Vertical.setSize(this.width/8,this.height/8),this.renderTargetBlurMip16_Horizontal.setSize(this.width/16,this.height/16),this.renderTargetBlurMip16_Vertical.setSize(this.width/16,this.height/16),this.renderTargetBlurMip32_Horizontal.setSize(this.width/32,this.height/32),this.renderTargetBlurMip32_Vertical.setSize(this.width/32,this.height/32),this.renderTargetBlurMip64_Horizontal.setSize(this.width/64,this.height/64),this.renderTargetBlurMip64_Vertical.setSize(this.width/64,this.height/64),this.compositePass.setSize(e,t)}setRenderTarget(e,t,n){}update(){}render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,gBufferRenderTargets:i,targetCamera:o,time:s}){this.geometry.start(),this.horizontalBlurMaterial.isCompiledShader||this.horizontalBlurMaterial.start({gpu:e,attributeDescriptors:this.geometry.getAttributeDescriptors()}),this.verticalBlurMaterial.isCompiledShader||this.verticalBlurMaterial.start({gpu:e,attributeDescriptors:this.geometry.getAttributeDescriptors()}),this.extractBrightnessPass.material.uniforms.setValue("uThreshold",this.threshold),this.extractBrightnessPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:!1,targetCamera:o,time:s});const l=(e,t,r)=>{const a=this.width/r,i=this.height/r;n.setRenderTarget(e,!0),this.horizontalBlurMaterial.uniforms.setValue(qe,this.extractBrightnessPass.renderTarget.texture),this.horizontalBlurMaterial.uniforms.setValue("uTargetWidth",a),this.horizontalBlurMaterial.uniforms.setValue("uTargetHeight",a),n.renderMesh(this.geometry,this.horizontalBlurMaterial),n.setRenderTarget(t,!0),this.verticalBlurMaterial.uniforms.setValue(qe,e.texture),this.verticalBlurMaterial.uniforms.setValue("uTargetWidth",a),this.verticalBlurMaterial.uniforms.setValue("uTargetHeight",i),n.renderMesh(this.geometry,this.verticalBlurMaterial)};l(this.renderTargetBlurMip4_Horizontal,this.renderTargetBlurMip4_Vertical,4),l(this.renderTargetBlurMip8_Horizontal,this.renderTargetBlurMip8_Vertical,8),l(this.renderTargetBlurMip16_Horizontal,this.renderTargetBlurMip16_Vertical,16),l(this.renderTargetBlurMip32_Horizontal,this.renderTargetBlurMip32_Vertical,32),l(this.renderTargetBlurMip64_Horizontal,this.renderTargetBlurMip64_Vertical,64),r&&this.compositePass.material.uniforms.setValue(qe,r.texture),this.compositePass.material.uniforms.setValue("uBlur4Texture",this.renderTargetBlurMip4_Vertical.texture),this.compositePass.material.uniforms.setValue("uBlur8Texture",this.renderTargetBlurMip8_Vertical.texture),this.compositePass.material.uniforms.setValue("uBlur16Texture",this.renderTargetBlurMip16_Vertical.texture),this.compositePass.material.uniforms.setValue("uBlur32Texture",this.renderTargetBlurMip32_Vertical.texture),this.compositePass.material.uniforms.setValue("uBlur64Texture",this.renderTargetBlurMip64_Vertical.texture),this.compositePass.material.uniforms.setValue("uExtractTexture",this.extractBrightnessPass.renderTarget.texture),this.compositePass.material.uniforms.setValue("uTone",this.tone),this.compositePass.material.uniforms.setValue("uBloomAmount",this.bloomAmount),this.compositePass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:null,isLastPass:a,targetCamera:o,gBufferRenderTargets:i,time:s})}}class Hn{constructor(e,t){this.elements=new Float32Array(2),this.set(e,t)}get x(){return this.elements[0]}get y(){return this.elements[1]}set x(e){this.elements[0]=e}set y(e){this.elements[1]=e}set(e,t){return this.elements=new Float32Array([e,t]),this}static get identity(){return new Hn(0,0)}static get one(){return new Hn(1,1)}static get zero(){return new Hn(0,0)}static subVectors(e,t){return new Hn(e.x-t.x,e.y-t.y)}copy(e){return this.x=e.x,this.y=e.y,this}div(e){return this.x/=e.x,this.y/=e.y,this}log(){}}class Wn{constructor({gpu:e}){this.focusDistance=14,this.focusRange=10,this.bokehRadius=4,this.name="DepthOfFieldPass",this.enabled=!0,this.width=1,this.height=1,this.materials=[],this.geometry=new En({gpu:e}),this.circleOfConfusionPass=new zn({name:"circleOfConfusionPass",gpu:e,fragmentShader:"#version 300 es\n\n            \nprecision mediump float;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uDepthTexture;\n\nuniform float uFocusDistance;\nuniform float uFocusRange;\nuniform float uBokehRadius;\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n    float rawDepth = texture(uDepthTexture, vUv).r;\n    float eyeDepth = perspectiveDepthToEyeDepth(rawDepth, uNearClip, uFarClip);\n    \n    \n    float coc = (eyeDepth - uFocusDistance) / uFocusRange;\n    coc = clamp(coc, -1., 1.) * uBokehRadius;\n    \n    \n    \n    \n    \n    \n    \n    outColor = vec4(vec3(coc), 1.);\n}",uniforms:[{name:qe,type:se,value:null},{name:je,type:se,value:null},{name:"uFocusDistance",type:ge,value:this.focusDistance},{name:"uFocusRange",type:ge,value:this.focusRange},{name:"uBokehRadius",type:ge,value:this.bokehRadius},{name:"uCocParams",type:fe,value:zt.zero},...Rn.commonUniforms],uniformBlockNames:[Pt],renderTargetType:Z}),this.materials.push(...this.circleOfConfusionPass.materials),this.preFilterPass=new zn({gpu:e,fragmentShader:"#version 300 es\n\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uCocTexture;\nuniform vec2 uTexelSize;\n\nfloat weight(vec3 c) {\n    return 1. / (1. + max(max(c.r, c.g), c.b));\n}\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n    vec4 cocColor = texture(uCocTexture, vUv);\n \n    vec4 kernel = uTexelSize.xyxy * vec2(-.5, .5).xxyy;\n   \n    vec3 s0 = texture(uSrcTexture, vUv + kernel.xy).rgb;\n    vec3 s1 = texture(uSrcTexture, vUv + kernel.zy).rgb;\n    vec3 s2 = texture(uSrcTexture, vUv + kernel.xw).rgb;\n    vec3 s3 = texture(uSrcTexture, vUv + kernel.zw).rgb;\n    \n    float w0 = weight(s0);\n    float w1 = weight(s1);\n    float w2 = weight(s2);\n    float w3 = weight(s3);\n    \n    vec3 rawCoc0 = texture(uCocTexture, vUv + kernel.xy).rgb;\n    vec3 rawCoc1 = texture(uCocTexture, vUv + kernel.zy).rgb;\n    vec3 rawCoc2 = texture(uCocTexture, vUv + kernel.xw).rgb;\n    vec3 rawCoc3 = texture(uCocTexture, vUv + kernel.zw).rgb;\n    float coc0 = rawCoc0.r;\n    float coc1 = rawCoc1.r;\n    float coc2 = rawCoc2.r;\n    float coc3 = rawCoc3.r;\n    \n    float coc = 0.;\n    \n    float cocMin = min(min(min(coc0, coc1), coc2), coc3);\n    float cocMax = max(max(max(coc0, coc1), coc2), coc3);\n    coc = cocMax >= -cocMin ? cocMax : cocMin;\n    \n    \n    \n    \n    \n\n    \n    \n    vec3 color = s0 * w0 + s1 * w1 + s2 * w2 + s3 * w3;\n    \n    \n    \n    color /= dot(vec4(w0, w1, w2, w3), vec4(1.));\n    \n    outColor = vec4(color.rgb, coc);\n   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",uniforms:[{name:"uCocTexture",type:se,value:null},{name:"uTexelSize",type:ue,value:Hn.zero},...Rn.commonUniforms],renderTargetType:J}),this.materials.push(...this.preFilterPass.materials),this.dofBokehPass=new zn({gpu:e,fragmentShader:"#version 300 es\n\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\n\nuniform vec2 uTexelSize;\nuniform float uBokehRadius;\n\n#define BOKEH_KERNEL_MEDIUM\n\n#define KERNEL_SAMPLE_COUNT 22\nconst vec2[22] kernel = vec2[](\n\tvec2(0, 0),\n\tvec2(0.53333336, 0),\n\tvec2(0.3325279, 0.4169768),\n\tvec2(-0.11867785, 0.5199616),\n\tvec2(-0.48051673, 0.2314047),\n\tvec2(-0.48051673, -0.23140468),\n\tvec2(-0.11867763, -0.51996166),\n\tvec2(0.33252785, -0.4169769),\n\tvec2(1, 0),\n\tvec2(0.90096885, 0.43388376),\n\tvec2(0.6234898, 0.7818315),\n\tvec2(0.22252098, 0.9749279),\n\tvec2(-0.22252095, 0.9749279),\n\tvec2(-0.62349, 0.7818314),\n\tvec2(-0.90096885, 0.43388382),\n\tvec2(-1, 0),\n\tvec2(-0.90096885, -0.43388376),\n\tvec2(-0.6234896, -0.7818316),\n\tvec2(-0.22252055, -0.974928),\n\tvec2(0.2225215, -0.9749278),\n\tvec2(0.6234897, -0.7818316),\n\tvec2(0.90096885, -0.43388376)\n);\n\nfloat weight(float coc, float radius) {\n    \n    return clamp((coc - radius + 2.) / 2., 0., 1.);\n}\n\nvoid main() {\n    vec4 srcColor = texture(uSrcTexture, vUv);\n    \n    vec2 texelSize = uTexelSize;\n   \n    vec3 bgColor = vec3(0.);\n    vec3 fgColor = vec3(0.);\n    float bgWeight = 0.;\n    float fgWeight = 0.;\n \n    float coc = texture(uSrcTexture, vUv).a;\n\n    for(int k = 0; k < KERNEL_SAMPLE_COUNT; k++) {\n        vec2 o = kernel[k].xy * uBokehRadius;\n        float radius = length(o);\n        o *= texelSize;\n        vec4 s = texture(uSrcTexture, vUv + o);\n      \n        \n        \n        float bgw = weight(max(0., min(s.a, coc)), radius);\n        \n        bgColor += s.rgb * bgw;\n        bgWeight += bgw;\n       \n        \n        \n        float fgw = weight(-s.a, radius);\n        fgColor += s.rgb * fgw;\n        fgWeight += fgw;\n    }\n   \n    bgColor *= vec3(1.) / (bgWeight + (bgWeight == 0. ? 1. : 0.)); \n    fgColor *= vec3(1.) / (fgWeight + (fgWeight == 0. ? 1. : 0.));\n    \n    \n    float bgfg = min(1., fgWeight * 3.141592 / float(KERNEL_SAMPLE_COUNT));\n    \n    vec3 color = mix(bgColor, fgColor, bgfg);\n    \n    outColor = vec4(color, bgfg);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",renderTargetType:J,uniforms:[{name:"uTexelSize",type:ue,value:Hn.zero},{name:"uBokehRadius",type:ge,value:this.bokehRadius},{name:"uBokehKernel",type:me,value:[]}]}),this.materials.push(...this.dofBokehPass.materials),this.bokehBlurPass=new zn({gpu:e,fragmentShader:"#version 300 es\n\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform vec2 uTexelSize;\nuniform float uBokehRadius;\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n\n    \n    vec4 kernel = uTexelSize.xyxy * vec2(-.5, .5).xxyy;\n    vec4 s =\n        texture(uSrcTexture, vUv + kernel.xy) +\n        texture(uSrcTexture, vUv + kernel.zy) +\n        texture(uSrcTexture, vUv + kernel.xw) +\n        texture(uSrcTexture, vUv + kernel.zw);\n        \n        \n        \n        \n        \n    \n    outColor = s * .25;\n        \n\n    \n    \n}",renderTargetType:J,uniforms:[{name:"uTexelSize",type:ue,value:Hn.zero},{name:"uBokehRadius",type:ge,value:this.bokehRadius}]}),this.materials.push(...this.bokehBlurPass.materials),this.compositePass=new zn({gpu:e,fragmentShader:"#version 300 es\n\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uCocTexture;\nuniform sampler2D uDofTexture;\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n   \n    float coc = texture(uCocTexture, vUv).r;\n    vec4 dof = texture(uDofTexture, vUv);\n    \n    \n    float dofStrength = smoothstep(.1, 1., coc); \n    \n    \n    float rate = dofStrength + dof.a - dofStrength * dof.a;\n    \n    \n    vec3 color = mix(\n        sceneColor.rgb,\n        dof.rgb,\n        rate\n    );\n    \n    outColor = vec4(color, 1.);\n   \n    \n    \n    \n    \n    \n    \n    \n    \n}",renderTargetType:K,uniforms:[{name:"uCocTexture",type:se,value:null},{name:"uDofTexture",type:se,value:null}]}),this.materials.push(...this.compositePass.materials)}get renderTarget(){return this.compositePass.renderTarget}setSize(e,t){this.width=e,this.height=t,this.circleOfConfusionPass.setSize(e,t),this.preFilterPass.setSize(e/2,t/2),this.dofBokehPass.setSize(e/2,t/2),this.bokehBlurPass.setSize(e/2,t/2),this.compositePass.setSize(e,t)}setRenderTarget(e,t,n){}update(){}render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,gBufferRenderTargets:i,targetCamera:o,time:s}){this.geometry.start(),this.circleOfConfusionPass.material.uniforms.setValue("uFocusDistance",this.focusDistance),this.circleOfConfusionPass.material.uniforms.setValue("uFocusRange",this.focusRange),this.circleOfConfusionPass.material.uniforms.setValue("uBokehRadius",this.bokehRadius),this.circleOfConfusionPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.preFilterPass.material.uniforms.setValue("uCocTexture",this.circleOfConfusionPass.renderTarget.texture),this.preFilterPass.material.uniforms.setValue("uTexelSize",new Hn(1/this.circleOfConfusionPass.width,1/this.circleOfConfusionPass.height)),this.preFilterPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.dofBokehPass.material.uniforms.setValue("uTexelSize",new Hn(1/this.preFilterPass.width,1/this.preFilterPass.height)),this.dofBokehPass.material.uniforms.setValue("uBokehRadius",this.bokehRadius),this.dofBokehPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:this.preFilterPass.renderTarget,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.bokehBlurPass.material.uniforms.setValue("uTexelSize",new Hn(1/this.dofBokehPass.width,1/this.dofBokehPass.height)),this.bokehBlurPass.material.uniforms.setValue("uBokehRadius",this.bokehRadius),this.bokehBlurPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:this.dofBokehPass.renderTarget,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.compositePass.material.uniforms.setValue("uCocTexture",this.circleOfConfusionPass.renderTarget.texture),this.compositePass.material.uniforms.setValue("uDofTexture",this.bokehBlurPass.renderTarget.texture),this.compositePass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,targetCamera:o,gBufferRenderTargets:i,time:s})}}var Xn="#version 300 es\n\nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform vec2 uRadialBlurOrigin; \nuniform float uRadialBlurPassScaleBase;\nuniform float uRadialBlurPassIndex;\nuniform float uRadialBlurRayStepStrength;\n\nconst int sampleCount = 12;\n\nvoid main() {\n    vec4 resultColor = texture(uSrcTexture, vUv);\n    outColor = resultColor;\n        \n    \n    \n    vec2 blurCenter = uRadialBlurOrigin;\n   \n    \n    float passScale = pow(uRadialBlurPassScaleBase * float(sampleCount), uRadialBlurPassIndex);\n\n    vec2 currentToCenter = (blurCenter - vUv) * passScale;\n    float totalWeight = 0.;\n    vec4 destColor = vec4(0.);\n\n    \n    float strength = uRadialBlurRayStepStrength;\n    vec2 currentToCenterStep = currentToCenter * strength;\n    \n        \n    for(int i = 0; i <= sampleCount; i++) {\n        float fi = float(i);\n        float weight = (float(sampleCount) - float(i)) / float(sampleCount);\n        vec2 currentStep = currentToCenterStep * fi;\n        vec2 uv = vUv + currentStep;\n        uv = vec2(\n            clamp(uv.x, 0., 1.),\n            clamp(uv.y, 0., 1.)\n        );\n        \n        \n        \n        \n        destColor += texture(uSrcTexture, uv);\n        totalWeight += 1.;\n    }\n    \n    destColor /= totalWeight;\n  \n    outColor = destColor;\n    \n    \n    \n    \n}";class $n{constructor({gpu:e,ratio:t=.5}){this.blendRate=.65,this.passScaleBase=.2,this.rayStepStrength=.012,this.name="LightShaftPass",this.enabled=!0,this.width=1,this.height=1,this.materials=[],this.#g=null,this.#v="uRadialBlurOrigin",this.#x="uRadialBlurPassScaleBase",this.#T="uRadialBlurPassIndex",this.#w="uRadialBlurRayStepStrength",this.ratio=1,this.ratio=t,this.geometry=new En({gpu:e}),this.lightShaftDownSamplePass=new zn({gpu:e,fragmentShader:"#version 300 es\n           \nprecision mediump float;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uDepthTexture;\nuniform float uNearClip;\nuniform float uFarClip;\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n    float rawDepth = texture(uDepthTexture, vUv).r;\n    \n    float eyeDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n   \n    \n    float mask = step(.0001, 1. - rawDepth) * rawDepth;\n\n    float edgeWidth = .05; \n    float edgeMask =\n        smoothstep(0., edgeWidth, vUv.x) *\n        (1. - smoothstep(1. - edgeWidth, 1., vUv.x)) *\n        smoothstep(0., edgeWidth, vUv.y) *\n        (1. - smoothstep(1. - edgeWidth, 1., vUv.y));\n        \n    mask *= edgeMask;\n    \n    \n    outColor = vec4(vec3(mask), 1.);\n    \n}",renderTargetType:K,uniforms:[{name:je,type:se,value:null},...Rn.commonUniforms]}),this.materials.push(...this.lightShaftDownSamplePass.materials),this.blur1Pass=new zn({gpu:e,fragmentShader:Xn,renderTargetType:K,uniforms:[{name:this.#T,type:ge,value:0},{name:this.#v,type:ue,value:Hn.identity},{name:this.#x,type:ge,value:this.passScaleBase},{name:this.#w,type:ge,value:this.rayStepStrength}]}),this.materials.push(...this.blur1Pass.materials),this.blur2Pass=new zn({gpu:e,fragmentShader:Xn,renderTargetType:K,uniforms:[{name:this.#T,type:ge,value:1},{name:this.#v,type:ue,value:Hn.identity},{name:this.#x,type:ge,value:this.passScaleBase},{name:this.#w,type:ge,value:this.rayStepStrength}]}),this.materials.push(...this.blur2Pass.materials),this.blur3Pass=new zn({gpu:e,fragmentShader:Xn,renderTargetType:K,uniforms:[{name:this.#T,type:ge,value:2},{name:this.#v,type:ue,value:Hn.identity},{name:this.#x,type:ge,value:this.passScaleBase},{name:this.#w,type:ge,value:this.rayStepStrength}]}),this.materials.push(...this.blur3Pass.materials),this.compositePass=new zn({gpu:e,fragmentShader:"#version 300 es\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uLightShaftTexture;\nuniform float uBlendRate;\n\nvoid main() {\n    vec4 sceneColor = texture(uSrcTexture, vUv);\n    vec4 destColor = sceneColor;\n    vec4 lightShaftColor = texture(uLightShaftTexture, vUv);\n    float occlusion = mix(0., 1., lightShaftColor.x * lightShaftColor.x);\n\n    occlusion *= uBlendRate;\n   \n    \n    \n    outColor = vec4(vec3(occlusion), 1.);\n}",renderTargetType:K,uniforms:[{name:"uLightShaftTexture",type:se,value:null},{name:"uBlendRate",type:ge,value:this.blendRate}]}),this.materials.push(...this.compositePass.materials)}#g;#v;#x;#T;#w;get renderTarget(){return this.compositePass.renderTarget}setSize(e,t){this.width=e*this.ratio,this.height=t*this.ratio,this.lightShaftDownSamplePass.setSize(this.width,this.height),this.blur1Pass.setSize(this.width,this.height),this.blur2Pass.setSize(this.width,this.height),this.blur3Pass.setSize(this.width,this.height),this.compositePass.setSize(this.width,this.height)}setRenderTarget(e,t,n){}update(){}render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,gBufferRenderTargets:i,targetCamera:o,time:s}){this.geometry.start(),this.lightShaftDownSamplePass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s});const l=o.transformScreenPoint(this.#g.transform.position.clone().scale(1e4)),u=new Hn(.5*l.x+.5,.5*l.y+.5);this.blur1Pass.material.uniforms.setValue(this.#v,u),this.blur1Pass.material.uniforms.setValue(this.#x,this.passScaleBase),this.blur1Pass.material.uniforms.setValue(this.#w,this.rayStepStrength),this.blur2Pass.material.uniforms.setValue(this.#v,u),this.blur2Pass.material.uniforms.setValue(this.#x,this.passScaleBase),this.blur2Pass.material.uniforms.setValue(this.#w,this.rayStepStrength),this.blur3Pass.material.uniforms.setValue(this.#v,u),this.blur3Pass.material.uniforms.setValue(this.#x,this.passScaleBase),this.blur3Pass.material.uniforms.setValue(this.#w,this.rayStepStrength),this.blur1Pass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:this.lightShaftDownSamplePass.renderTarget,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.blur2Pass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:this.blur1Pass.renderTarget,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.blur3Pass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:this.blur2Pass.renderTarget,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.compositePass.material.uniforms.setValue("uLightShaftTexture",this.blur3Pass.renderTarget.read.texture),this.compositePass.material.uniforms.setValue("uBlendRate",this.blendRate),this.compositePass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,targetCamera:o,gBufferRenderTargets:i,time:s})}setDirectionalLight(e){this.#g=e}}class Yn extends Rn{constructor({gpu:e,ratio:t}){super({gpu:e,fragmentShader:"#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n#define MAX_SPOT_LIGHT_COUNT 4\n#define MARCH_COUNT 64\n#define MARCH_COUNT_F 64.\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nbool testLightInRange(const in float lightDistance, const in float cutoffDistance) {\n    return any(bvec2(cutoffDistance == 0., lightDistance < cutoffDistance));\n}\n\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance, const in float cutoffDistance, const in float attenuationComponent) {\n    if (attenuationComponent > 0.) {\n        return pow(saturate(-lightDistance / cutoffDistance + 1.), attenuationComponent);\n    }\n\n    return 1.;\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nlayout (std140) uniform ubCommon {\n    float uTime;\n    vec4 uViewport;\n};\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\nstruct SpotLight {\n    vec4 color;\n    vec3 position;\n    vec3 direction; \n    float intensity;\n    float distance;\n    float attenuation;\n    float coneCos;\n    float penumbraCos;\n    mat4 shadowMapProjectionMatrix;\n};\n\nlayout (std140) uniform ubSpotLight {\n    SpotLight uSpotLight[MAX_SPOT_LIGHT_COUNT];\n};\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uGBufferATexture;\nuniform sampler2D uDepthTexture; \nuniform sampler2D uVolumetricDepthTexture;\nuniform float uBlendRate;\n\nuniform sampler2D uSpotLightShadowMap[MAX_SPOT_LIGHT_COUNT];\nuniform float uDensityMultiplier;\nuniform float uRayStep;\nuniform float uRayJitterSizeX;\nuniform float uRayJitterSizeY;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n\nfloat calcTransmittance(\n    SpotLight spotLight,\n    sampler2D spotLightShadowMap,\n    vec3 rayPosInWorld,\n    vec3 rayPosInView,\n    float viewZFromDepth\n    \n    \n) {\n    float rate = 0.;\n    \n    vec4 rayPosInProjectionTexture = spotLight.shadowMapProjectionMatrix * vec4(rayPosInWorld, 1.);\n    vec3 projectionCoord = rayPosInProjectionTexture.xyz / rayPosInProjectionTexture.w;\n    vec3 shadowUv = projectionCoord;\n    float rayDepthInProjection = rayPosInProjectionTexture.z / rayPosInProjectionTexture.w;\n    float spotLightShadowDepth = texture(spotLightShadowMap, shadowUv.xy).r;\n    float isShadowArea =\n        step(0., shadowUv.x) * (1. - step(1., shadowUv.x)) *\n        step(0., shadowUv.y) * (1. - step(1., shadowUv.y)) *\n        step(0., shadowUv.z) * (1. - step(1., shadowUv.z));\n\n    vec3 rayToLight = spotLight.position - rayPosInWorld;\n    vec3 PtoL = normalize(rayToLight);\n    vec3 LtoP = -PtoL;\n    float lightDistance = length(rayToLight);\n    float angleCos = dot(normalize(LtoP), spotLight.direction);\n\n    float spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\n    float attenuation = punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.attenuation);\n   \n    if(abs(rayPosInView.z) < viewZFromDepth) {\n        if(all(\n            bvec4(\n                angleCos > spotLight.coneCos,\n                testLightInRange(lightDistance, spotLight.distance),\n                spotLightShadowDepth > rayDepthInProjection, \n                spotLightShadowDepth < 1. \n            )\n        )) {\n            \n            rate = (1. / MARCH_COUNT_F) * attenuation * spotEffect * isShadowArea * uDensityMultiplier;\n        }\n    }\n\n    \n    \n    \n    \n    \n    \n\n    return rate;\n}\n\nvoid main() {\n    vec2 uv = vUv;\n\n    GBufferA gBufferA = DecodeGBufferA(uGBufferATexture, uv);\n    float rawDepth = texture(uDepthTexture, uv).r;\n\n    float jitter = noise(uv + uTime) * 2. - 1.;\n    vec2 jitterOffset = vec2(\n        jitter * uRayJitterSizeX,\n        jitter * uRayJitterSizeY * uViewport.z\n    );\n\n    \n    \n    \n    float rawDepthFrustum = texture(uVolumetricDepthTexture, vUv).r;\n    float sceneDepthFrustum = perspectiveDepthToLinearDepth(rawDepthFrustum, uNearClip, uFarClip);\n    vec3 worldPositionFrustum = reconstructWorldPositionFromDepth(\n        vUv,\n        texture(uVolumetricDepthTexture, vUv).x,\n        uInverseViewProjectionMatrix\n    );\n    vec3 worldPosition = worldPositionFrustum;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    vec3 rayOrigin = worldPosition + vec3(jitterOffset, 0.);\n    \n    vec3 rayDir = normalize(rayOrigin - uViewPosition);\n    \n\n    float rayStep = 0.;\n\n    vec4 accColor = vec4(vec3(0.), 1.);\n    float transmittance = 0.; \n\n    float[MAX_SPOT_LIGHT_COUNT] fogRateArray;\n\n    vec3 rayPosInWorld;\n    vec3 rayPosInView;\n    float viewZFromDepth = perspectiveDepthToEyeDepth(rawDepth, uNearClip, uFarClip);\n \n    for(int i = 0; i < MARCH_COUNT; i++) {\n        rayStep = uRayStep * float(i);\n        rayPosInWorld = rayOrigin + rayDir * rayStep;\n        rayPosInView = (uViewMatrix * vec4(rayPosInWorld, 1.)).xyz;\n        \n            fogRateArray[0] += calcTransmittance(\n                uSpotLight[0],\n                uSpotLightShadowMap[0],\n                rayPosInWorld,\n                rayPosInView,\n                viewZFromDepth\n            );\n        \n            fogRateArray[1] += calcTransmittance(\n                uSpotLight[1],\n                uSpotLightShadowMap[1],\n                rayPosInWorld,\n                rayPosInView,\n                viewZFromDepth\n            );\n        \n            fogRateArray[2] += calcTransmittance(\n                uSpotLight[2],\n                uSpotLightShadowMap[2],\n                rayPosInWorld,\n                rayPosInView,\n                viewZFromDepth\n            );\n        \n            fogRateArray[3] += calcTransmittance(\n                uSpotLight[3],\n                uSpotLightShadowMap[3],\n                rayPosInWorld,\n                rayPosInView,\n                viewZFromDepth\n            );\n        \n    }\n   \n    \n    \n    \n    \n    vec4 fogColor = vec4(0.);\n    float fogRate = 0.;\n  \n    vec4 currentFogColor = vec4(0.); \n    float currentFogRate = 0.; \n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n       \n        currentFogRate = fogRateArray[0] * uSpotLight[0].intensity * uBlendRate;\n        fogRate += currentFogRate;\n\n        currentFogColor = currentFogRate * uSpotLight[0].color;\n        fogColor += currentFogColor;\n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n       \n        currentFogRate = fogRateArray[1] * uSpotLight[1].intensity * uBlendRate;\n        fogRate += currentFogRate;\n\n        currentFogColor = currentFogRate * uSpotLight[1].color;\n        fogColor += currentFogColor;\n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n       \n        currentFogRate = fogRateArray[2] * uSpotLight[2].intensity * uBlendRate;\n        fogRate += currentFogRate;\n\n        currentFogColor = currentFogRate * uSpotLight[2].color;\n        fogColor += currentFogColor;\n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n       \n        currentFogRate = fogRateArray[3] * uSpotLight[3].intensity * uBlendRate;\n        fogRate += currentFogRate;\n\n        currentFogColor = currentFogRate * uSpotLight[3].color;\n        fogColor += currentFogColor;\n    \n\n    \n    \n    accColor.a = fogRate; \n    \n    accColor.rgb = fogColor.xyz;\n\n    outColor = accColor;\n    \n    \n    \n    \n    \n}",uniforms:[{name:ft,type:be,value:Vn.range(4).map((()=>null))},{name:"uRayStep",type:ge,value:0},{name:"uDensityMultiplier",type:ge,value:0},{name:"uRayJitterSizeX",type:ge,value:0},{name:"uRayJitterSizeY",type:ge,value:0},{name:Ne,type:se,value:null},{name:je,type:se,value:null},{name:"uVolumetricDepthTexture",type:se,value:null},{name:"uBlendRate",type:ge,value:1}],uniformBlockNames:[wt,bt,Pt,St],renderTargetType:J}),this.rayStep=.5,this.blendRate=1,this.densityMultiplier=1,this.rayJitterSizeX=.1,this.rayJitterSizeY=.1,this.#b=[],this.ratio=.5,this.rawWidth=1,this.rawHeight=1,void 0!==t&&(this.ratio=t),this.renderTargetSpotLightFrustum=new Dn({gpu:e,type:Y,width:1,height:1,depthPrecision:X}),this.spotLightFrustumMaterial=new qt({vertexShader:`#version 300 es\n                    \n                    layout (location = 0) in vec3 ${ae.Position};\n\nuniform mat4 uWorldMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n                    \n                    // out vec4 vWorldPosition;\n                   \n                    void main() {\n                        vec4 worldPosition = ${ye} * vec4(${ae.Position}, 1.);\n                        // vWorldPosition = worldPosition;\n                        gl_Position = ${Ce} * ${Se} * worldPosition;\n                    }\n                    `,fragmentShader:"#version 300 es\n                   \n                    precision mediump float;\n\n                    // in vec4 vWorldPosition; \n                    out vec4 outColor;\n                 \n                    void main() {\n                        outColor = vec4(1., 0., 0., 1.);\n                        // outColor = vec4(vWorldPosition.xyz, 1.);\n                    }\n                    ",primitiveType:a,blendType:c,depthFuncType:l,depthWrite:!0,depthTest:!0,faceSide:N,uniforms:[{name:ye,type:ie,value:null},{name:Se,type:ie,value:null},{name:Ce,type:ie,value:null}]}),this.materials.push(this.spotLightFrustumMaterial)}#b;setSize(e,t){this.rawWidth=e,this.rawHeight=t,this.width=Math.floor(e*this.ratio),this.height=Math.floor(t*this.ratio),super.setSize(this.width,this.height),this.renderTargetSpotLightFrustum.setSize(this.rawWidth,this.rawHeight),this.material.uniforms.setValue(Ze,this.width),this.material.uniforms.setValue(Qe,this.height)}render(e){const{gpu:t,renderer:n}=e;this.spotLightFrustumMaterial.isCompiledShader||this.spotLightFrustumMaterial.start({gpu:t,attributeDescriptors:this.#b[0].shadowCamera?.visibleFrustumMesh?.geometry.getAttributeDescriptors()}),n.setRenderTarget(this.renderTargetSpotLightFrustum.write,!1,!0),this.spotLightFrustumMaterial.uniforms.setValue(Se,e.targetCamera.viewMatrix),this.spotLightFrustumMaterial.uniforms.setValue(Ce,e.targetCamera.projectionMatrix),this.#b.forEach((e=>{e.shadowCamera&&null!==e.shadowCamera.visibleFrustumMesh&&(this.spotLightFrustumMaterial.uniforms.setValue(ye,e.shadowCamera.transform.worldMatrix),n.renderMesh(e.shadowCamera.visibleFrustumMesh.geometry,this.spotLightFrustumMaterial))})),this.material.uniforms.setValue(ft,this.#b.map((e=>e.shadowMap?e.shadowMap?.read.depthTexture:null))),this.material.uniforms.setValue("uVolumetricDepthTexture",this.renderTargetSpotLightFrustum.depthTexture),this.material.uniforms.setValue("uRayStep",this.rayStep),this.material.uniforms.setValue("uDensityMultiplier",this.densityMultiplier),this.material.uniforms.setValue("uRayJitterSizeX",this.rayJitterSizeX),this.material.uniforms.setValue("uRayJitterSizeY",this.rayJitterSizeY),this.material.uniforms.setValue("uBlendRate",this.blendRate),super.render(e)}setSpotLights(e){this.#b=e}}const qn="uFogColor",Jn="uFogStrength",Kn="uFogDensity",Zn="uFogDensityAttenuation",Qn="uFogEndHeight",er="uDistanceFogStart",tr="uDistanceFogPower",nr=class extends Rn{constructor({gpu:e}){super({gpu:e,fragmentShader:"#version 300 es\n            \nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\nuniform sampler2D uSrcTexture;\nuniform sampler2D uLightShaftTexture;\nuniform sampler2D uVolumetricLightTexture;\nuniform float uBlendRate;\nuniform sampler2D uDepthTexture;\nuniform vec4 uFogColor;\nuniform float uFogStrength;\nuniform float uFogDensity;\nuniform float uFogDensityAttenuation;\nuniform float uFogEndHeight;\nuniform float uDistanceFogStart;\nuniform float uDistanceFogPower;\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nfloat calcFogHeightExp(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float densityY0, float densityAttenuation) {\n    vec3 v = cameraPositionInWorld - objectPositionInWorld;\n    float l = length(v);\n    float ret;\n    float tmp = l * densityY0 * exp(-densityAttenuation * objectPositionInWorld.y);\n    if(v.y == 0.) {\n        ret = exp(-tmp);\n    } else {\n        float kvy = densityAttenuation * v.y;\n        ret = exp(tmp / kvy * (exp(-kvy) - 1.));\n    }\n    \n    return 1. - ret;\n}\n\nfloat calcFogHeightUniform(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float fogDensity, float fogEndHeight) {\n    vec3 v = cameraPositionInWorld - objectPositionInWorld;\n    float t;\n    if(objectPositionInWorld.y < fogEndHeight) {\n        if(cameraPositionInWorld.y > fogEndHeight) {\n            t = (fogEndHeight - objectPositionInWorld.y) / v.y;\n        } else {\n            t = 1.;\n        }\n    } else {\n        if(cameraPositionInWorld.y < fogEndHeight) {\n            t = (cameraPositionInWorld.y - fogEndHeight) / v.y;\n        } else {\n            t = 0.;\n        }\n    }\n    float dist = length(v) * t;\n    float fog = exp(-dist * fogDensity);\n    return 1. - fog;\n}\n\nfloat calcDistanceFog(vec3 objectPositionInWorld, vec3 cameraPositionInWorld, float expStart, float expPower) {\n    float dist = length(cameraPositionInWorld - objectPositionInWorld);\n    dist = max(0., dist - expStart);\n    return max(0., 1. - exp(-dist * expPower));\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    \n    vec4 sceneColor = texture(uSrcTexture, uv);\n    vec4 destColor = sceneColor;\n    vec4 lightShaftColor = texture(uLightShaftTexture, uv);\n    vec4 volumetricLightColor = texture(uVolumetricLightTexture, uv);\n    \n    float occlusion = saturate(lightShaftColor.x);\n\n    float rawDepth = texture(uDepthTexture, uv).x;\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n    vec3 viewPositionFromDepth = reconstructViewPositionFromDepth(uv, rawDepth, uInverseProjectionMatrix);\n    vec3 worldPositionFromDepth = reconstructWorldPositionFromDepth(uv, rawDepth, uInverseViewProjectionMatrix);\n \n    float constantFogScale = .1;\n  \n    vec3 fogColor = uFogColor.xyz;\n    \n    \n    \n    float rate = constantFogScale * max(0., 1. - exp(-uFogStrength * -viewPositionFromDepth.z));\n   \n    \n    float fogRate = calcFogHeightExp(worldPositionFromDepth, uViewPosition, uFogDensity, uFogDensityAttenuation);\n    fogRate *= 1. - step(1. - .0001, rawDepth);\n    \n    fogRate += calcDistanceFog(worldPositionFromDepth, uViewPosition, uDistanceFogStart, uDistanceFogPower);\n    \n    fogRate = saturate(fogRate);\n\n    \n    vec4 applyOcclusionColor = sceneColor * (1. - occlusion);\n    outColor = vec4(mix(applyOcclusionColor.xyz, fogColor.xyz, fogRate), 1.);\n    \n    \n    \n    \n    \n    outColor += vec4(volumetricLightColor.xyz, 0.);\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}",renderTargetType:K,uniforms:[{name:qn,type:Te,value:Ut.white},{name:je,type:se,value:null},{name:nr.lightShaftTextureUniformName,type:se,value:null},{name:nr.volumetricLightTextureUniformName,type:se,value:null},{name:Jn,type:ge,value:.01},{name:Kn,type:ge,value:.023},{name:Zn,type:ge,value:.45},{name:Qn,type:ge,value:1},{name:er,type:ge,value:20},{name:tr,type:ge,value:.1}],uniformBlockNames:[Pt]}),this.fogColor=Ut.white,this.fogColor=Ut.white,this.fogStrength=.01,this.fogDensity=.023,this.fogDensityAttenuation=.45,this.fogEndHeight=1,this.distanceFogStart=20,this.distanceFogPower=.1}setLightShaftMap(e){this.material.uniforms.setValue(nr.lightShaftTextureUniformName,e.read.texture)}setVolumetricLightMap(e){this.material.uniforms.setValue(nr.volumetricLightTextureUniformName,e.read.texture)}render(e){this.material.uniforms.setValue(qn,this.fogColor),this.material.uniforms.setValue(Jn,this.fogStrength),this.material.uniforms.setValue(Kn,this.fogDensity),this.material.uniforms.setValue(Zn,this.fogDensityAttenuation),this.material.uniforms.setValue(Qn,this.fogEndHeight),this.material.uniforms.setValue(er,this.distanceFogStart),this.material.uniforms.setValue(tr,this.distanceFogPower),super.render(e)}};let rr=nr;rr.lightShaftTextureUniformName="uLightShaftTexture",rr.volumetricLightTextureUniformName="uVolumetricLightTexture";const ar="uChromaticAberrationScale";class ir extends Rn{constructor({gpu:e}){super({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform float uTargetWidth;\nuniform float uTargetHeight;\nuniform float uChromaticAberrationScale;\n\nconst int ARRAY_NUM = 5;\n\nconst vec3 chromaticAberrationFilter[ARRAY_NUM] = vec3[](\n    vec3(0., 0., .5),\n    vec3(0., .25, .5),\n    vec3(0., .5, 0.),\n    vec3(.5, .25, 0.),\n    vec3(.5, 0., 0.)\n);\n\nvoid main() {\n    vec2 uv = vUv;\n    vec2 centerUv = vUv * 2. - 1.; \n    outColor = vec4(0.);\n    for(int i = 0; i < ARRAY_NUM; i++) {\n        vec2 tempUv = centerUv * (1. - uChromaticAberrationScale * (float(i) + 1.) / float(ARRAY_NUM));\n        tempUv = (tempUv + 1.) * .5; \n        vec3 mask = chromaticAberrationFilter[i];\n        vec4 color = texture(uSrcTexture, tempUv);\n        outColor += vec4(color.rgb * mask, 1.);\n    }\n}",uniforms:[{name:ar,type:ge,value:.015}]}),this.chromaticAberrationScale=.015}setSize(e,t){super.setSize(e,t),this.material.uniforms.setValue(Ze,e),this.material.uniforms.setValue(Qe,t)}render(e){this.material.uniforms.setValue(ar,this.chromaticAberrationScale),super.render(e)}}const or="uVignetteRadius",sr="uVignettePower",lr="uBlendRate";class ur extends Rn{constructor({gpu:e}){super({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform float uVignetteRadius;\nuniform float uVignettePower;\nuniform float uBlendRate;\nuniform float uAspect;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec2 centerUv = vUv * 2. - 1.; \n    centerUv.x *= uAspect;\n    float d = dot(centerUv, centerUv);\n    float factor = pow(min(1., d / uVignetteRadius), uVignettePower) * uBlendRate;\n    vec3 vignetteColor = vec3(0.);\n    vec3 srcColor = texture(uSrcTexture, uv).rgb;\n    outColor = vec4(mix(srcColor, vignetteColor, factor), 1.);\n}",uniforms:[{name:or,type:ge,value:2.5},{name:sr,type:ge,value:1.4},{name:lr,type:ge,value:1},{name:et,type:ge,value:1}]}),this.vignetteRadius=2.5,this.vignettePower=1.4,this.blendRate=1}setSize(e,t){super.setSize(e,t),this.material.uniforms.setValue(et,e/t)}render(e){this.material.uniforms.setValue(or,this.vignetteRadius),this.material.uniforms.setValue(sr,this.vignettePower),this.material.uniforms.setValue(lr,this.blendRate),super.render(e)}}class cr{constructor({gpu:e,threshold:t,stretch:n,intensity:r,color:a,verticalScale:i,horizontalScale:o}){this.name="StreakPass",this.enabled=!0,this.width=1,this.height=1,this.threshold=.9,this.stretch=.5,this.color=Ut.white,this.intensity=.6,this.verticalScale=1.5,this.horizontalScale=1.25,this.materials=[],this.downSamplePasses=[],this.upSamplePasses=[],this.halfHeight=0,this.threshold=void 0!==t?t:this.threshold,this.color=void 0!==a?a:this.color,this.stretch=void 0!==n?n:this.stretch,this.intensity=void 0!==r?r:this.intensity,this.verticalScale=void 0!==i?i:this.verticalScale,this.horizontalScale=void 0!==o?o:this.horizontalScale,this.geometry=new En({gpu:e}),this.prefilterPass=new zn({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform vec2 uTexelSize;\nuniform float uThreshold;\nuniform float uVerticalScale;\n\nvoid main() {\n    \n    float vScale = uVerticalScale;\n    float dy = uTexelSize.y * vScale / 2.;\n    vec2 uv = vUv;\n    vec4 srcColor = texture(uSrcTexture, uv);\n    vec3 c0 = texture(uSrcTexture, vec2(uv.x, uv.y - dy)).rgb;\n    vec3 c1 = texture(uSrcTexture, vec2(uv.x, uv.y + dy)).rgb;\n    vec3 c = (c0 + c1) / 2.;\n    \n    \n    float br = max(c.r, max(c.g, c.b)); \n    \n    \n    \n    c *= max(0., br - uThreshold) / max(br, 1e-5);\n    \n    outColor = vec4(c, 1.);\n}",uniforms:[{name:qe,type:se,value:null},{name:tt,type:ue,value:Hn.zero},{name:"uThreshold",type:ge,value:this.threshold},{name:"uVerticalScale",type:ge,value:this.verticalScale},...Rn.commonUniforms],renderTargetType:K}),this.materials.push(...this.prefilterPass.materials);const s=[2,4,8,16,32].map((t=>{const n=new zn({name:`DownSampleMip${t}Pass`,gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uPrevTexture;\nuniform vec2 uTexelSize;\nuniform float uHorizontalScale;\n\nvoid main() {\n    vec2 uv = vUv;\n\n    \n    float hScale = uHorizontalScale;\n    \n    float dx = uTexelSize.x * hScale;\n\n    float u0 = uv.x - dx * 5.;\n    float u1 = uv.x - dx * 3.;\n    float u2 = uv.x - dx * 1.;\n    float u3 = uv.x + dx * 1.;\n    float u4 = uv.x + dx * 3.;\n    float u5 = uv.x + dx * 5.;\n    \n    vec4 c0 = texture(uPrevTexture, vec2(u0, uv.y));\n    vec4 c1 = texture(uPrevTexture, vec2(u1, uv.y));\n    vec4 c2 = texture(uPrevTexture, vec2(u2, uv.y));\n    vec4 c3 = texture(uPrevTexture, vec2(u3, uv.y));\n    vec4 c4 = texture(uPrevTexture, vec2(u4, uv.y));\n    vec4 c5 = texture(uPrevTexture, vec2(u5, uv.y));\n  \n    \n    \n    vec4 c = (c0 + c1 + c2 + c3 + c4 + c5) / 6.0;\n    \n    outColor = vec4(c.xyz, 1.);\n}",uniforms:[{name:tt,type:ue,value:Hn.zero},{name:"uPrevTexture",type:se,value:null},{name:"uHorizontalScale",type:ge,value:this.horizontalScale},...Rn.commonUniforms]});return this.materials.push(...n.materials),{pass:n,downScale:t}}));this.downSamplePasses=s.map((({pass:e,downScale:t},n)=>({pass:e,prevPass:0===n?this.prefilterPass:s[n-1].pass,downScale:t})));const l=Vn.range(5).map(((t,n)=>{const r=new zn({name:`UpSampleMip${n}Pass`,gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uDownSampleTexture;\nuniform sampler2D uPrevTexture; \nuniform float uStretch;\n\nvoid main() {\n    vec2 uv = vUv;\n\n    \n    vec3 c0 = texture(uPrevTexture, uv).xyz * .25;\n    vec3 c1 = texture(uPrevTexture, uv).xyz * .5;\n    vec3 c2 = texture(uPrevTexture, uv).xyz * .25;\n\n    vec3 c3 = texture(uDownSampleTexture, uv).xyz;\n\n    \n    vec3 c = mix(c3, c0 + c1 + c2, uStretch);\n    outColor = vec4(c.xyz, 1.);\n    \n    \n    \n}",uniforms:[{name:"uDownSampleTexture",type:se,value:null},{name:"uPrevTexture",type:se,value:null},{name:"uStretch",type:ge,value:this.stretch},...Rn.commonUniforms]});return this.materials.push(...r.materials),{pass:r}}));this.upSamplePasses=l.map((({pass:e},t)=>({pass:e,prevPass:0===t?this.downSamplePasses[this.downSamplePasses.length-1].pass:l[t-1].pass,downSamplePass:this.downSamplePasses[this.downSamplePasses.length-1-t].pass}))),this.compositePass=new zn({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform vec4 uColor;\nuniform float uIntensity;\nuniform sampler2D uSrcTexture;\nuniform sampler2D uStreakTexture;\n\nvoid main() {\n    vec2 uv = vUv;\n\n    \n    vec3 c0 = texture(uStreakTexture, uv).xyz * .25;\n    vec3 c1 = texture(uStreakTexture, uv).xyz * .5;\n    vec3 c2 = texture(uStreakTexture, uv).xyz * .25;\n    \n    vec3 c3 = texture(uSrcTexture, uv).xyz;\n  \n    \n    float multiplier = 5.;\n    vec3 cf = (c0 + c1 + c2) * uColor.xyz * uIntensity * multiplier;\n   \n    \n    outColor = vec4(cf + c3, 1.);\n    \n    \n    \n}",uniforms:[{name:"uStreakTexture",type:se,value:null},{name:"uColor",type:Te,value:this.color},{name:"uIntensity",type:ge,value:this.intensity},...Rn.commonUniforms],renderTargetType:K}),this.materials.push(...this.compositePass.materials)}get renderTarget(){return this.compositePass.renderTarget}setSize(e,t){this.width=e,this.height=t,this.halfHeight=Math.floor(this.height/2),this.prefilterPass.setSize(this.width,this.halfHeight),this.compositePass.setSize(this.width,this.height)}setRenderTarget(e,t,n){}update(){}render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,gBufferRenderTargets:i,targetCamera:o,time:s}){this.geometry.start(),this.prefilterPass.material.uniforms.setValue("uTexelSize",new Hn(1/this.width,1/this.height)),this.prefilterPass.material.uniforms.setValue("uThreshold",this.threshold),this.prefilterPass.material.uniforms.setValue("uVerticalScale",this.verticalScale),this.prefilterPass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s}),this.downSamplePasses.forEach((({pass:r,prevPass:a,downScale:l})=>{const u=Math.floor(this.width/l);r.setSize(u,this.halfHeight),r.material.uniforms.setValue(tt,new Hn(1/u,1/this.halfHeight)),r.material.uniforms.setValue("uPrevTexture",a.renderTarget.texture),r.material.uniforms.setValue("uHorizontalScale",this.horizontalScale),r.render({gpu:e,camera:t,renderer:n,prevRenderTarget:null,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s})})),this.upSamplePasses.forEach((({pass:r,prevPass:a,downSamplePass:l})=>{r.setSize(l.width,l.height),r.material.uniforms.setValue("uPrevTexture",a.renderTarget.texture),r.material.uniforms.setValue("uDownSampleTexture",l.renderTarget.texture),r.material.uniforms.setValue("uStretch",this.stretch),r.render({gpu:e,camera:t,renderer:n,prevRenderTarget:null,isLastPass:!1,targetCamera:o,gBufferRenderTargets:i,time:s})})),this.compositePass.material.uniforms.setValue("uStreakTexture",this.upSamplePasses[this.upSamplePasses.length-1].pass.renderTarget.texture),this.compositePass.material.uniforms.setValue("uColor",this.color),this.compositePass.material.uniforms.setValue("uIntensity",this.intensity),this.compositePass.render({gpu:e,camera:t,renderer:n,prevRenderTarget:r,isLastPass:a,targetCamera:o,gBufferRenderTargets:i,time:s})}}function hr(e,t){t.directionalLight&&t.directionalLight.shadowMap&&e.uniforms.setValue(ht,t.directionalLight.shadowMap.read.depthTexture),e.uniforms.setValue(ft,t.spotLights.map((e=>e.shadowMap?e.shadowMap.read.depthTexture:null)))}class fr{constructor({name:e}){this.parent=null,this.children=[],this.name=e}get childCount(){return this.children.length}get hasChild(){return this.childCount>0}addChild(e){this.children.push(e),e.parent=this}updateMatrix(){throw"should implementation"}}class mr extends fr{constructor({index:n,...r}){super(r),this.offsetMatrix=t.identity,this.#P=t.identity,this.#y=t.identity,this.#S=t.identity,this.position=e.zero,this.rotation=Lt.zero,this.scale=e.one,this.index=n}#P;#y;#S;get boneOffsetMatrix(){return this.#y}get poseMatrix(){return this.#P}get jointMatrix(){return this.#S}calcBoneOffsetMatrix(e){this.#P=e?t.multiplyMatrices(e.poseMatrix,this.offsetMatrix):this.offsetMatrix,this.#y=this.#P.clone().invert(),this.children.forEach((e=>e.calcBoneOffsetMatrix(this)))}calcJointMatrix(e){this.offsetMatrix=t.multiplyMatrices(t.translationMatrix(this.position),this.rotation.rawMatrix,t.scalingMatrix(this.scale)),this.#S=e?t.multiplyMatrices(e.jointMatrix,this.offsetMatrix):this.offsetMatrix,this.children.forEach((e=>e.calcJointMatrix(this)))}traverse(e){e(this),this.children.forEach((t=>{t.traverse(e)}))}}class dr extends hn{constructor({bones:e,debugBoneView:t,...n}){super({...n,actorType:y,autoGenerateDepthMaterial:!0}),this.boneCount=0,this.boneOffsetMatrices=[],this.#C=[],this.#D=[],this.#B=null,this.#M=null,this.#E=[],this.#R=1,this.boneLines=null,this.bonePoints=null,this.bones=e,this.debugBoneView=!!t,this.bones.traverse((e=>{this.boneCount++,this.#D[e.index]=e}))}#C;#D;#B;#M;#E;#R;start({gpu:e}){if(this.bones.calcBoneOffsetMatrix(),this.boneOffsetMatrices=this.getBoneOffsetMatrices(),this.#M=!!this.mainMaterial.gpuSkinning,this.#B=new en({gpu:e,width:1,height:1,type:k}),this.materials.forEach((e=>{e.uniforms=new $t(e.uniforms.data,this.generateSkinningUniforms()),e.isSkinning=!0,e.gpuSkinning=this.#M,e.jointNum=this.boneCount})),this.mainMaterial.depthUniforms=new $t(this.mainMaterial.depthUniforms.data,this.generateSkinningUniforms()),super.start({gpu:e}),this.debugBoneView&&this.#A({gpu:e}),this.#E&&this.#M){const e=[];this.#E.forEach(((t,n)=>{const r=t.getAllKeyframesValue();e[n]=[],r.forEach(((t,r)=>{e[n][r]=[],t.forEach((t=>{const a=t.target.index;switch(e[n][r][a]||(e[n][r][a]={bone:t.target}),t.key){case Pr.translation:case Pr.rotation:case Pr.scale:e[n][r][a][t.key]=t.frameValue;break;default:throw"invalid target path"}}))}))}));const n=[];e.forEach(((e,r)=>{n[r]=[],e.forEach((e=>{e.forEach((e=>{const{translation:t,rotation:n,scale:r,bone:a}=e,i=this.#D[a.index];t&&(i.position=t),n&&(i.rotation=Lt.fromMatrix4(n.toMatrix4())),r&&(i.scale=r)})),this.bones.calcJointMatrix();const a=this.boneOffsetMatrices,i=this.getBoneJointMatricesWithBone(),o=a.map(((e,n)=>t.multiplyMatrices(i[n].matrix,e)));n[r].push(...o)}))}));const r=[...n].flat(2),a=this.#E.reduce(((e,t)=>e+t.frameCount),0),i=this.#R,o=this.boneCount*a,s=Math.ceil(o/i),l=new Float32Array([...r,...new Array(i*s-o).fill(0).map((()=>t.identity))].map((e=>[...e.elements])).flat()),u=4;this.#B.update({width:i*u,height:s,data:l}),this.materials.forEach((e=>e.uniforms.setValue(Ye,a))),this.depthMaterial&&this.depthMaterial.uniforms.setValue(Ye,a)}}update(e){super.update(e);const{time:n}=e;if(this.bones.calcJointMatrix(),this.boneLines&&this.bonePoints){const e=this.#D.map((e=>[...e.jointMatrix.position.elements]));this.boneLines.geometry.updateAttribute(ae.Position,new Float32Array(e.flat())),this.bonePoints.geometry.updateAttribute(ae.Position,new Float32Array(e.flat()))}if(this.#M)this.materials.forEach((e=>e.uniforms.setValue(Je,n))),this.depthMaterial&&this.depthMaterial.uniforms.setValue(Je,n),this.materials.forEach((e=>e.uniforms.setValue(We,this.#B))),this.depthMaterial&&this.depthMaterial.uniforms.setValue(We,this.#B);else{const e=this.boneOffsetMatrices,n=this.getBoneJointMatricesWithBone(),r=e.map(((e,r)=>t.multiplyMatrices(n[r].matrix,e))),a=this.#R,i=Math.ceil(this.boneCount/a),o=a*i-this.boneCount,s=new Float32Array([...r,...new Array(o).fill(0).map((()=>t.identity))].map((e=>[...e.elements])).flat()),l=4;this.#B&&this.#B.update({width:a*l,height:i,data:s}),this.materials.forEach((e=>e.uniforms.setValue(We,this.#B))),this.depthMaterial&&this.depthMaterial.uniforms.setValue(We,this.#B)}}generateSkinningUniforms(){return[{name:We,type:se,value:null},{name:$e,type:xe,value:this.#R},...this.#M?[{name:Xe,type:xe,value:this.boneCount},{name:Ye,type:xe,value:0}]:[]]}getBoneOffsetMatrices(){const e=[];return this.bones.traverse((t=>{const n=t.boneOffsetMatrix.clone();e.push(n)})),e}getBoneJointMatrices(){const e=[];return this.bones.traverse((t=>{const n=t.jointMatrix.clone();e.push(n)})),e}getBoneJointMatricesWithBone(){const e=[];return this.bones.traverse((t=>{const n=t.jointMatrix.clone();e.push({bone:t,matrix:n})})),e}#A({gpu:e}){const t=e=>{e.hasChild&&e.children.forEach((n=>{const r=n;this.#C.push(e.index,r.index),t(r)}))};t(this.bones),this.boneLines=new hn({geometry:new cn({gpu:e,attributes:[new Jt({name:ae.Position,data:new Float32Array(new Array(3*this.#D.length).fill(0)),size:3,usageType:ne})],indices:this.#C,drawCount:this.#C.length}),material:new qt({vertexShader:`#version 300 es\n                \n                layout (location = 0) in vec3 ${ae.Position};\n                \n                uniform mat4 ${ye};\n                uniform mat4 ${Se};\n                uniform mat4 ${Ce};\n                \n                void main() {\n                    gl_Position = ${Ce} * ${Se} * ${ye} * vec4(${ae.Position}, 1.);\n                }\n                `,fragmentShader:"#version 300 es\n                \n                precision mediump float;\n                \n                out vec4 outColor;\n                \n                void main() {\n                    outColor = vec4(0, 1., 0, 1.);\n                }\n                ",primitiveType:r,blendType:h,depthWrite:!1,depthTest:!1})}),this.bonePoints=new hn({geometry:new cn({gpu:e,attributes:[new Jt({name:ae.Position.toString(),data:new Float32Array(new Array(3*this.#D.length).fill(0)),size:3,usageType:ne})],drawCount:this.#D.length}),material:new qt({vertexShader:`#version 300 es\n               \n                layout (location = 0) in vec3 ${ae.Position};\n                \n                uniform mat4 ${ye};\n                uniform mat4 ${Se};\n                uniform mat4 ${Ce};\n                \n                void main() {\n                    gl_Position = ${Ce} * ${Se} * ${ye} * vec4(${ae.Position}, 1.);\n                    gl_PointSize = 6.;\n                }\n                `,fragmentShader:"#version 300 es\n                \n                precision mediump float;\n                \n                out vec4 outColor;\n                \n                void main() {\n                    outColor = vec4(1, 0., 0, 1.);\n                }\n                ",primitiveType:n,blendType:h,depthWrite:!1,depthTest:!1})}),this.addChild(this.boneLines),this.addChild(this.bonePoints)}setAnimationClips(e){this.#E=e}}class pr{constructor({name:e,keyframes:t}){this.currentTime=0,this.currentFrame=0,this.loop=!1,this.isPlaying=!1,this.speed=1,this.fps=30,this.onUpdateProxy=null,this._keyframes=[],this.name=e,this._keyframes=t,this.frameCount=Math.max(...t.map((({frameCount:e})=>e)))}get keyframes(){return this._keyframes}play(){this.currentTime=0,this.isPlaying=!0}update(e){if(!this.isPlaying)return;const t=1/this.fps;this.currentTime+=e*this.speed;const n=t*this.frameCount;if(this.currentTime>n){if(!this.loop)return this.currentFrame=this.frameCount,void(this.currentTime=n);this.currentTime%=n}if(this.currentFrame=Math.floor(this.currentTime/t),this.onUpdateProxy){const e=this._keyframes.map((e=>({target:e.target,key:e.key,frameValue:e.getFrameValue(this.currentFrame)})));this.onUpdateProxy(e)}else this._keyframes.forEach((e=>{const t=e.getFrameValue(this.currentFrame);switch(e.key){case"translation":const n=t;e.target.transform?e.target.transform.position=n:e.target.position=n;break;case"rotation":const r=t,a=Lt.fromMatrix4(r.toMatrix4());e.target.transform?e.target.transform.rotation=a:e.target.rotation=a;break;case"scale":const i=t;e.target.transform?e.target.transform.scale=i:e.target.scale=i;break;default:throw"invalid animation keyframes key"}}))}getAllKeyframesValue(){return new Array(this.frameCount).fill(0).map(((e,t)=>this._keyframes.map((e=>({target:e.target,key:e.key,frameValue:e.getFrameValue(t)})))))}}class gr{constructor(e,t,n,r){this.elements=new Float32Array(4),this.set(e,t,n,r)}get x(){return this.elements[0]}get y(){return this.elements[1]}get z(){return this.elements[2]}get w(){return this.elements[3]}set(e,t,n,r){return this.elements=new Float32Array([e,t,n,r]),this}toEulerRadian(){const e=this.x,t=this.y,n=this.z,r=this.w,a=r*e,i=r*t,o=r*n,s=e*e,l=e*t,u=e*n,c=t*t,h=t*n,f=n*n;return{x:-Math.atan2(2*(l-o),1-2*(s+f)),y:(m=2*(h+a),m>=1?Math.PI/2:m<=-1?-Math.PI/2:Math.asin(m)),z:-Math.atan2(2*(u-i),1-2*(s+c))};var m}toEulerDegree(){const e=this.toEulerRadian();return{x:180*e.x/Math.PI,y:180*e.y/Math.PI,z:180*e.z/Math.PI}}toMatrix4(){const e=this.x,n=this.y,r=this.z,a=this.w,i=a*e,o=a*n,s=a*r,l=e*e,u=e*n,c=e*r,h=n*n,f=n*r,m=r*r;return new t(1-2*(h+m),2*(u-s),2*(c+o),0,2*(u+s),1-2*(l+m),2*(f-i),0,2*(c-o),2*(f+i),1-2*(l+h),0,0,0,0,1)}static identity(){return new gr(0,0,0,1)}}class vr{get data(){return this._data}constructor({target:e,type:t,key:n,interpolation:r,data:a,start:i,end:o,frameCount:s,frames:l}){switch(this.target=e,this.key=n,this.interpolation=r,this.type=t,this._data=a,this.start=i,this.end=o,this.frameCount=s,this.frames=l,this.type){case Q:this.elementSize=3;break;case ee:this.elementSize=4;break;default:throw"[AnimationKeyframes.getFrameValue] invalid type"}}getFrameValue(t){const n=new Array(this.elementSize).fill(0).map(((e,n)=>{switch(this.interpolation){case br.LINEAR:return this._data[t*this.elementSize+n];case br.STEP:return this._data[n];default:throw"invalid interp"}}));switch(this.type){case Q:return new e(n[0],n[1],n[2]);case ee:return new gr(n[0],n[1],n[2],n[3]);default:throw"[AnimationKeyframes.getFrameValue] invalid type"}}}var xr="#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\n#pragma ATTRIBUTES\n\n#pragma APPEND_ATTRIBUTES\n\nlayout (std140) uniform ubCommon {\n    float uTime;\n    vec4 uViewport;\n};\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\n#if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n\nmat4 calcSkinningMatrix(mat4 jointMat0, mat4 jointMat1, mat4 jointMat2, mat4 jointMat3, vec4 boneWeights) {\n    mat4 skinMatrix =\n         jointMat0 * aBoneWeights.x +\n         jointMat1 * aBoneWeights.y +\n         jointMat2 * aBoneWeights.z +\n         jointMat3 * aBoneWeights.w;\n    return skinMatrix;\n}\n\nmat4 getJointMatrix(sampler2D jointTexture, uint jointIndex, int colNum) {\n    \n    int colIndex = int(mod(float(jointIndex), float(colNum)));\n    \n    int rowIndex = int(floor(float(jointIndex) / float(colNum)));\n    mat4 jointMatrix = mat4(\n        \n        \n        \n        \n        \n        \n        texelFetch(jointTexture, ivec2(colIndex * 4 + 0, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 1, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 2, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 3, rowIndex), 0)\n    );\n    return jointMatrix;\n}\n\nmat4 getJointMatrixGPUSkinning(\n    sampler2D jointTexture,\n    uint jointIndex,\n    int jointNum,\n    int currentSkinIndex,\n    int colNum,\n    int totalFrameCount,\n    float time,\n    float timeOffset\n) {\n    \n    \n    \n    \n    \n\n    float offset = float(int(mod(floor(time + timeOffset), float(totalFrameCount))) * jointNum);\n    \n    int colIndex = int(mod(float(jointIndex) + offset, float(colNum)));\n    \n    int rowIndex = int(floor(float(jointIndex) + offset / float(colNum)));\n\n    mat4 jointMatrix = mat4(\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 0, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 1, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 2, rowIndex), 0),\n        texelFetch(jointTexture, ivec2(colIndex * 4 + 3, rowIndex), 0)\n    );\n    return jointMatrix;\n}\n\n#endif\n\nout vec2 vUv;\nout vec3 vLocalPosition;\nout vec3 vWorldPosition;\nout vec3 vNormal;\n\n#ifdef USE_NORMAL_MAP\nout vec3 vTangent;\nout vec3 vBinormal;               \n#endif\n#ifdef USE_RECEIVE_SHADOW\nout vec4 vShadowMapProjectionUv;\n#endif\n#ifdef USE_VERTEX_COLOR\nout vec4 vVertexColor;\n#endif\n\n#pragma APPEND_UNIFORMS\n        \n#ifdef USE_RECEIVE_SHADOW\nuniform mat4 uShadowMapProjectionMatrix;\n#endif\n#if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n\nuniform sampler2D uJointTexture;\n\nuniform int uBoneCount;\nuniform int uJointTextureColNum;\nuniform int uTotalFrameCount;\n#endif\n\nmat4 getRotationXMat(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat4(\n        \n        \n        \n        \n        \n        \n        1., 0., 0., 0.,\n        0., c, s, 0.,\n        0., -s, c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\nmat4 getRotationYMat(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat4(\n        \n        \n        \n        \n        \n        \n        c, 0., -s, 0.,\n        0., 1., 0., 0.,\n        s, 0., c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\nmat4 getRotationZMat(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat4(\n        \n        \n        \n        \n        \n        \n        c, s, 0., 0.,\n        -s, c, 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    );\n}\n\nmat4 getTranslationMat(vec3 p) {\n    return mat4(\n        \n        \n        \n        \n        \n        \n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        p.x, p.y, p.z, 1.\n    );\n}\n\nmat4 getScalingMat(vec3 s) {\n    return mat4(\n        \n        s.x, 0., 0., 0.,\n        0., s.y, 0., 0.,\n        0., 0., s.z, 0.,\n        0., 0., 0., 1.\n    );\n}\n\nmat4 getLookAtMat(vec3 lookAt, vec3 p) {\n    vec3 f = normalize(lookAt - p);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    return mat4(\n        r.x, r.y, r.z, 0.,\n        u.x, u.y, u.z, 0.,\n        f.x, f.y, f.z, 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid main() {\n\n    #pragma BEGIN_MAIN\n\n    vec4 localPosition = vec4(aPosition, 1.);\n\n    #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n    mat4 skinMatrix = mat4(\n        1., 0., 0., 0.,\n        0., 1., 0., 0.,\n        0., 0., 1., 0.,\n        0., 0., 0., 1.\n    );\n  \n#ifdef USE_SKINNING_GPU\n    float fps = 30.;\n    mat4 jointMatrix0 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[0], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\n    mat4 jointMatrix1 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[1], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\n    mat4 jointMatrix2 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[2], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\n    mat4 jointMatrix3 = getJointMatrixGPUSkinning(uJointTexture, aBoneIndices[3], uBoneCount, 0, uJointTextureColNum, uTotalFrameCount, uTime * fps, aInstanceAnimationOffset);\n    skinMatrix = calcSkinningMatrix(\n        jointMatrix0,\n        jointMatrix1,\n        jointMatrix2,\n        jointMatrix3,\n        aBoneWeights\n    );\n#endif\n#ifdef USE_SKINNING_CPU\n    mat4 jointMatrix0 = getJointMatrix(uJointTexture, aBoneIndices[0], uJointTextureColNum);\n    mat4 jointMatrix1 = getJointMatrix(uJointTexture, aBoneIndices[1], uJointTextureColNum);\n    mat4 jointMatrix2 = getJointMatrix(uJointTexture, aBoneIndices[2], uJointTextureColNum);\n    mat4 jointMatrix3 = getJointMatrix(uJointTexture, aBoneIndices[3], uJointTextureColNum);\n    skinMatrix = calcSkinningMatrix(\n        jointMatrix0,\n        jointMatrix1,\n        jointMatrix2,\n        jointMatrix3,\n        aBoneWeights\n    );\n#endif\n\n    localPosition = skinMatrix * localPosition;\n#endif\n    \n    #pragma LOCAL_POSITION_POST_PROCESS\n\n    \n    vUv = aUv;\n    vLocalPosition = aPosition;\n\n    mat4 worldMatrix = uWorldMatrix;\n    \n#ifdef USE_INSTANCING\n    mat4 instanceTranslation = getTranslationMat(aInstancePosition);\n    mat4 instanceScaling = getScalingMat(aInstanceScale.xyz);\n    mat4 instanceRotationX = getRotationXMat(aInstanceRotation.x);\n    mat4 instanceRotationY = getRotationYMat(aInstanceRotation.y);\n    mat4 instanceRotationZ = getRotationZMat(aInstanceRotation.z);\n    mat4 instanceRotation =\n        instanceRotationY *\n        instanceRotationX *\n        instanceRotationZ;\n    \n\n#ifdef USE_INSTANCE_LOOK_DIRECTION\n    instanceRotation = getLookAtMat(aInstancePosition + aInstanceVelocity * 1000., aInstancePosition);\n#endif\n\n    #pragma INSTANCE_TRANSFORM_PRE_PROCESS\n\n    worldMatrix = uWorldMatrix * instanceTranslation * instanceRotation * instanceScaling;\n#endif\n\n    vec4 worldPosition = worldMatrix * localPosition;\n\n    #pragma WORLD_POSITION_POST_PROCESS\n\n    vWorldPosition = worldPosition.xyz;\n\n    mat3 normalMatrix;\n\n#ifdef USE_NORMAL_MAP\n    #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n        #ifdef USE_INSTANCING\n            normalMatrix = mat3(transpose(inverse(worldMatrix))) * mat3(skinMatrix);\n        #else\n            normalMatrix = mat3(uNormalMatrix) * mat3(skinMatrix);\n        #endif\n    #else\n        #ifdef USE_INSTANCING\n            normalMatrix = mat3(transpose(inverse(worldMatrix)));\n        #else\n            normalMatrix = mat3(uNormalMatrix);\n        #endif\n    #endif\n    vNormal = normalMatrix * aNormal;\n    vTangent = normalMatrix * aTangent;\n    vBinormal = normalMatrix * aBinormal;\n#else\n    #if defined(USE_SKINNING_GPU) || defined(USE_SKINNING_CPU)\n        #ifdef USE_INSTANCING\n            normalMatrix = mat3(transpose(inverse(worldMatrix))) * mat3(skinMatrix);\n        #else\n            normalMatrix = mat3(uNormalMatrix);\n        #endif\n    #else\n        #ifdef USE_INSTANCING\n            normalMatrix = mat3(transpose(inverse(worldMatrix)));\n        #else\n            normalMatrix = mat3(uNormalMatrix);\n        #endif\n    #endif\n    vNormal = normalMatrix * aNormal;\n#endif\n\n    #ifdef USE_RECEIVE_SHADOW\n    vShadowMapProjectionUv = uShadowMapProjectionMatrix * worldPosition;\n#endif\n    \n\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n    \n#if defined(USE_INSTANCING) && defined(USE_VERTEX_COLOR)\n    vVertexColor = aInstanceVertexColor;\n#endif\n\n    #pragma END_MAIN\n}",Tr="#version 300 es\n\nprecision mediump float;\n\n#pragma DEFINES\n\nuniform vec4 uColor;\nuniform sampler2D uDiffuseMap; \nuniform vec2 uDiffuseMapUvScale;\n\n#ifdef USE_ALPHA_TEST\nuniform float uAlphaTestThreshold;\n#endif\n\nin vec2 vUv;\n\n#ifdef USE_VERTEX_COLOR\nin vec4 vVertexColor;\n#endif\n\nout vec4 outColor;\n\n#ifdef USE_ALPHA_TEST\nvoid checkAlphaTest(float value, float threshold) {\n    if(value < threshold) {\n        discard;\n    }\n}\n#endif\n\nvoid main() {\n    vec2 uv = vUv * uDiffuseMapUvScale;\n   \n    vec4 diffuseMapColor = texture(uDiffuseMap, uv);\n    \n    vec4 diffuseColor = vec4(0.);\n\n#ifdef USE_VERTEX_COLOR\n    diffuseColor = vVertexColor * uColor * diffuseMapColor;\n#else\n    diffuseColor = uColor * diffuseMapColor;\n#endif   \n\n    float alpha = diffuseColor.a; \n\n#ifdef USE_ALPHA_TEST\n    checkAlphaTest(alpha, uAlphaTestThreshold);\n#endif    \n\n    outColor = vec4(1., 1., 1., 1.);\n}";class wr extends qt{constructor({diffuseColor:e,diffuseMap:t,diffuseMapUvScale:n,diffuseMapUvOffset:r,normalMap:a,normalMapUvScale:o,normalMapUvOffset:s,metallic:l,roughness:c,emissiveColor:h,vertexShaderModifier:f={},shadingModelId:m=i,uniforms:d=[],...p}={}){super({...p,name:"GBufferMaterial",vertexShaderModifier:f,uniforms:[...[{name:"uDiffuseColor",type:Te,value:e||Ut.white},{name:"uDiffuseMap",type:se,value:t||null},{name:"uDiffuseMapUvScale",type:ue,value:n||Hn.one},{name:"uDiffuseMapUvOffset",type:ue,value:r||Hn.one},{name:Ge,type:ge,value:l||0},{name:He,type:ge,value:c||0},{name:"uNormalMap",type:se,value:a||null},{name:"uNormalMapUvScale",type:ue,value:o||Hn.one},{name:"uNormalMapUvOffset",type:ue,value:s||Hn.one},{name:"uEmissiveColor",type:Te,value:h||Ut.black},{name:ke,type:xe,value:m}],...d||[]],depthUniforms:[{name:"uDiffuseMap",type:se,value:t||null},{name:"uDiffuseMapUvScale",type:ue,value:Hn.one},{name:"uDiffuseMapUvOffset",type:ue,value:Hn.one}],useNormalMap:!!a,depthTest:!0,depthWrite:!1,depthFuncType:u,uniformBlockNames:[wt,bt,Pt]})}start({gpu:e,attributeDescriptors:t=[]}){this.vertexShader=xr,this.fragmentShader="#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\n#define MAX_SPOT_LIGHT_COUNT 4\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\nuniform vec4 uDiffuseColor;\nuniform sampler2D uDiffuseMap; \nuniform vec2 uDiffuseMapUvScale;\nuniform float uSpecularAmount;\nuniform samplerCube uEnvMap;\nuniform float uAmbientAmount;\nuniform float uMetallic;\nuniform float uRoughness;\nuniform vec4 uEmissiveColor;\nuniform int uShadingModelId;\n\n#pragma APPEND_UNIFORMS\n\nvec3 reinhard(vec3 x) {\n    return x / (x + vec3(1.));\n}\n\nvec3 reinhardExposure(vec3 x, float exposure) {\n    float l2 = exposure * exposure;\n    return (x / (x + vec3(1.))) * (1. + (x / exposure));\n}\n\nvec3 aces(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    vec3 y = (x * (a * x + b)) / (x * (c * x + d) + e);\n    return clamp(y, 0., 1.);\n}\n\nvec3 degamma(vec3 color) {\n    return pow(color, vec3(1. / 2.2));\n}\n\nvec3 gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\n#ifdef USE_NORMAL_MAP\nuniform sampler2D uNormalMap;\nuniform float uNormalStrength;\n#endif\n\n#ifdef USE_ALPHA_TEST\nuniform float uAlphaTestThreshold;\n#endif\n\nstruct DirectionalLight {\n    vec3 direction;\n    float intensity;\n    vec4 color;\n};\nuniform DirectionalLight uDirectionalLight;\n\nstruct Surface {\n    vec3 worldNormal;\n    vec3 worldPosition;\n    vec4 diffuseColor;\n    \n};\n\nstruct Camera {\n    vec3 worldPosition;\n};\n\nin vec2 vUv;\nin vec3 vNormal;\n\n#ifdef USE_NORMAL_MAP\nin vec3 vTangent;\nin vec3 vBinormal;\n#endif\n\nin vec3 vWorldPosition;\n\n#ifdef USE_VERTEX_COLOR\nin vec4 vVertexColor;\n#endif\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n\n#ifdef USE_NORMAL_MAP\nvec3 calcNormal(vec3 normal, vec3 tangent, vec3 binormal, sampler2D normalMap, vec2 uv) {\n    vec3 n = normalize(normal);\n    vec3 t = normalize(tangent);\n    vec3 b = normalize(binormal);\n    mat3 tbn = mat3(t, b, n);\n    vec3 nt = texture(normalMap, uv).xyz;\n    nt = nt * 2. - 1.;\n\n    \n    vec3 resultNormal = normalize(tbn * nt);\n    \n    \n    \n\n    return resultNormal;\n}\n#endif\n\nvoid checkAlphaTest(float value, float threshold) {\n    if(value < threshold) {\n        discard;\n    }\n}\n\nlayout (location = 0) out vec4 outGBufferA;\nlayout (location = 1) out vec4 outGBufferB;\nlayout (location = 2) out vec4 outGBufferC;\nlayout (location = 3) out vec4 outGBufferD;\n\nvoid main() {\n    vec4 resultColor = vec4(0, 0, 0, 1);\n    \n    vec2 uv = vUv * uDiffuseMapUvScale;\n  \n    vec4 diffuseMapColor = texture(uDiffuseMap, uv);\n    vec4 diffuseColor = uDiffuseColor * diffuseMapColor;\n   \n    vec3 worldNormal = vNormal;\n   \n#ifdef USE_NORMAL_MAP\n    worldNormal = calcNormal(vNormal, vTangent, vBinormal, uNormalMap, uv);\n#else\n    worldNormal = normalize(vNormal);\n#endif\n\n#ifdef USE_VERTEX_COLOR\n    diffuseColor *= vVertexColor;\n#endif\n\n    \n\n    Surface surface;\n    surface.worldPosition = vWorldPosition;\n    surface.worldNormal = worldNormal;\n    surface.diffuseColor = diffuseColor;\n    \n    resultColor = surface.diffuseColor;\n    \n#ifdef USE_ALPHA_TEST\n    checkAlphaTest(resultColor.a, uAlphaTestThreshold);\n#endif\n\n    resultColor.rgb = gamma(resultColor.rgb);\n\n    outGBufferA = EncodeGBufferA(resultColor.rgb);\n    outGBufferB = EncodeGBufferB(worldNormal, uShadingModelId);\n    outGBufferC = EncodeGBufferC(uMetallic, uRoughness);\n    outGBufferD = EncodeGBufferD(uEmissiveColor.rgb);\n}",this.depthFragmentShader=Tr,super.start({gpu:e,attributeDescriptors:t})}}const br={LINEAR:"LINEAR",STEP:"STEP",CATMULLROMSPLINE:"CATMULLROMSPLINE",CUBICSPLINE:"CUBICSPLINE"},Pr={translation:"translation",rotation:"rotation",scale:"scale"};async function yr({gpu:n,dir:r,path:a}){const i=e=>r+e,o=i(a),s=await fetch(o),l=await s.json(),u=new Nt({}),c={KHR_materials_emissive_strength:!1};l.extensionsUsed&&l.extensionsUsed.forEach((e=>{if("KHR_materials_emissive_strength"===e)c.KHR_materials_emissive_strength=!0}));const h=[];l.textures&&await Promise.all(l.textures.map((async({source:e,sampler:t})=>{const n=l.images[e].uri,r=l.samplers[t].minFilter,a=l.samplers[t].magFilter,o=l.samplers[t].wrapS,s=l.samplers[t].wrapT,u=r?Zt(r):void 0,c=a?Zt(a):void 0,h=o?Qt(o):void 0,f=s?Qt(s):void 0;return{img:await tn(i(n)),minFilter:u,magFilter:c,wrapS:h,wrapT:f}}))).then((e=>{e.forEach((({img:e,minFilter:t,magFilter:r,wrapS:a,wrapT:i})=>{const o=new en({gpu:n,img:e,minFilter:t,magFilter:r,wrapS:a,wrapT:i});h.push(o)}))}));const f=[],m=await Promise.all(l.buffers.map((async e=>{const t=e.uri.match("^data:application/octet-stream;base64.*")?e.uri:i(e.uri),n=await fetch(t),r=await n.arrayBuffer();return{byteLength:e.byteLength,binBufferData:r}}))),d=e=>{const t=l.bufferViews[e.bufferView],{binBufferData:n}=m[t.buffer];return n.slice(t.byteOffset,t.byteOffset+t.byteLength)},p=(n,r=null)=>{const a=l.nodes[n],i=new mr({name:a.name,index:n});f[n]=i;const o=t.multiplyMatrices(t.translationMatrix(a.translation?new e(a.translation[0],a.translation[1],a.translation[2]):e.zero),a.rotation?new gr(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]).toMatrix4():gr.identity().toMatrix4(),t.scalingMatrix(a.scale?new e(a.scale[0],a.scale[1],a.scale[2]):e.one));return i.offsetMatrix=o,r&&r.addChild(i),a.children&&a.children.forEach((e=>p(e,i))),i},g=(e,t)=>{const r=l.nodes[e],a=void 0!==r.children;if(void 0!==r.mesh){const i=(({meshIndex:e,skinIndex:t=null})=>{let r=new Float32Array,a=new Float32Array,i=new Float32Array,o=new Float32Array,s=new Float32Array,u=new Uint16Array,f=new Uint16Array,m=new Float32Array,g=null;const v=l.meshes[e],x=[];if(v.primitives.forEach((e=>{const t={attributes:[],indices:null};if(Object.keys(e.attributes).forEach((n=>{const r=n,a=e.attributes[r];null!=a&&t.attributes.push({attributeName:r,accessor:l.accessors[a]})})),Object.hasOwn(e,"material")&&x.push(e.material),e.indices&&(t.indices={accessor:l.accessors[e.indices]}),t.attributes.forEach((e=>{const{attributeName:t,accessor:n}=e,o=d(n);switch(t){case"POSITION":r=new Float32Array(o);break;case"NORMAL":a=new Float32Array(o);break;case"TANGENT":i=new Float32Array(o);break;case"TEXCOORD_0":s=new Float32Array(o);break;case"JOINTS_0":f=new Uint16Array(new Uint8Array(o));break;case"WEIGHTS_0":m=new Float32Array(o);break;default:throw"[loadGLTF.createMesh] invalid attribute name"}})),t.indices){const{accessor:e}=t.indices,n=d(e);u=new Uint16Array(n)}})),null!==t){const e=l.skins[t];g=p(e.joints[0])}const T=s.map(((e,t)=>t%2==0?e:1-e));if(i)o=new Float32Array(cn.createBinormals(Array.from(a),Array.from(i)));else{const e=cn.createTangentsAndBinormals(Array.from(a));i=new Float32Array(e.tangents),o=new Float32Array(e.binormals)}const w=new cn({gpu:n,attributes:[new Jt({name:"aPosition",data:r,size:3}),new Jt({name:"aUv",data:T,size:2}),new Jt({name:"aNormal",data:a,size:3}),...g?[new Jt({name:"aBoneIndices",data:f,size:4}),new Jt({name:"aBoneWeights",data:m,size:4})]:[],new Jt({name:"aTangent",data:new Float32Array(i),size:3}),new Jt({name:"aBinormal",data:new Float32Array(o),size:3})],indices:Array.from(u),drawCount:u.length}),b=x.map((e=>{const t=l.materials[e],n=!!t.pbrMetallicRoughness.baseColorTexture,r=!!t.normalTexture,a=n?h[t.pbrMetallicRoughness.baseColorTexture.index]:null,i=r?h[t.normalTexture.index]:null;let o=Ut.black;if(t.hasOwnProperty("emissiveFactor"))if(c.KHR_materials_emissive_strength){const e=t.extensions.KHR_materials_emissive_strength.emissiveStrength;o=Ut.fromArray(t.emissiveFactor).multiplyScalar(e)}else o=Ut.fromArray(t.emissiveFactor);return new wr({diffuseMap:a,diffuseColor:t.pbrMetallicRoughness.baseColorFactor?Ut.fromArray(t.pbrMetallicRoughness.baseColorFactor):Ut.white,normalMap:i,metallic:t.pbrMetallicRoughness.metallicFactor,roughness:t.pbrMetallicRoughness.roughnessFactor,emissiveColor:o})}));return g?new dr({geometry:w,bones:g}):new hn({geometry:w,materials:b})})({meshIndex:r.mesh,skinIndex:null!==r.skin&&void 0!==r.skin?r.skin:null});return f[e]=i,t.addChild(i),void(a&&r.children.forEach((e=>g(e,i))))}if(a)if(f[e])r.children.forEach((e=>g(e,t)));else{const n=new Nt({});t.addChild(n),f[e]=n,r.children.forEach((e=>g(e,n)))}};l.scenes.forEach((e=>{e.nodes.forEach((e=>{g(e,u)}))}));if(l.animations&&l.animations.length>0){const e=l.animations.map((e=>{const t=e.channels.map((t=>{const n=e.samplers[t.sampler],r=l.accessors[n.input],a=d(r),i=new Float32Array(a),o=l.accessors[n.output],s=d(o),u=new Float32Array(s);switch(t.target.path){case Pr.translation:case Pr.scale:case Pr.rotation:break;default:throw"invalid key type"}let c;switch(t.target.path){case Pr.rotation:c=ee;break;case Pr.translation:case Pr.scale:c=Q;break;default:throw"invalid channel taget path"}return new vr({target:f[t.target.node],key:t.target.path,interpolation:n.interpolation,data:u,start:Math.min(...r.min),end:Math.min(...r.max),frames:i,frameCount:r.count,type:c})}));return new pr({name:e.name,keyframes:t})}));u.animator.setAnimationClips(e)}return u}var Sr="#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nuniform vec2 uTiling;\nuniform sampler2D uTextureCol0;\nuniform vec2 uTextureCol0UvOffset;\nuniform sampler2D uTextureCol1;\nuniform vec2 uTextureCol1UvOffset;\nuniform sampler2D uTextureCol2;\nuniform vec2 uTextureCol2UvOffset;\nuniform sampler2D uTextureCol3;\nuniform vec2 uTextureCol3UvOffset;\nuniform sampler2D uTextureCol4;\nuniform vec2 uTextureCol4UvOffset;\nuniform sampler2D uTextureCol5;\nuniform vec2 uTextureCol5UvOffset;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\n    vec2 tiling = uTiling;\n    vec4 color0 = calcTextureAreaColor(uTextureCol0, vUv, tiling, uTextureCol0UvOffset);\n    vec4 color1 = calcTextureAreaColor(uTextureCol1, vUv, tiling, uTextureCol1UvOffset);\n    vec4 color2 = calcTextureAreaColor(uTextureCol2, vUv, tiling, uTextureCol2UvOffset);\n    vec4 color3 = calcTextureAreaColor(uTextureCol3, vUv, tiling, uTextureCol3UvOffset);\n    vec4 color4 = calcTextureAreaColor(uTextureCol4, vUv, tiling, uTextureCol4UvOffset);\n    vec4 color5 = calcTextureAreaColor(uTextureCol5, vUv, tiling, uTextureCol5UvOffset);\n    outColor = color0 + color1 + color2 + color3 + color4 + color5;\n}";const Cr="depthTexture",Dr="gBufferATexture",Br="gBufferBTexture",Mr="gBufferCTexture",Er="gBufferDTexture",Rr="directionalLightShadowMap",Ar="spotLightShadowMap",Fr="ambientOcclusionTexture",Vr="deferredShadingTexture",Lr="ssrTexture",_r="lightShaftTexture",Ir="volumetricLightTexture",Nr="fogTexture",Ur="depthOfFieldTexture",Or="bloomBlurMip4Texture",zr="bloomBlurMip8Texture",kr="bloomBlurMip16Texture",jr="bloomBlurMip32Texture",Gr="bloomBlurMip64Texture",Hr="bloomTexture";class Wr{#F=Hn.zero;#V=Hn.zero;#L=Hn.zero;#_=Hn.zero;#I=Hn.zero;#N=!1;#U=!1;#O=!1;#z=0;#k=0;get isUp(){return!this.#U}get isPressed(){return this.#N}get isDown(){return this.#U}get isReleased(){return this.#O}get deltaNormalizedInputPosition(){return this.#_}get normalizedInputPosition(){return this.#I}constructor(){}start(){throw"[AbstractInputController] should implementation 'start' method."}setSize(e,t){this.#z=e,this.#k=t}update(){throw"[AbstractInputController] should implementation 'update' method."}updateInternal({inputPosition:e,isDown:t}){this.#j(t),this.#G(e)}#j(e){const t=this.isDown;return this.#U=e,!t&&this.isDown?(this.#N=!0,void(this.#O=!1)):!t&&this.isDown?(this.#N=!1,void(this.#O=!1)):t&&!this.isDown?(this.#N=!1,void(this.#O=!0)):(this.#N=!1,void(this.#O=!1))}#G(e){this.isUp||this.isPressed&&(this.#V.copy(e),this.#F.copy(this.#V),this.#L.set(0,0),this.#_.set(0,0)),this.#F.copy(this.#V),this.#V.copy(e);const t=Hn.subVectors(this.#V,this.#F);this.#L.copy(t);const n=Math.min(this.#z,this.#k);this.#_.set(this.#L.x/n,this.#L.y/n),this.#I.set(this.#V.x/this.#z,this.#V.y/this.#k)}clearInputPositions(){this.#F.set(-1/0,-1/0),this.#V.set(-1/0,-1/0),this.#L.set(-1/0,-1/0),this.#_.set(-1/0,-1/0)}dispose(){}}class Xr extends kt{constructor({gpu:e,buffers:t}){super(),this.gpu=e;const{gl:n}=e;this.transformFeedback=n.createTransformFeedback(),this.bind();for(let r=0;r<t.length;r++)n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,r,t[r]);n.bindBuffer(n.ARRAY_BUFFER,null),this.unbind()}get glObject(){return this.transformFeedback}bind(){const{gl:e}=this.gpu;e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,this.glObject)}unbind(){const{gl:e}=this.gpu;e.bindTransformFeedback(e.TRANSFORM_FEEDBACK,null)}}var $r="#version 300 es\n\nvoid main() { }";class Yr{constructor({gpu:e,attributes:t,drawCount:n,vertexShader:r,varyings:a,uniforms:i=[],uniformBlockNames:o=[]}){this.attributes=[],this.uniformBlockNames=[],this.outputs=[];const{gl:s}=e,l=a.map((({name:e})=>e));this.shader=new Gt({gpu:e,vertexShader:r,fragmentShader:$r,transformFeedbackVaryings:l}),this.uniforms=new $t(i),this.uniformBlockNames=o,this.drawCount=n,t.forEach(((e,t)=>{e.location=t,e.divisor=0})),this.attributes=t,this.vertexArrayObject=new un({gpu:e,attributes:t});const u=a.map((({data:e,usageType:t})=>{const n=s.createBuffer();return s.bindBuffer(s.ARRAY_BUFFER,n),s.bufferData(s.ARRAY_BUFFER,e,ln(s,t||ne)),s.bindBuffer(s.ARRAY_BUFFER,null),this.outputs.push({buffer:n}),n}));this.transformFeedback=new Xr({gpu:e,buffers:u})}}const qr=65536;class Jr{constructor(e,t,n){this.gpu=e,this.channelNum=2,this.duration=n,this.node=null,this.gainNode=null,this.volume=1;const r=new AudioContext,a=r.createBuffer(this.channelNum,r.sampleRate*n,r.sampleRate),{gl:i}=e,o=new Float32Array(this.channelNum*qr),s=new Yr({gpu:e,attributes:[],varyings:[{name:"vSound",data:o,usageType:re}],vertexShader:t,uniforms:[{name:"uBlockOffset",type:ge,value:0},{name:"uSampleRate",type:ge,value:0}],drawCount:qr}),l=Math.ceil(r.sampleRate*n/qr),u=a.getChannelData(0),c=a.getChannelData(1);s.uniforms.setValue("uSampleRate",r.sampleRate);for(let h=0;h<l;h++){const t=h*qr/r.sampleRate;s.uniforms.setValue("uBlockOffset",t),e.updateTransformFeedback({shader:s.shader,uniforms:s.uniforms,transformFeedback:s.transformFeedback,vertexArrayObject:s.vertexArrayObject,drawCount:qr}),e.gl.getBufferSubData(i.TRANSFORM_FEEDBACK_BUFFER,0,o);for(let e=0;e<qr;e++)u[h*qr+e]=o[2*e+0],c[h*qr+e]=o[2*e+1]}this.audioContext=r,this.audioBuffer=a}play(e){this.gainNode&&(this.gainNode.disconnect(),this.gainNode=null),this.node&&(this.node.stop(),this.node=null);const t=this.audioContext.createBufferSource(),n=this.audioContext.createGain();n.connect(this.audioContext.destination),n.gain.value=this.volume,t.connect(n),t.buffer=this.audioBuffer,t.loop=!1,t.start(0,e),this.node=t,this.gainNode=n}setVolume(e){this.volume=e,this.gainNode&&(this.gainNode.gain.value=this.volume)}stop(){this.node?.stop()}}class Kr{get domElement(){return this.rootElement}constructor(e=!0){this.rootElement=document.createElement("div"),e&&(this.rootElement.style.cssText="\n                background-color: rgb(200 200 255 / 70%);\n                position: absolute;\n                top: 0px;\n                right: 0px;\n                box-sizing: border-box;\n                padding: 0px 10px 10px 10px;\n                display: grid;\n                justify-items: start;\n                \n                font-size: 9px;\n                font-weight: bold;\n                line-height: 1.2em;\n                min-width: 200px;\n        "),this.contentElement=document.createElement("div"),this.contentElement.style.cssText="\n            width: 100%;\n        ",this.rootElement.appendChild(this.contentElement)}#H(e){const t=document.createElement("div");t.style.cssText="\n            box-sizing: border-box;\n            padding-top: 8px;\n        ";const n=document.createElement("div");if(t.appendChild(n),e){const t=document.createElement("span");t.style.cssText="\n                padding-right: 1em;\n            ",t.textContent=e,n.appendChild(t)}const r=document.createElement("div");return t.appendChild(r),{wrapperElement:t,headerElement:n,contentElement:r}}addGroup(e,t=!0){const n=new Kr(!1),r=document.createElement("p");r.textContent=e,r.style.cssText="\n            font-size: 11px;\n            font-style: italic;\n            box-sizing: border-box;\n            padding: 4px 0 0 0;\n            cursor: pointer;\n        ",n.rootElement.insertBefore(r,n.contentElement);const a=()=>{n.contentElement.classList.remove("is-hidden"),n.contentElement.style.cssText="",r.textContent=` ${e}`},i=()=>{n.contentElement.classList.add("is-hidden"),n.contentElement.style.cssText="display: none;",r.textContent=` ${e}`};return r.addEventListener("click",(()=>{n.contentElement.classList.contains("is-hidden")?a():i()})),t?a():i(),this.contentElement.appendChild(n.domElement),n}addPullDownDebugger({label:e,onChange:t,initialValue:n=null,initialExec:r=!0,options:a=[]}){const{wrapperElement:i,contentElement:o}=this.#H(e),s=document.createElement("select");s.style.cssText="\n                    font-size: 9px;\n                ",a.forEach((e=>{const t=document.createElement("option");t.value=e.value,t.label=e.label||e.value,s.appendChild(t),e.isDefault&&(s.value=e.value)})),s.addEventListener("change",(()=>{t(s.value)})),null!==n&&(s.value=n),r&&t(s.value),o.appendChild(s),this.contentElement.appendChild(i)}addColorDebugger({label:e,onChange:t,onInput:n=null,initialValue:r=null,initialExec:a=!0}){const{wrapperElement:i,contentElement:o}=this.#H(e),s=document.createElement("input");s.type="color",s.addEventListener("change",(()=>{t(s.value)})),s.addEventListener("input",(()=>{n?n(s.value):t(s.value)})),null!==r&&(s.value=r),a&&t(s.value),o.appendChild(s),this.contentElement.appendChild(i)}addToggleDebugger({label:e,onChange:t,initialValue:n=null,initialExec:r=!0}){const{wrapperElement:a,contentElement:i}=this.#H(e),o=document.createElement("input");o.type="checkbox",o.checked=!!n,o.addEventListener("change",(()=>{t(o.checked)})),r&&t(o.checked),i.appendChild(o),this.contentElement.appendChild(a)}addSliderDebugger({label:e,onChange:t,onInput:n,initialValue:r,initialExec:a=!0,minValue:i,maxValue:o,stepValue:s}){const{wrapperElement:l,headerElement:u,contentElement:c}=this.#H(e),h=document.createElement("span"),f=document.createElement("input"),m=()=>{h.textContent=`value: ${f.value}`},d=()=>(m(),Number.parseFloat(f.value));f.type="range",f.min=i.toString(),f.max=o.toString(),null!==s&&(f.step=s.toString()),f.addEventListener("change",(()=>d())),f.addEventListener("input",(()=>{n?n(d()):t(d())})),null!==r&&(f.value=r.toString()),a?t(d()):m(),u.appendChild(h),c.appendChild(f),this.contentElement.appendChild(l)}addButtonDebugger({buttonLabel:e,onClick:t}){const{wrapperElement:n,contentElement:r}=this.#H(""),a=document.createElement("input");a.type="button",a.value=e,a.style.cssText="\n        font-size: 9px;\n        font-weight: bold;\n        line-height: 1.2em;\n        padding: 1px 2px;\n",a.addEventListener("click",(()=>t())),r.appendChild(a),this.contentElement.appendChild(n)}addBorderSpacer(){const e=document.createElement("hr");e.style.cssText="\n            width: 100%;\n            height: 1px;\n            border: none;\n            border-top: 1px solid #777;\n            margin: 0.5em 0 0.25em 0;\n        ",this.contentElement.appendChild(e)}}class Zr{constructor({gpu:e,attributes:t,drawCount:n,vertexShader:r,varyings:a,uniforms:i=[],uniformBlockNames:o=[]}){this.transformFeedbackBuffers=[],this.uniformBlockNames=[];const s=a.map((({name:e})=>e));this.shader=new Gt({gpu:e,vertexShader:r,fragmentShader:$r,transformFeedbackVaryings:s}),this.drawCount=n,this.uniforms=new $t(i),this.uniformBlockNames=o,t.forEach(((e,t)=>{e.location=t,e.divisor=0}));const l=t,u=t.map((e=>({...e}))),c=new un({gpu:e,attributes:l}),h=new un({gpu:e,attributes:u}),f=new Xr({gpu:e,buffers:c.getBuffers()}),m=new Xr({gpu:e,buffers:h.getBuffers()});this.transformFeedbackBuffers.push({attributes:l,srcVertexArrayObject:c,transformFeedback:m,outputVertexArrayobject:h}),this.transformFeedbackBuffers.push({attributes:u,srcVertexArrayObject:h,transformFeedback:f,outputVertexArrayobject:c})}get read(){const e=this.transformFeedbackBuffers[0];return{vertexArrayObject:e.srcVertexArrayObject,transformFeedback:e.transformFeedback}}get write(){const e=this.transformFeedbackBuffers[0];return{vertexArrayObject:e.srcVertexArrayObject,transformFeedback:e.transformFeedback}}swap(){const e=this.transformFeedbackBuffers[0];this.transformFeedbackBuffers[0]=this.transformFeedbackBuffers[1],this.transformFeedbackBuffers[1]=e}}class Qr extends qt{constructor({diffuseColor:e,diffuseMap:t,diffuseMapUvScale:n,diffuseMapUvOffset:r,emissiveColor:a,vertexShaderModifier:i={},uniforms:s=[],...l}={}){super({...l,name:"UnlitMaterial",vertexShaderModifier:i,uniforms:[...[{name:"uDiffuseColor",type:Te,value:e||Ut.black},{name:"uDiffuseMap",type:se,value:t||null},{name:"uDiffuseMapUvScale",type:ue,value:n||Hn.one},{name:"uDiffuseMapUvOffset",type:ue,value:r||Hn.one},{name:"uEmissiveColor",type:Te,value:a||Ut.black},{name:ke,type:xe,value:o}],...s||[]],depthUniforms:[{name:"uDiffuseMap",type:se,value:t||null},{name:"uDiffuseMapUvScale",type:ue,value:Hn.one},{name:"uDiffuseMapUvOffset",type:ue,value:Hn.one}],useNormalMap:!1,depthTest:!0,depthWrite:!1,depthFuncType:u,uniformBlockNames:[bt,Pt]})}start({gpu:e,attributeDescriptors:t=[]}){this.vertexShader=xr,this.fragmentShader="#version 300 es\n\nprecision highp float;\n\n#pragma DEFINES\n\nuniform vec4 uDiffuseColor;\nuniform sampler2D uDiffuseMap;\nuniform vec2 uDiffuseMapUvScale;\nuniform vec4 uEmissiveColor;\nuniform int uShadingModelId;\n\nvec3 reinhard(vec3 x) {\n    return x / (x + vec3(1.));\n}\n\nvec3 reinhardExposure(vec3 x, float exposure) {\n    float l2 = exposure * exposure;\n    return (x / (x + vec3(1.))) * (1. + (x / exposure));\n}\n\nvec3 aces(vec3 x) {\n    float a = 2.51;\n    float b = .03;\n    float c = 2.43;\n    float d = .59;\n    float e = .14;\n    vec3 y = (x * (a * x + b)) / (x * (c * x + d) + e);\n    return clamp(y, 0., 1.);\n}\n\nvec3 degamma(vec3 color) {\n    return pow(color, vec3(1. / 2.2));\n}\n\nvec3 gamma(vec3 color) {\n    return pow(color, vec3(2.2));\n}\n\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\n\n#ifdef USE_ALPHA_TEST\nuniform float uAlphaTestThreshold;\n#endif\n\nstruct Camera {\n    vec3 worldPosition;\n};\n\nin vec2 vUv;\nin vec3 vNormal;\nin vec3 vWorldPosition;\n\n#ifdef USE_VERTEX_COLOR\nin vec4 vVertexColor;\n#endif\n\n#define SHADING_MODEL_NUM 3.\n\nstruct GBufferA {\n    vec3 baseColor; \n    \n};\n\nstruct GBufferB {\n    vec3 normal; \n    float shadingModelId; \n};\n\nstruct GBufferC {\n    float metallic; \n    float roughness; \n};\n\nstruct GBufferD {\n    vec3 emissiveColor; \n    \n};\n\nvec4 EncodeGBufferA(vec3 baseColor) {\n    return vec4(baseColor, 1.);\n}\n\nvec4 EncodeGBufferB(vec3 normal, int shadingModelId) {\n    \n    float id = float(shadingModelId) / SHADING_MODEL_NUM;\n    return vec4(normal * .5 + .5, id);\n}\n\nvec4 EncodeGBufferC(float metallic, float roughness) {\n    return vec4(metallic, roughness, 0., 1.);\n}\n\nvec4 EncodeGBufferD(vec3 emissiveColor) {\n    return vec4(emissiveColor, 1.);\n}\n\nGBufferA DecodeGBufferA(sampler2D gBufferATexture, vec2 uv) {\n    vec4 color = texture(gBufferATexture, uv);\n    GBufferA gBufferA;\n    gBufferA.baseColor = color.rgb;\n    return gBufferA;\n}\n\nGBufferB DecodeGBufferB(sampler2D gBufferBTexture, vec2 uv) {\n    vec4 color = texture(gBufferBTexture, uv);\n    GBufferB gBufferB;\n    gBufferB.normal = normalize(color.rgb * 2. - 1.);\n    gBufferB.shadingModelId = color.a * SHADING_MODEL_NUM;\n    return gBufferB;\n}\n\nGBufferC DecodeGBufferC(sampler2D gBufferCTexture, vec2 uv) {\n    vec4 color = texture(gBufferCTexture, uv);\n    GBufferC gBufferC;\n    gBufferC.metallic = color.x;\n    gBufferC.roughness = color.y;\n    return gBufferC;\n}\n\nGBufferD DecodeGBufferD(sampler2D gBufferDTexture, vec2 uv) {\n    vec4 color = texture(gBufferDTexture, uv);\n    GBufferD gBufferD;\n    gBufferD.emissiveColor = color.rgb;\n    return gBufferD;\n}\n\nvoid checkAlphaTest(float value, float threshold) {\n    if(value < threshold) {\n        discard;\n    }\n}\n\nlayout (location = 0) out vec4 outGBufferA;\nlayout (location = 1) out vec4 outGBufferB;\nlayout (location = 2) out vec4 outGBufferC;\nlayout (location = 3) out vec4 outGBufferD;\n\nvoid main() {\n    vec4 resultColor = vec4(0, 0, 0, 1);\n\n    vec2 uv = vUv * uDiffuseMapUvScale;\n\n    vec4 diffuseMapColor = texture(uDiffuseMap, uv);\n\n    vec3 worldNormal = vNormal;\n\n#ifdef USE_NORMAL_MAP\n    worldNormal = calcNormal(vNormal, vTangent, vBinormal, uNormalMap, uv);\n#else\n    worldNormal = normalize(vNormal);\n#endif\n\n#ifdef USE_VERTEX_COLOR\n    diffuseColor *= vVertexColor;\n#endif\n\n    resultColor = diffuseMapColor; \n\n#ifdef USE_ALPHA_TEST\n    checkAlphaTest(resultColor.a, uAlphaTestThreshold);\n#endif\n    \n    resultColor.rgb = gamma(resultColor.rgb);\n    vec3 emissiveColor = gamma(uEmissiveColor.rgb);\n    \n    outGBufferA = EncodeGBufferA(resultColor.rgb);\n    outGBufferB = EncodeGBufferB(worldNormal, uShadingModelId);\n    outGBufferC = EncodeGBufferC(0., 0.);\n    outGBufferD = EncodeGBufferD(emissiveColor);\n}",this.depthFragmentShader=Tr,super.start({gpu:e,attributeDescriptors:t})}}class ea extends Ot{constructor(e){super({...e,lightType:w}),this.shadowCamera=new gn(45,1,.1,20),this.shadowCamera.fixedAspect=!0,this.shadowCamera.transform.setRotationY(180),this.addChild(this.shadowCamera),this.distance=e.distance,this.attenuation=e.attenuation,this.coneCos=e.coneCos,this.penumbraCos=e.penumbraCos}update(e){super.update(e),this.shadowCamera&&(this.shadowCamera.fov=2*(Math.acos(this.coneCos)*(180/Math.PI)),this.shadowCamera.far=this.distance,this.shadowCamera.updateProjectionMatrix(),this.updateShadowCamera())}}class ta{constructor(e,t){this.point=e,this.normal=t}}const na=4096;let ra=0;const aa=(e,t)=>{sa.addBorderSpacer();const n=sa.addGroup(t,!1);n.addToggleDebugger({label:"light enabled",initialValue:e.enabled,onChange:t=>e.enabled=t}),n.addColorDebugger({label:"color",initialValue:e.color.getHexCoord(),onChange:t=>{e.color=Ut.fromHex(t)}}),n.addSliderDebugger({label:"intensity",minValue:0,maxValue:10,stepValue:.001,initialValue:e.intensity,onChange:t=>{e.intensity=t}}),n.addSliderDebugger({label:"distance",minValue:0,maxValue:100,stepValue:.01,initialValue:e.distance,onChange:t=>{e.distance=t}}),n.addSliderDebugger({label:"attenuation",minValue:0,maxValue:10,stepValue:.001,initialValue:e.attenuation,onChange:t=>{e.attenuation=t}}),n.addSliderDebugger({label:"coneCos",minValue:0,maxValue:1,stepValue:.001,initialValue:e.coneCos,onChange:t=>{e.coneCos=t}}),n.addSliderDebugger({label:"penumbraCos",minValue:0,maxValue:1,stepValue:.001,initialValue:e.penumbraCos,onChange:t=>{e.penumbraCos=t}}),n.addSliderDebugger({label:"pos x",minValue:-10,maxValue:10,stepValue:.001,initialValue:e.transform.position.x,onChange:t=>{e.transform.position.x=t}}),n.addSliderDebugger({label:"pos y",minValue:0,maxValue:10,stepValue:.001,initialValue:e.transform.position.y,onChange:t=>{e.transform.position.y=t}}),n.addSliderDebugger({label:"pos z",minValue:-10,maxValue:10,stepValue:.001,initialValue:e.transform.position.z,onChange:t=>{e.transform.position.z=t}})},ia=document.createElement("style");ia.innerText="\n:root {\n  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;\n  line-height: 1.5;\n  font-weight: 400;\n  color-scheme: light dark;\n  font-synthesis: none;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-text-size-adjust: 100%;\n}\n\nbody {\n  overflow: hidden;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  font-family: sans-serif;\n} \n\n#wrapper {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\ncanvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: black;\n}\n",document.head.appendChild(ia);const oa={instanceNum:0};let sa,la,ua,ca,ha,fa,ma,da,pa,ga;oa.instanceNum=64;const va=!!window.navigator.userAgent.match(/(iPhone|iPad|iPod|Android)/i),xa=va?new class extends Wr{#W=!1;#X=Hn.zero;constructor(){super()}start(){window.addEventListener("touchstart",this.#$.bind(this)),window.addEventListener("touchmove",this.#Y.bind(this)),window.addEventListener("touchend",this.#q.bind(this))}update(){this.updateInternal({inputPosition:this.#X,isDown:this.#W})}#$(e){this.#W=!0;const t=e.touches[0];this.setInputPosition(t.clientX,t.clientY)}#Y(e){const t=e.touches[0];this.setInputPosition(t.clientX,t.clientY)}#q(e){this.#W=!1;const t=e.touches[0];this.setInputPosition(t.clientX,t.clientY)}setInputPosition(e,t){this.#X.set(e,t)}dispose(){window.removeEventListener("touchstart",this.#$.bind(this)),window.removeEventListener("touchmove",this.#Y.bind(this)),window.removeEventListener("touchend",this.#q.bind(this))}}:new class extends Wr{#W=!1;#X=Hn.zero;constructor(){super()}start(){window.addEventListener("mousedown",this.#J.bind(this)),window.addEventListener("mousemove",this.#K.bind(this)),window.addEventListener("mouseup",this.#Z.bind(this))}update(){this.updateInternal({inputPosition:this.#X,isDown:this.#W})}#J(e){this.#W=!0,this.setInputPosition(e.clientX,e.clientY)}#K(e){this.setInputPosition(e.clientX,e.clientY)}#Z(e){this.#W=!1,this.setInputPosition(e.clientX,e.clientY)}setInputPosition(e,t){this.#X.set(e,t)}dispose(){window.removeEventListener("mousedown",this.#J.bind(this)),window.removeEventListener("mousemove",this.#K.bind(this)),window.removeEventListener("mouseup",this.#Z.bind(this))}};xa.start();const Ta=document.createElement("div");document.body.appendChild(Ta),Ta.setAttribute("id","wrapper");const wa=document.createElement("canvas");Ta.appendChild(wa);const ba=wa.getContext("webgl2",{antialias:!1});if(!ba)throw"invalid gl";const Pa=new class{constructor({gl:e}){this.shader=null,this.vao=null,this.uniforms=null,this.validExtensions=[],this.invalidExtensions=[],this.uboBindingPoint=0,this.gl=e,this.dummyTexture=new en({gpu:this,img:sn("white"),wrapS:H.Repeat,wrapT:H.Repeat}),this.dummyTextureBlack=new en({gpu:this,img:sn("black"),wrapS:H.Repeat,wrapT:H.Repeat}),this.dummyCubeTexture=rn(this,sn(),sn(),sn(),sn(),sn(),sn())}setShader(e){this.shader=e}setVertexArrayObject(e){this.vao=e}setUniforms(e){this.uniforms=e}setSize(e,t,n,r){this.gl.viewport(e,t,n,r)}setFramebuffer(e){const t=this.gl;e?(t.bindFramebuffer(t.FRAMEBUFFER,e.glObject),e.hasMultipleDrawBuffers&&t.drawBuffers(e.drawBufferList)):t.bindFramebuffer(t.FRAMEBUFFER,null)}flush(){this.gl.flush()}clearDepth(e,t,n,r){const a=this.gl;a.depthMask(!0),a.colorMask(!1,!1,!1,!1),a.clearColor(e,t,n,r),a.clear(a.DEPTH_BUFFER_BIT)}clearColor(e,t,n,r){const a=this.gl;a.depthMask(!1),a.colorMask(!0,!0,!0,!0),a.clearColor(e,t,n,r),a.clear(a.COLOR_BUFFER_BIT)}clear(e,t,n,r){this.clearDepth(e,t,n,r),this.clearColor(e,t,n,r)}checkExtension(e){if(this.validExtensions.includes(e))return!0;if(this.invalidExtensions.includes(e))return!1;return null!=this.gl.getExtension(e)?(this.validExtensions.push(e),!0):(this.invalidExtensions.push(e),!1)}#Q(e){const t=this.gl;switch(e){case n:return t.POINTS;case r:return t.LINES;case a:return t.TRIANGLES;default:throw"invalid primitive type"}}setUniformValues(){const e=this.gl;let t=0;const n=(n,r,a)=>{const i=e.getUniformLocation(this.shader.glObject,r);switch(n){case xe:e.uniform1i(i,a);break;case ge:e.uniform1f(i,a);break;case ve:e.uniform1fv(i,a);break;case ue:e.uniform2fv(i,a.elements);break;case ce:e.uniform2fv(i,a.map((e=>[...e.elements])).flat());break;case he:e.uniform3fv(i,a.elements);break;case fe:e.uniform4fv(i,a.elements);break;case me:e.uniform4fv(i,a.map((e=>[...e.elements])).flat());break;case ie:e.uniformMatrix4fv(i,!1,a.elements);break;case oe:a&&e.uniformMatrix4fv(i,!1,a.map((e=>[...e.elements])).flat());break;case Te:e.uniform4fv(i,a.elements);break;case we:a&&e.uniform4fv(i,a.map((e=>[...e.elements])).flat());break;case se:e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,a?a.glObject:this.dummyTexture.glObject),e.uniform1i(i,t),t++;break;case be:const o=[];a.forEach((n=>{o.push(t),e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,n?n.glObject:this.dummyTexture.glObject),t++})),e.uniform1iv(i,o);break;case le:e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_CUBE_MAP,a?a.glObject:this.dummyCubeTexture.glObject),e.uniform1i(i,t),t++;break;default:throw`invalid uniform - name: ${r}, type: ${n}`}};this.uniforms&&this.uniforms.data.forEach((e=>{if(e.type===de){e.value.forEach((t=>{const r=`${e.name}.${t.name}`;n(t.type,r,t.value)}))}else e.type===pe?e.value.forEach(((t,r)=>{t.forEach((t=>{const a=`${e.name}[${r}].${t.name}`;n(t.type,a,t.value)}))})):n(e.type,e.name,e.value)}))}updateTransformFeedback({shader:e,uniforms:t,transformFeedback:n,vertexArrayObject:r,drawCount:a}){this.uniforms=t,this.shader=e,this.vao=r;const i=this.gl;i.bindVertexArray(this.vao.glObject),i.useProgram(this.shader.glObject),this.setUniformValues(),i.enable(i.RASTERIZER_DISCARD),i.bindTransformFeedback(i.TRANSFORM_FEEDBACK,n.glObject),i.beginTransformFeedback(i.POINTS),i.drawArrays(i.POINTS,0,a),i.endTransformFeedback(),i.bindTransformFeedback(i.TRANSFORM_FEEDBACK,null),i.disable(i.RASTERIZER_DISCARD),i.useProgram(null),i.bindVertexArray(null),this.shader=null,this.uniforms=null,this.vao=null}draw(e,t,n,r,a,i,o,s,m=0){const d=this.#Q(t),p=this.gl;switch(o){case _:p.enable(p.CULL_FACE),p.cullFace(p.BACK),p.frontFace(p.CCW);break;case I:p.enable(p.CULL_FACE),p.cullFace(p.FRONT),p.frontFace(p.CCW);break;case N:p.disable(p.CULL_FACE),p.frontFace(p.CCW);break;default:throw"invalid face side"}if(p.depthMask(r),n)switch(p.enable(p.DEPTH_TEST),a){case u:p.depthFunc(p.EQUAL);break;case l:p.depthFunc(p.LEQUAL);break;default:throw"invalid depth func type"}else p.disable(p.DEPTH_TEST);switch(i){case c:p.disable(p.BLEND);break;case h:p.enable(p.BLEND),p.blendFunc(p.SRC_ALPHA,p.ONE_MINUS_SRC_ALPHA);break;case f:p.enable(p.BLEND),p.blendFunc(p.SRC_ALPHA,p.ONE);break;default:throw"invalid blend type"}if(!this.shader)throw"shader is not set";if(!this.vao)throw"vao is not set";p.useProgram(this.shader.glObject),this.setUniformValues(),p.bindVertexArray(this.vao.glObject),this.vao.hasIndices?s?p.drawElementsInstanced(d,e,p.UNSIGNED_SHORT,m,s):p.drawElements(d,e,p.UNSIGNED_SHORT,m):s?p.drawArraysInstanced(d,m,e,s):p.drawArrays(d,m,e),p.bindTexture(p.TEXTURE_2D,null),p.bindTexture(p.TEXTURE_CUBE_MAP,null)}createUniformBufferObject(e,t,n){const r=[];n.forEach((e=>{switch(e.type){case de:e.value.forEach((t=>{r.push(`${e.name}.${t.name}`)}));break;case pe:e.value.forEach(((t,n)=>{t.forEach((t=>{r.push(`${e.name}[${n}].${t.name}`)}))}));break;default:r.push(e.name)}}));const a=this.gl,i=a.getUniformBlockIndex(e.glObject,t),o=a.getActiveUniformBlockParameter(e.glObject,i,a.UNIFORM_BLOCK_DATA_SIZE),s=a.getUniformIndices(e.glObject,r),l=a.getActiveUniforms(e.glObject,s,a.UNIFORM_OFFSET),u=new on(this,t,o,r,s,l,o,this.uboBindingPoint);return this.uboBindingPoint++,u}bindUniformBlockAndGetBlockIndex(e,t,n){const r=this.gl.getUniformBlockIndex(t.glObject,n);return this.gl.uniformBlockBinding(t.glObject,r,e.bindingPoint),r}}({gl:ba}),ya=new class{constructor(){this.children=[]}add(e){this.children.push(e.transform)}traverse(e){for(let t=0;t<this.children.length;t++)this.#ee(this.children[t].actor,e)}find(e){return this.children.find((t=>t.actor.name===e))}#ee(e,t){if(t(e),e.transform.hasChild)for(let n=0;n<e.transform.children.length;n++)this.#ee(e.transform.children[n],t)}},Sa=Math.min(window.devicePixelRatio,1),Ca=new class{constructor({gpu:n,canvas:r,pixelRatio:a=1.5}){this.globalUniformBufferObjects=[],this.renderTarget=null,this.clearColorDirtyFlag=!1,this.realWidth=1,this.realHeight=1,this.stats=null,this.screenQuadCamera=pn.CreateFullQuadOrthographicCamera(),this.gpu=n,this.canvas=r,this.pixelRatio=a,this._scenePostProcess=new Pn(this.screenQuadCamera),this._depthPrePassRenderTarget=new Dn({gpu:n,type:Y,width:1,height:1,name:"depth pre-pass render target",depthPrecision:X}),this._gBufferRenderTargets=new Bn({gpu:n,width:1,height:1,name:"g-buffer render target"}),this._afterDeferredShadingRenderTarget=new Dn({gpu:n,type:q,width:1,height:1,name:"after g-buffer render target"}),this._copyDepthSourceRenderTarget=new Dn({gpu:n,type:q,width:1,height:1,name:"copy depth source render target",depthPrecision:X}),this._copyDepthDestRenderTarget=new Dn({gpu:n,type:Y,width:1,height:1,name:"copy depth dest render target",depthPrecision:X}),this._ambientOcclusionPass=new Nn({gpu:n}),this._deferredShadingPass=new Ln({gpu:n}),this._ssrPass=new Un({gpu:n}),this._lightShaftPass=new $n({gpu:n}),this._volumetricLightPass=new Yn({gpu:n}),this._fogPass=new rr({gpu:n}),this._depthOfFieldPass=new Wn({gpu:n}),this._scenePostProcess.addPass(this._depthOfFieldPass),this._bloomPass=new Gn({gpu:n}),this._scenePostProcess.addPass(this._bloomPass),this._streakPass=new cr({gpu:n}),this._scenePostProcess.addPass(this._streakPass),this._toneMappingPass=new On({gpu:n}),this._scenePostProcess.addPass(this._toneMappingPass),this._chromaticAberrationPass=new ir({gpu:n}),this._scenePostProcess.addPass(this._chromaticAberrationPass),this._vignettePass=new ur({gpu:n}),this._scenePostProcess.addPass(this._vignettePass);const i=new Gt({gpu:n,vertexShader:"#version 300 es\n\n#define MAX_SPOT_LIGHT_COUNT 4\n\nlayout (std140) uniform ubCommon {\n    float uTime;\n    vec4 uViewport;\n};\r\nlayout (std140) uniform ubTransformations {\n    mat4 uWorldMatrix;\n    mat4 uViewMatrix;\n    mat4 uProjectionMatrix;\n    mat4 uNormalMatrix;\n    mat4 uInverseWorldMatrix;\n\n    mat4 uViewProjectionMatrix;\n    mat4 uInverseViewMatrix;\n    mat4 uInverseProjectionMatrix;\n    mat4 uInverseViewProjectionMatrix;\n    mat4 uTransposeInverseViewMatrix;\n};\r\nlayout (std140) uniform ubCamera {\n    vec3 uViewPosition;\n    vec3 uViewDirection;\n    float uNearClip;\n    float uFarClip;\n    float uAspect;\n    float uFov;\n};\r\nstruct DirectionalLight {\n    vec3 direction; \n    float intensity;\n    vec4 color;\n    mat4 shadowMapProjectionMatrix;\n};\n\nlayout (std140) uniform ubDirectionalLight {\n    DirectionalLight uDirectionalLight;\n};\r\nstruct SpotLight {\n    vec4 color;\n    vec3 position;\n    vec3 direction; \n    float intensity;\n    float distance;\n    float attenuation;\n    float coneCos;\n    float penumbraCos;\n    mat4 shadowMapProjectionMatrix;\n};\n\nlayout (std140) uniform ubSpotLight {\n    SpotLight uSpotLight[MAX_SPOT_LIGHT_COUNT];\n};\n\nvoid main() {\r\n}",fragmentShader:"#version 300 es\n\nvoid main() {\r\n}"}),o=[{name:ye,type:ie,value:t.identity},{name:Se,type:ie,value:t.identity},{name:Ce,type:ie,value:t.identity},{name:Be,type:ie,value:t.identity},{name:Me,type:ie,value:t.identity},{name:De,type:ie,value:t.identity},{name:Ee,type:ie,value:t.identity},{name:Ae,type:ie,value:t.identity},{name:Re,type:ie,value:t.identity},{name:Fe,type:ie,value:t.identity}];this.globalUniformBufferObjects.push({uniformBufferObject:this.gpu.createUniformBufferObject(i,bt,o),data:o});const s=[{name:Ve,type:he,value:e.zero},{name:Le,type:he,value:e.zero},{name:nt,type:ge,value:0},{name:rt,type:ge,value:0},{name:_e,type:ge,value:0},{name:Ie,type:ge,value:0}];this.globalUniformBufferObjects.push({uniformBufferObject:this.gpu.createUniformBufferObject(i,Pt,s),data:s});const l=[{name:it,type:de,value:[{name:st,type:he,value:e.zero},{name:lt,type:ge,value:0},{name:ut,type:Te,value:Ut.black},{name:ct,type:ie,value:t.identity}]}];this.globalUniformBufferObjects.push({uniformBufferObject:this.gpu.createUniformBufferObject(i,yt,l),data:l});const u=[{name:ot,type:pe,value:Vn.range(4).map((()=>[{name:ut,type:Te,value:Ut.black},{name:mt,type:he,value:e.zero},{name:st,type:he,value:e.zero},{name:lt,type:ge,value:0},{name:dt,type:ge,value:0},{name:pt,type:ge,value:0},{name:gt,type:ge,value:0},{name:vt,type:ge,value:0},{name:ct,type:ie,value:t.identity}]))}];this.globalUniformBufferObjects.push({uniformBufferObject:this.gpu.createUniformBufferObject(i,St,u),data:u});const c=[{name:Je,type:ge,value:0},{name:Ke,type:fe,value:zt.zero}];this.globalUniformBufferObjects.push({uniformBufferObject:this.gpu.createUniformBufferObject(i,wt,c),data:c})}checkNeedsBindUniformBufferObjectToMaterial(e){e.boundUniformBufferObjects||(e.boundUniformBufferObjects=!0,e.uniformBlockNames.forEach((t=>{const n=this.globalUniformBufferObjects.find((({uniformBufferObject:e})=>e.blockName===t));if(!n)return;const r=this.gpu.bindUniformBlockAndGetBlockIndex(n.uniformBufferObject,e.shader,t);e.uniforms.addUniformBlock(r,n.uniformBufferObject,[])})))}get depthPrePassRenderTarget(){return this._depthPrePassRenderTarget}get gBufferRenderTargets(){return this._gBufferRenderTargets}get ambientOcclusionPass(){return this._ambientOcclusionPass}get ssrPass(){return this._ssrPass}get deferredShadingPass(){return this._deferredShadingPass}get lightShaftPass(){return this._lightShaftPass}get volumetricLightPass(){return this._volumetricLightPass}get fogPass(){return this._fogPass}get depthOfFieldPass(){return this._depthOfFieldPass}get bloomPass(){return this._bloomPass}get streakPass(){return this._streakPass}get chromaticAberrationPass(){return this._chromaticAberrationPass}get vignettePass(){return this._vignettePass}setStats(e){this.stats=e}setSize(e,t){this.realWidth=e,this.realHeight=t,this.canvas.width=this.realWidth,this.canvas.height=this.realHeight,this.gpu.setSize(0,0,this.realWidth,this.realHeight),this._depthPrePassRenderTarget.setSize(e,t),this._gBufferRenderTargets.setSize(e,t),this._afterDeferredShadingRenderTarget.setSize(e,t),this._copyDepthSourceRenderTarget.setSize(e,t),this._copyDepthDestRenderTarget.setSize(e,t),this._ambientOcclusionPass.setSize(e,t),this._deferredShadingPass.setSize(e,t),this._ssrPass.setSize(e,t),this._lightShaftPass.setSize(e,t),this._volumetricLightPass.setSize(e,t),this._fogPass.setSize(e,t),this._depthOfFieldPass.setSize(e,t),this._bloomPass.setSize(e,t),this._streakPass.setSize(e,t),this._toneMappingPass.setSize(e,t),this._chromaticAberrationPass.setSize(e,t),this._vignettePass.setSize(e,t)}setRenderTarget(e,t=!1,n=!1){e?(this.renderTarget=e,this.gpu.setFramebuffer(e.framebuffer),this.gpu.setSize(0,0,e.width,e.height)):(this.renderTarget=null,this.gpu.setFramebuffer(null),this.gpu.setSize(0,0,this.realWidth,this.realHeight)),t?(this.gpu.clearColor(0,0,0,0),this.clearColorDirtyFlag=!0):this.clearColorDirtyFlag=!1,n&&this.gpu.clearDepth(1,1,1,1)}flush(){this.gpu.flush()}clearColor(e,t,n,r){this.gpu.clearColor(e,t,n,r)}clearDepth(e,t,n,r){this.gpu.clearDepth(e,t,n,r)}render(e,t,{time:n,onBeforePostProcess:r}){const a={[m]:[],[d]:[],[p]:[],[g]:[]},i={directionalLight:null,spotLights:[]};e.traverse((e=>{switch(e.type){case C:return void a[m].push(this.buildRenderMeshInfo(e,m));case P:case y:e.materials.forEach(((t,n)=>{if(t.alphaTest)a[p].push(this.buildRenderMeshInfo(e,p,n));else switch(t.blendType){case c:return void a[d].push(this.buildRenderMeshInfo(e,d,n));case h:case f:return void a[g].push(this.buildRenderMeshInfo(e,g,n));default:throw"[Renderer.render] invalid blend type"}}));break;case S:if(e.enabled){const t=e;switch(t.lightType){case T:i.directionalLight=t;break;case w:i.spotLights.push(t)}}}}));const o=(e,t)=>e.actor.materials[e.materialIndex].renderQueue-t.actor.materials[t.materialIndex].renderQueue,s=Object.keys(a).map((e=>a[e].sort(o))).flat().filter((({actor:e})=>e.enabled)),l=s.filter((e=>e.queue===m)),u=s.filter((e=>e.queue===m||e.queue===d||e.queue===p)),v=s.filter((e=>e.queue===g));this.updateCommonUniforms({time:n}),i.directionalLight&&this.updateDirectionalLightUniforms(i.directionalLight),i.spotLights.length>0&&this.updateSpotLightsUniforms(i.spotLights);const x=u.filter((({actor:e})=>e.type!==C&&e));this.depthPrePass(x,t),this.scenePass(u,t);const b=[];if(i.directionalLight&&b.push(i.directionalLight),i.spotLights.forEach((e=>{e.castShadow&&b.push(e)})),b.length>0){const e=u.filter((({actor:e})=>e.type!==C&&e.castShadow));this.shadowPass(b,e)}if(Pn.renderPass({pass:this._ambientOcclusionPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:null,isLastPass:!1,time:n}),l.forEach((e=>{const t=e.actor;this._deferredShadingPass.updateSkyboxUniforms(t)})),hr(this._deferredShadingPass.material,i),this._deferredShadingPass.material.uniforms.setValue("uAmbientOcclusionTexture",this._ambientOcclusionPass.renderTarget.read.texture),Pn.renderPass({pass:this._deferredShadingPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:null,isLastPass:!1,time:n,lightActors:i}),Pn.renderPass({pass:this._ssrPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:this._deferredShadingPass.renderTarget,isLastPass:!1,time:n}),!i.directionalLight)throw"invalid directional light.";if(this._lightShaftPass.setDirectionalLight(i.directionalLight),Pn.renderPass({pass:this._lightShaftPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:this._deferredShadingPass.renderTarget,isLastPass:!1,time:n}),this._volumetricLightPass.setSpotLights(i.spotLights),Pn.renderPass({pass:this._volumetricLightPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:this._deferredShadingPass.renderTarget,isLastPass:!1,time:n}),this._fogPass.setLightShaftMap(this._lightShaftPass.renderTarget),this._fogPass.setVolumetricLightMap(this._volumetricLightPass.renderTarget),Pn.renderPass({pass:this._fogPass,renderer:this,targetCamera:t,gpu:this.gpu,camera:this._scenePostProcess.postProcessCamera,prevRenderTarget:this._ssrPass.renderTarget,isLastPass:!1,time:n}),this._afterDeferredShadingRenderTarget.setTexture(this._fogPass.renderTarget.read.texture),this._afterDeferredShadingRenderTarget.setDepthTexture(this._depthPrePassRenderTarget.depthTexture),this.copyDepthTexture(),v.forEach((e=>{e.actor.material.uniforms.setValue(je,this._copyDepthDestRenderTarget.depthTexture)})),this.setRenderTarget(this._afterDeferredShadingRenderTarget.write),this.transparentPass(v,t,i),r&&r(),!this._scenePostProcess.hasEnabledPass)throw"invalid postprocess";let D=this._afterDeferredShadingRenderTarget;const B=!t.renderTarget&&!t.hasEnabledPostProcessPass;this._scenePostProcess.update(),this._scenePostProcess.render({gpu:this.gpu,renderer:this,prevRenderTarget:D,gBufferRenderTargets:this._gBufferRenderTargets,targetCamera:t,time:n,isCameraLastPass:B}),B||(D=this._scenePostProcess.lastRenderTarget,t.hasEnabledPostProcessPass&&(t.postProcess?.update(),t.postProcess?.render({gpu:this.gpu,renderer:this,prevRenderTarget:D,gBufferRenderTargets:this._gBufferRenderTargets,targetCamera:t,time:n,isCameraLastPass:!t.renderTarget,lightActors:i})))}renderMesh(e,t){if(e.update(),this.stats&&(this.stats.addDrawVertexCount(e),this.stats.incrementDrawCall()),this.gpu.setVertexArrayObject(e.vertexArrayObject),!t.shader)throw"invalid material shader";let n;if(this.gpu.setShader(t.shader),this.gpu.setUniforms(t.uniforms),null!==t.depthWrite)n=t.depthWrite;else switch(t.blendType){case c:n=!0;break;case h:case f:n=!1;break;default:throw"invalid depth write"}const r=!!t.depthTest,a=t.depthFuncType;this.gpu.draw(e.drawCount,t.primitiveType,r,n,a,t.blendType,t.faceSide,e.instanceCount)}buildRenderMeshInfo(e,t,n=0){return{actor:e,queue:t,materialIndex:n}}setUniformBlockValue(e,t,n){const r=this.globalUniformBufferObjects.find((({uniformBufferObject:t})=>t.blockName===e));if(!r)return;const a=r.uniformBufferObject,i=r.data.find((e=>e.name===t));i&&a.updateUniformValue(t,i.type,n)}depthPrePass(e,t){this.setRenderTarget(this._depthPrePassRenderTarget,!1,!0),this.updateCameraUniforms(t),e.forEach((({actor:e})=>{const t=e.depthMaterial;if(!t)throw"[Renderer.depthPrePass] invalid depth material";e.mainMaterial.skipDepthPrePass||(this.updateActorTransformUniforms(e),this.renderMesh(e.geometry,t),this.stats&&this.stats.addPassInfo("depth pre pass",e.name,e.geometry))}))}copyDepthTexture(){this._copyDepthSourceRenderTarget.setDepthTexture(this._depthPrePassRenderTarget.depthTexture),Dn.blitDepth({gpu:this.gpu,sourceRenderTarget:this._copyDepthSourceRenderTarget,destRenderTarget:this._copyDepthDestRenderTarget,width:this.realWidth,height:this.realHeight})}shadowPass(e,t){e.forEach((e=>{if(!e.shadowMap)throw"invalid shadow pass";if(!e.shadowCamera)throw"invalid shadow camera";this.setRenderTarget(e.shadowMap.write,!1,!0),t.length<1||(this.updateCameraUniforms(e.shadowCamera),t.forEach((({actor:t})=>{const n=t.depthMaterial;if(!n)throw"invalid target material";this.updateActorTransformUniforms(t),n.uniforms.setValue(je,this._copyDepthDestRenderTarget.depthTexture),t.updateDepthMaterial({camera:e.shadowCamera}),this.renderMesh(t.geometry,n),this.stats&&this.stats.addPassInfo("shadow pass",t.name,t.geometry)})))}))}scenePass(e,t){this._gBufferRenderTargets.setDepthTexture(this._depthPrePassRenderTarget.depthTexture),this.setRenderTarget(this._gBufferRenderTargets.write,!0),this.updateCameraUniforms(t),e.forEach((({actor:e,materialIndex:n})=>{if(e.type===C){if(!e.renderMesh)return;e.updateTransform(t)}const r=e.materials[n];r.skipDepthPrePass&&(this.setRenderTarget(null,!1,!1),this.copyDepthTexture(),this.setRenderTarget(this._gBufferRenderTargets.write,!1,!1)),this.updateActorTransformUniforms(e),r.uniforms.setValue(je,this._copyDepthDestRenderTarget.depthTexture),e.updateMaterial({camera:t}),this.renderMesh(e.geometry,r),this.stats&&this.stats.addPassInfo("scene pass",e.name,e.geometry)}))}updateActorTransformUniforms(e){this.setUniformBlockValue(bt,ye,e.transform.worldMatrix),this.setUniformBlockValue(bt,Me,e.transform.inverseWorldMatrix),this.setUniformBlockValue(bt,Be,e.transform.normalMatrix)}updateCameraUniforms(e){this.setUniformBlockValue(bt,Se,e.viewMatrix),this.setUniformBlockValue(bt,Ce,e.projectionMatrix),this.setUniformBlockValue(Pt,Ve,e.transform.worldMatrix.position),this.setUniformBlockValue(Pt,Le,e.getWorldForward()),this.setUniformBlockValue(Pt,nt,e.near),this.setUniformBlockValue(Pt,rt,e.far),this.setUniformBlockValue(Pt,_e,(e.isPerspective(),e.aspect)),this.setUniformBlockValue(Pt,Ie,e.isPerspective()?e.fov:0),this.setUniformBlockValue(bt,De,e.viewProjectionMatrix),this.setUniformBlockValue(bt,Ee,e.inverseViewMatrix),this.setUniformBlockValue(bt,Ae,e.inverseProjectionMatrix),this.setUniformBlockValue(bt,Re,e.inverseViewProjectionMatrix),this.setUniformBlockValue(bt,Fe,e.viewMatrix.clone().invert().transpose())}updateUniformBlockValue(e,t,n){const r=this.globalUniformBufferObjects.find((({uniformBufferObject:t})=>t.blockName===e));if(!r)return;const a=r.uniformBufferObject,i=r.data.find((e=>e.name===t));if(!i)return;const o=(e,t)=>{const n=[];switch(e){case ge:case xe:n.push(t),n.push(0),n.push(0),n.push(0);break;case Pe:n.push(t?1:0),n.push(0),n.push(0),n.push(0);break;case ue:case he:n.push(...t.elements),n.push(0);break;case fe:case ie:case Te:n.push(...t.elements);break;default:throw`invalid uniform type: ${e}`}return n};switch(i.type){case de:n.forEach((e=>{const n=`${t}.${e.name}`,r=o(e.type,e.value);a.updateBufferData(n,new Float32Array(r))}));break;case pe:n.forEach(((e,n)=>{e.forEach((e=>{const r=`${t}[${n}].${e.name}`,i=o(e.type,e.value);a.updateBufferData(r,new Float32Array(i))}))}));break;default:if(Array.isArray(n)){const e=[];n.forEach((t=>{"number"==typeof t?(e.push(t),e.push(0),e.push(0),e.push(0)):"boolean"==typeof t?(e.push(t?1:0),e.push(0),e.push(0),e.push(0)):e.push(...t.elements)})),a.updateBufferData(t,new Float32Array(e))}else a.updateBufferData(t,"number"==typeof n?new Float32Array([n]):n.elements)}}updateCommonUniforms({time:e}){this.updateUniformBlockValue(wt,Je,e),this.updateUniformBlockValue(wt,Ke,new zt(this.realWidth,this.realHeight,this.realWidth/this.realHeight,0))}updateDirectionalLightUniforms(e){this.updateUniformBlockValue(yt,it,[{name:st,type:he,value:e.transform.position.clone().negate().normalize()},{name:lt,type:ge,value:e.intensity},{name:ut,type:Te,value:e.color},{name:ct,type:ie,value:e.shadowMapProjectionMatrix}])}updateSpotLightsUniforms(e){this.updateUniformBlockValue(St,ot,e.map((e=>[{name:ut,type:Te,value:e.color},{name:mt,type:he,value:e.transform.position},{name:st,type:he,value:e.transform.worldForward.clone()},{name:lt,type:ge,value:e.intensity},{name:dt,type:ge,value:e.distance},{name:pt,type:ge,value:e.attenuation},{name:gt,type:ge,value:e.coneCos},{name:vt,type:ge,value:e.penumbraCos},{name:ct,type:ie,value:e.shadowMapProjectionMatrix}])))}transparentPass(e,t,n){this.updateCameraUniforms(t),e.forEach((({actor:e,materialIndex:t})=>{const r=e.materials[t];this.updateActorTransformUniforms(e),hr(r,n),this.renderMesh(e.geometry,r),this.stats&&this.stats.addPassInfo("transparent pass",e.name,e.geometry)}))}}({gpu:Pa,canvas:wa,pixelRatio:Sa}),Da=new class{constructor({gpu:e,renderer:t,onBeforeFixedUpdate:n,onBeforeUpdate:r,onRender:a}){this.#te=null,this.#ne=null,this.#re=null,this.#ae=null,this.#ie=null,this._onRender=null,this.#m=e,this.#oe=t,this.#se=new bn,this.#oe.setStats(this.#se),this.#le=new Tn(60,this.fixedUpdate.bind(this)),this.#ue=new xn(60,this.update.bind(this)),this.#ae=n||null,this.#ie=r||null,this._onRender=a||null}#m;#se;#oe;#te;#le;#ue;#ne;#re;#ae;#ie;get renderer(){return this.#oe}set onBeforeStart(e){this.#ne=e}set onAfterStart(e){this.#re=e}set onBeforeUpdate(e){this.#ie=e}set onBeforeFixedUpdate(e){this.#ae=e}set onRender(e){this._onRender=e}setScene(e){this.#te=e}start(){this.#ne&&this.#ne();const e=performance.now()/1e3;this.#le.start(e),this.#ue.start(e),this.#re&&this.#re()}setSize(e,t){const n=e*this.renderer.pixelRatio,r=t*this.renderer.pixelRatio,a=Math.floor(n),i=Math.floor(r);this.#te?.traverse((e=>e.setSize(a,i))),this.#oe.setSize(n,r)}fixedUpdate(e,t){this.#ae&&this.#ae({fixedTime:e,fixedDeltaTime:t}),this.#te?.traverse((n=>n.fixedUpdate({gpu:this.#m,fixedTime:e,fixedDeltaTime:t}))),this.#te?.traverse((e=>{e.updateTransform()}))}update(e,t){this.#ie&&this.#ie({time:e,deltaTime:t}),this.#te?.traverse((n=>{switch(n.update({gpu:this.#m,time:e,deltaTime:t}),n.type){case C:case P:case y:n.beforeRender({gpu:this.#m});const e=n;e.materials.forEach((e=>{this.renderer.checkNeedsBindUniformBufferObjectToMaterial(e)})),e.depthMaterial&&this.renderer.checkNeedsBindUniformBufferObjectToMaterial(e.depthMaterial)}})),this.#te?.traverse((e=>{e.updateTransform()})),this.render(e,t)}render(e,t){this.#se.clear(),this._onRender&&this._onRender(e,t),this.#se.update(e)}run(e){this.#le.exec(e/1e3),this.#ue.exec(e/1e3)}}({gpu:Pa,renderer:Ca});Da.setScene(ya);const Ba=new gn(50,1,.1,50);ya.add(Ba);const Ma=new class{constructor(t){this.dampingFactor=.01,this.minAzimuth=-45,this.maxAzimuth=45,this.minAltitude=-45,this.maxAltitude=45,this.azimuthSpeed=100,this.altitudeSpeed=100,this.#ce={azimuth:0,altitude:0},this.#he=e.zero,this.distance=10,this.attenuation=.001,this.#fe=0,this.#me=0,this.deltaAzimuthPower=1,this.deltaAltitudePower=1,this.defaultAzimuth=0,this.defaultAltitude=0,this.enabled=!0,this.#de=e.zero,this.#pe=e.zero,this.#ge=t}#ge;#ce;#he;#fe;#me;#de;#pe;set lookAtTarget(e){this.#he=e}start(e=null,t=null){this.#ce.azimuth=null!==e?e:this.defaultAzimuth,this.#ce.altitude=null!==t?t:this.defaultAltitude,this.#ve(!0)}setDelta(e){this.enabled&&(this.#fe=e.x*this.deltaAzimuthPower,this.#me=e.y*this.deltaAltitudePower)}fixedUpdate(){this.enabled&&(this.#fe=Math.sign(this.#fe)*Math.max(0,Math.abs(this.#fe)-this.attenuation),this.#me=Math.sign(this.#me)*Math.max(0,Math.abs(this.#me)-this.attenuation),this.#ce.azimuth+=this.#fe*this.azimuthSpeed,this.#ce.altitude+=this.#me*this.altitudeSpeed,this.#ve())}#ve(t=!1){this.#ce.azimuth=_n(this.#ce.azimuth,this.minAzimuth,this.maxAzimuth),this.#ce.altitude=_n(this.#ce.altitude,this.minAltitude,this.maxAltitude);const n=e.rotateVectorX(new e(0,0,1),this.#ce.altitude),r=e.rotateVectorY(n,this.#ce.azimuth);this.#de=e.addVectors(this.#he,r.scale(this.distance)),this.#pe=e.lerpVectors(this.#pe,this.#de,t?1:this.dampingFactor),this.#ge.transform.position=this.#pe,this.#ge.transform.lookAt(this.#he)}}(Ba);Ma.distance=15,Ma.attenuation=.01,Ma.dampingFactor=.2,Ma.azimuthSpeed=100,Ma.altitudeSpeed=100,Ma.deltaAzimuthPower=2,Ma.deltaAltitudePower=2,Ma.maxAltitude=5,Ma.minAltitude=-45,Ma.maxAzimuth=55,Ma.minAzimuth=-55,Ma.defaultAzimuth=10,Ma.defaultAltitude=-10,Ma.lookAtTarget=new e(0,3,0),Ba.subscribeOnStart((({actor:e})=>{e.setClearColor(new zt(0,0,0,1))})),Ba.onFixedUpdate=()=>{xa.isDown&&Ma.enabled&&Ma.setDelta(xa.deltaNormalizedInputPosition),Ma.fixedUpdate()};const Ea=new class extends Ot{constructor(e){super({...e,lightType:T}),this.shadowCamera=new pn(-1,1,-1,1,.1,1),this.shadowCamera.transform.setRotationY(180),this.addChild(this.shadowCamera)}update(e){super.update(e),this.updateShadowCamera()}}({intensity:.1,color:Ut.white});Ea.shadowCamera&&(Ea.shadowCamera.visibleFrustum=!1,Ea.castShadow=!0,Ea.shadowCamera.near=1,Ea.shadowCamera.far=15,Ea.shadowCamera.setOrthoSize(null,null,-7,7,-7,7),Ea.shadowMap=new Dn({gpu:Pa,width:1024,height:1024,type:Y,depthPrecision:X})),Ea.subscribeOnStart((({actor:t})=>{t.transform.setTranslation(new e(-8,8,-2)),t.transform.lookAt(new e(0,0,0))})),ya.add(Ea);const Ra=new ea({intensity:1.4,color:new Ut(1,1,1),distance:15,attenuation:1.06,coneCos:.8,penumbraCos:.9});Ra.shadowCamera&&(Ra.shadowCamera.visibleFrustum=!1,Ra.castShadow=!0,Ra.shadowCamera.near=.1,Ra.shadowCamera.far=Ra.distance,Ra.shadowCamera.setPerspectiveSize(1),Ra.shadowMap=new Dn({gpu:Pa,width:1024,height:1024,type:Y,depthPrecision:X})),Ra.subscribeOnStart((({actor:t})=>{t.transform.setTranslation(new e(3.4,8.1,0)),t.transform.lookAt(new e(2,0,0))})),ya.add(Ra);const Aa=new ea({intensity:1.4,color:new Ut(1,1,1),distance:15,attenuation:1.06,coneCos:.8,penumbraCos:.9});Aa.shadowCamera&&(Aa.shadowCamera.visibleFrustum=!1,Aa.castShadow=!0,Aa.shadowCamera.near=.1,Aa.shadowCamera.far=Aa.distance,Aa.shadowCamera.setPerspectiveSize(1),Aa.shadowMap=new Dn({gpu:Pa,width:1024,height:1024,type:Y,depthPrecision:X})),Aa.subscribeOnStart((({actor:t})=>{t.transform.setTranslation(new e(-3.4,8.1,0)),t.transform.lookAt(new e(-2,0,0))})),ya.add(Aa);const Fa=new Pn;Ca.depthOfFieldPass.focusDistance=18.5,Ca.depthOfFieldPass.focusRange=17;const Va=new class extends Rn{constructor({gpu:e}){super({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nuniform sampler2D uSrcTexture;\nuniform float uTargetWidth;\nuniform float uTargetHeight;\n\nuniform float uContrastThreshold;\nuniform float uRelativeThreshold;\nuniform float uSubpixelBlending;\n       \nstruct EdgeData {\n    bool isHorizontal;\n    float pixelStep;\n    float oppositeLuma;\n    float gradient;\n};\n\nstruct LuminanceData {\n    float center;\n    float top;\n    float right;\n    float bottom;\n    float left;\n    \n    float topLeft;\n    float topRight;\n    float bottomLeft;\n    float bottomRight;\n    \n    float highest;\n    float lowest;\n    float contrast;\n};\n\nfloat rgbToLuma(vec3 rgb) {\n    return dot(rgb, vec3(.299, .587, .114));\n}\n\nvec4 sampleTexture(sampler2D tex, vec2 coord) {\n    return texture(tex, coord);\n}\n\nvec4 sampleTextureOffset(sampler2D tex, vec2 coord, float offsetX, float offsetY) {\n    return sampleTexture(tex, coord + vec2(offsetX, offsetY));\n}\n\nLuminanceData sampleLuminanceNeighborhood(vec2 uv, vec2 texelSize) {\n    LuminanceData l;\n\n    \n    vec3 rgbTop = sampleTextureOffset(uSrcTexture, uv, 0., texelSize.y).xyz;\n    vec3 rgbRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, 0.).xyz;\n    vec3 rgbBottom = sampleTextureOffset(uSrcTexture, uv, 0., -texelSize.y).xyz;\n    vec3 rgbLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, 0.).xyz;\n    vec3 rgbCenter = sampleTextureOffset(uSrcTexture, uv, 0., 0.).xyz;\n\n    \n    vec3 rgbTopRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, texelSize.y).xyz;\n    vec3 rgbTopLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, texelSize.y).xyz;\n    vec3 rgbBottomRight = sampleTextureOffset(uSrcTexture, uv, texelSize.x, -texelSize.y).xyz;\n    vec3 rgbBottomLeft = sampleTextureOffset(uSrcTexture, uv, -texelSize.x, -texelSize.y).xyz;\n\n    \n    float lumaTop = rgbToLuma(rgbTop);\n    float lumaLeft = rgbToLuma(rgbLeft);\n    float lumaCenter = rgbToLuma(rgbCenter);\n    float lumaRight = rgbToLuma(rgbRight);\n    float lumaBottom = rgbToLuma(rgbBottom);\n\n    \n    float lumaTopLeft = rgbToLuma(rgbTopLeft);\n    float lumaTopRight = rgbToLuma(rgbTopRight);\n    float lumaBottomLeft = rgbToLuma(rgbBottomLeft);\n    float lumaBottomRight = rgbToLuma(rgbBottomRight);\n\n    \n    float lumaHighest = max(lumaCenter, max(max(lumaTop, lumaLeft), max(lumaBottom, lumaRight)));\n    float lumaLowest = min(lumaCenter, min(min(lumaTop, lumaLeft), min(lumaBottom, lumaRight)));\n    float lumaContrast = lumaHighest - lumaLowest;\n \n    l.top = lumaTop;\n    l.left = lumaLeft;\n    l.center = lumaCenter;\n    l.right = lumaRight;\n    l.bottom = lumaBottom;\n    \n    l.topLeft = lumaTopLeft;\n    l.topRight = lumaTopRight;\n    l.bottomLeft = lumaBottomLeft;\n    l.bottomRight = lumaBottomRight;\n    \n    l.highest = lumaHighest;\n    l.lowest = lumaLowest;\n    l.contrast = lumaContrast;\n    \n    return l;\n}\n\nbool shouldSkipPixel(LuminanceData l) {\n    return l.contrast < max(uContrastThreshold, l.highest * uRelativeThreshold);\n}\n\nfloat determinePixelBlendFactor(LuminanceData l) {\n    \n    \n    \n    \n \n    float determineEdgeFilter = 2. * (l.top + l.right + l.bottom + l.left);\n    determineEdgeFilter += l.topLeft + l.topRight + l.bottomLeft + l.bottomRight;\n    \n    \n    determineEdgeFilter *= 1. / 12.; \n    \n    \n    determineEdgeFilter = abs(determineEdgeFilter - l.center); \n    \n    \n    determineEdgeFilter = clamp(determineEdgeFilter / l.contrast, 0., 1.); \n    \n    \n    float pixelBlendFactor = smoothstep(0., 1., determineEdgeFilter); \n    \n    \n    pixelBlendFactor = pixelBlendFactor * pixelBlendFactor;\n    \n    \n    pixelBlendFactor *= uSubpixelBlending; \n    \n    return pixelBlendFactor;\n}\n\nEdgeData determineEdge(LuminanceData l, vec2 texelSize) {\n    EdgeData e;\n    \n    \n   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    float horizontal =\n        abs(l.top + l.bottom - 2. * l.center) * 2. +\n        abs(l.topRight + l.bottomRight - 2. * l.right) + \n        abs(l.topLeft + l.bottomLeft - 2. * l.left);\n        \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n        \n    float vertical = \n        abs(l.right + l.left - 2. * l.center) * 2. +\n        abs(l.topRight + l.topLeft - 2. * l.top) +\n        abs(l.bottomRight + l.bottomLeft - 2. * l.bottom);\n       \n    \n    \n        \n    e.isHorizontal = horizontal >= vertical;\n    \n    \n    \n    \n    \n    float positiveLuma = e.isHorizontal ? l.top : l.right;\n    float negativeLuma = e.isHorizontal ? l.bottom : l.left;\n    \n    \n\n    float positiveGradient = abs(positiveLuma - l.center);\n    float negativeGradient = abs(negativeLuma - l.center);\n    \n    \n  \n    e.pixelStep = e.isHorizontal ? texelSize.y : texelSize.x;\n\n    \n\n    if(positiveGradient < negativeGradient) {\n        \n        e.pixelStep = -e.pixelStep;\n        e.oppositeLuma = negativeLuma;\n        e.gradient = negativeGradient;\n    } else {\n        \n        e.oppositeLuma = positiveLuma;\n        e.gradient = positiveGradient;\n    }\n    \n    return e;\n}\n\nfloat determineEdgeBlendFactor(LuminanceData l, EdgeData e, vec2 uv, vec2 texelSize) {\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    float[10] edgeStepsArray = float[](1., 1.5, 2., 2., 2., 2., 2., 2., 2., 4.);\n    const int edgeStepCount = 10;\n    float edgeGuess = 8.;\n\n    vec2 uvEdge = uv; \n    vec2 edgeStep = vec2(0.);\n\n    \n    \n    if(e.isHorizontal) {\n        uvEdge.y += e.pixelStep * .5; \n        edgeStep = vec2(texelSize.x, 0.);\n    } else {\n        uvEdge.x += e.pixelStep * .5; \n        edgeStep = vec2(0., texelSize.y);\n    }\n\n    float edgeLuma = (l.center + e.oppositeLuma) * .5;\n    float gradientThreshold = e.gradient * .25;\n    \n    \n    \n\n    \n    vec2 puv = uvEdge + edgeStep * vec2(edgeStepsArray[0]);\n    float pLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, puv).xyz) - edgeLuma;\n    bool pAtEnd = abs(pLumaDelta) >= gradientThreshold;\n\n    \n    for(int i = 1; i < edgeStepCount && !pAtEnd; i++) {\n        if(!pAtEnd) {\n            puv += edgeStep * vec2(edgeStepsArray[i + 1]);\n            pLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, puv).xyz) - edgeLuma;\n            pAtEnd = abs(pLumaDelta) >= gradientThreshold;\n        }\n    }\n\n    if(!pAtEnd) {\n        puv += edgeStep * vec2(edgeGuess);\n    }\n    \n    \n    \n    \n   \n    vec2 nuv = uvEdge - edgeStep * vec2(edgeStepsArray[0]);\n    float nLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, nuv).xyz) - edgeLuma;\n    bool nAtEnd = abs(nLumaDelta) >= gradientThreshold;\n\n    \n    for(int i = 1; i < edgeStepCount && !nAtEnd; i++) {\n        if(!nAtEnd) {\n            nuv -= edgeStep * vec2(edgeStepsArray[i + 1]);\n            nLumaDelta = rgbToLuma(sampleTexture(uSrcTexture, nuv).xyz) - edgeLuma;\n            nAtEnd = abs(nLumaDelta) >= gradientThreshold;\n        }\n    }\n\n    if(!nAtEnd) {\n        nuv -= edgeStep * vec2(edgeGuess);\n    }\n    \n    \n    \n   \n    float pDistance, nDistance;\n    if(e.isHorizontal) {\n        pDistance = puv.x - uv.x;\n        nDistance = uv.x - nuv.x;\n    } else {\n        pDistance = puv.y - uv.y;\n        nDistance = uv.y - nuv.y;\n    }\n    \n    \n    \n    float shortestDistance;\n    bool deltaSign;\n    if(pDistance <= nDistance) {\n        shortestDistance = pDistance;\n        deltaSign = pLumaDelta >= 0.;\n    } else {\n        shortestDistance = nDistance;\n        deltaSign = nLumaDelta >= 0.;\n    }\n   \n    float edgeBlendFactor;\n    \n    if(deltaSign == (l.center - edgeLuma >= 0.)) {\n        \n        edgeBlendFactor = 0.;\n    } else {\n        \n        edgeBlendFactor = .5 - shortestDistance / (pDistance + nDistance);\n    }\n    \n    return edgeBlendFactor;\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    \n    vec2 texelSize = vec2(1. / uTargetWidth, 1. / uTargetHeight);\n    \n    LuminanceData l = sampleLuminanceNeighborhood(uv, texelSize);   \n\n    if(shouldSkipPixel(l)) {\n        outColor = sampleTexture(uSrcTexture, uv);\n        return;\n    }\n    \n    EdgeData e = determineEdge(l, texelSize);\n    float pixelBlend = determinePixelBlendFactor(l); \n    float edgeBlend = determineEdgeBlendFactor(l, e, uv, texelSize);\n    \n    float finalBlend = max(pixelBlend, edgeBlend);\n    \n    if(e.isHorizontal) {\n        uv.y += e.pixelStep * finalBlend;\n    } else {\n        uv.x += e.pixelStep * finalBlend;\n    }\n\n    outColor = sampleTexture(uSrcTexture, uv);\n    \n}",uniforms:[{name:"uContrastThreshold",type:ge,value:.0625},{name:"uRelativeThreshold",type:ge,value:.125},{name:"uSubpixelBlending",type:ge,value:.75}]})}setSize(e,t){super.setSize(e,t),this.material.uniforms.setValue(Ze,e),this.material.uniforms.setValue(Qe,t)}}({gpu:Pa});Va.enabled=!1,Fa.addPass(Va);const La=new class{constructor({gpu:e}){this.rowPasses=[],this.name="BufferVisualizerPass",this.enabled=!0,this.width=1,this.height=1,this.materials=[],this.fullViewTextureEnabled=!1,this.geometry=new En({gpu:e}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nfloat viewZToLinearDepth(float z, float near, float far) {\n    return (z + near) / (near - far);\n}\n\nfloat perspectiveDepthToLinearDepth(float rawDepth, float near, float far) {\n    float nz = near * rawDepth;\n    return -nz / (far * (rawDepth - 1.) - nz);\n}\n\nfloat perspectiveDepthToEyeDepth(float rawDepth, float near, float far) {\n    float depth = perspectiveDepthToLinearDepth(rawDepth, near, far);\n    return mix(near, far, depth);\n}\n\nvec3 reconstructWorldPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseViewProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 worldPos = inverseViewProjectionMatrix * clipPos;\n    return worldPos.xyz / worldPos.w;\n}\n\nvec3 reconstructViewPositionFromDepth(vec2 screenUV, float rawDepth, mat4 inverseProjectionMatrix) {\n    \n    vec4 clipPos = vec4(screenUV * 2. - 1., rawDepth * 2. - 1., 1.);\n    vec4 viewPos = inverseProjectionMatrix * clipPos;\n    return viewPos.xyz / viewPos.w;\n}\n\nfloat sampleRawDepthByViewPosition(\n    sampler2D depthTexture,\n    vec3 viewPosition,\n    mat4 projectionMatrix,\n    vec3 offset\n) {\n    vec4 offsetPosition = vec4(viewPosition + offset, 1.);\n    vec4 projectedPosition = projectionMatrix * offsetPosition;\n    vec3 projectedPositionNDC = projectedPosition.xyz / projectedPosition.w;\n    vec2 projectedPositionUV = projectedPositionNDC.xy * .5 + .5;\n    \n    return textureLod(depthTexture, projectedPositionUV, 0.).x;\n}\n\nuniform vec2 uTiling;\nuniform sampler2D uTextureCol0;\nuniform vec2 uTextureCol0UvOffset;\nuniform vec2 uTextureCol1UvOffset;\nuniform sampler2D uTextureCol2;\nuniform vec2 uTextureCol2UvOffset;\nuniform sampler2D uTextureCol3;\nuniform vec2 uTextureCol3UvOffset;\nuniform sampler2D uTextureCol4;\nuniform vec2 uTextureCol4UvOffset;\nuniform sampler2D uTextureCol5;\nuniform vec2 uTextureCol5UvOffset;\n\nuniform float uNearClip;\nuniform float uFarClip;\nuniform mat4 uInverseViewProjectionMatrix;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\n    vec2 tiling = uTiling;\n    \n\n    \n    vec2 depthUv = vUv * tiling + uTextureCol0UvOffset;\n    vec2 worldPositionUv = vUv * tiling + uTextureCol1UvOffset;\n    \n    \n    \n\n    float rawDepth = texture(uTextureCol0, depthUv).x * isArea(depthUv);\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n    \n    vec3 worldPosition = reconstructWorldPositionFromDepth(\n        worldPositionUv,\n        texture(uTextureCol0, worldPositionUv).x,\n        uInverseViewProjectionMatrix\n    );\n\n    vec4 depthColor = calcAreaColor(vec4(sceneDepth), vUv, tiling, vec2(0., 0.));\n    vec4 worldPositionColor = calcAreaColor(vec4(worldPosition, 1.), vUv, tiling, vec2(-1., 0.));\n    vec4 color2 = calcTextureAreaColor(uTextureCol2, vUv, tiling, uTextureCol2UvOffset);\n    vec4 color3 = calcTextureAreaColor(uTextureCol3, vUv, tiling, uTextureCol3UvOffset);\n    vec4 color4 = calcTextureAreaColor(uTextureCol4, vUv, tiling, uTextureCol4UvOffset);\n    vec4 color5 = calcTextureAreaColor(uTextureCol5, vUv, tiling, uTextureCol5UvOffset);\n\n    outColor = depthColor + worldPositionColor + color2 + color3 + color4 + color5;\n}",uniforms:[{name:"uNearClip",type:ge,value:.1},{name:"uFarClip",type:ge,value:1},{name:"uInverseViewProjectionMatrix",type:ie,value:t.identity}]}),tiles:new Map([[Cr,{label:"depth",type:"Texture"}],["worldPosition",{type:"Other",uniformPrefix:"uWorldPosition"}],[Dr,{type:"Texture"}],[Br,{type:"Texture"}],[Er,{type:"Texture"}],[Mr,{type:"Texture"}]])}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:Sr,srcTextureEnabled:!1}),tiles:new Map([[Rr,{type:"Texture"}],[`${Ar}0`,{type:"Texture"}],[`${Ar}1`,{type:"Texture"}],[`${Ar}2`,{type:"Texture"}],[`${Ar}3`,{type:"Texture"}]])}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:Sr,srcTextureEnabled:!1}),tiles:new Map([[Fr,{type:"Texture"}],[Vr,{type:"Texture"}],[Lr,{type:"Texture",label:"combine ssr"}],[_r,{type:"Texture"}],[Ir,{type:"Texture"}],[Nr,{type:"Texture",label:"combine fog"}]])}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:Sr,srcTextureEnabled:!1}),tiles:new Map([[Ur,{type:"Texture",label:"dof"}]])}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:Sr,srcTextureEnabled:!1}),tiles:new Map([[Or,{type:"Texture",label:"bloom blur mip4"}],[zr,{type:"Texture",label:"bloom blur mip8"}],[kr,{type:"Texture",label:"bloom blur mip16"}],[jr,{type:"Texture",label:"bloom blur mip32"}],[Gr,{type:"Texture",label:"bloom blur mip64"}],[Hr,{type:"Texture",label:"bloom"}]])}),this.rowPasses.push({pass:new zn({gpu:e,fragmentShader:Sr,srcTextureEnabled:!1}),tiles:new Map([])}),this.compositePass=new zn({gpu:e,name:"BufferVisualizerPass",fragmentShader:"#version 300 es\n\nprecision mediump float;\n\n#define saturate(a) clamp(a, 0., 1.)\n\nfloat noise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat isArea(vec2 uv) {\n    return step(0., uv.x) * (1. - step(1., uv.x)) * step(0., uv.y) * (1. - step(1., uv.y));\n}\n\nvec4 calcAreaColor(vec4 color, vec2 uv, vec2 tiling, vec2 offset) {\n    return color * isArea(uv * tiling + offset);\n}\n\nvec4 calcTextureAreaColor(sampler2D tex, vec2 uv, vec2 tiling, vec2 offset) {\n    return calcAreaColor(texture(tex, uv * tiling + offset), uv, tiling, offset);\n}\n\nuniform vec2 uTiling;\nuniform sampler2D uRow0Texture;\nuniform sampler2D uRow1Texture;\nuniform sampler2D uRow2Texture;\nuniform sampler2D uRow3Texture;\nuniform sampler2D uRow4Texture;\nuniform sampler2D uRow5Texture;\nuniform sampler2D uFullViewTexture;\n\nuniform float uFullViewTextureEnabled;\n\nin vec2 vUv;\n\nout vec4 outColor;\n\nvoid main() {\n    vec2 tiling = vec2(1., 6.);\n    \n    vec4 color0 = calcTextureAreaColor(uRow0Texture, vUv, tiling, vec2(0., -5.));\n    vec4 color1 = calcTextureAreaColor(uRow1Texture, vUv, tiling, vec2(0., -4.));\n    vec4 color2 = calcTextureAreaColor(uRow2Texture, vUv, tiling, vec2(0., -3.));\n    vec4 color3 = calcTextureAreaColor(uRow3Texture, vUv, tiling, vec2(0., -2.));\n    vec4 color4 = calcTextureAreaColor(uRow4Texture, vUv, tiling, vec2(0., -1.));\n    vec4 color5 = calcTextureAreaColor(uRow5Texture, vUv, tiling, vec2(0., 0.));\n    outColor = mix(\n        color0 + color1 + color2 + color3 + color4 + color5,\n        texture(uFullViewTexture, vUv),\n        step(.5, uFullViewTextureEnabled)\n    );\n}",srcTextureEnabled:!1,uniforms:[{name:"uFullViewTexture",type:se,value:e.dummyTextureBlack},{name:"uFullViewTextureEnabled",type:ge,value:0},...Vn.range(6).map(((t,n)=>[{name:`uRow${n}Texture`,type:se,value:e.dummyTextureBlack}])).flat(),...Rn.commonUniforms]}),this.rowPasses.forEach((({pass:e})=>this.materials.push(e.material))),this.materials.push(this.compositePass.material),this.rowPasses.forEach((({pass:t,tiles:n},r)=>{let a=0;t.material.uniforms.addValue("uTiling",ue,new Hn(6,1));for(const[i,o]of n){const s=o.uniformNamePrefix||"uTextureCol",l=`${s}${a}`,u=`${l}UvOffset`,c=-a;o.uniformNamePrefix||(n.get(i).uniformNamePrefix=s),"Texture"===o.type&&(n.get(i).uniformNameTexture=l),n.get(i).uniformNameUvOffset=u,0===r?(t.material.uniforms.addValue(u,ue,new Hn(c,0)),"Texture"===o.type&&t.material.uniforms.addValue(l,se,e.dummyTextureBlack)):(t.material.uniforms.addValue(u,ue,new Hn(c,0)),t.material.uniforms.addValue(l,se,e.dummyTextureBlack)),a++}})),this.compositePass.material.uniforms.addValue("uTiling",ue,new Hn(1,6));const n=document.createElement("style");n.textContent="\n.buffer-visualizer-pass {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    display: grid;\n    grid-template-rows: repeat(6, 1fr);\n}\n.buffer-visualizer-pass.hidden {\n    display: none;\n}\n.buffer-visualizer-pass-tile {\n    display: flex;\n    justify-content: flex-start;\n    align-items: flex-end;\n    font-size: 9px;\n    line-height: 1em;\n    font-weight: bold;\n    text-shadow: 1px 1px #333;\n    padding: 4px;\n}\n\n.buffer-visualizer-pass-row {\n    // display: flex;\n    display: grid;\n    grid-template-columns: repeat(6, 1fr);\n}\n        ",document.head.appendChild(n),this.dom=document.createElement("div"),this.dom.classList.add("buffer-visualizer-pass");const r=document.createDocumentFragment();this.rowPasses.forEach((({tiles:e},t)=>{let n=0;const a=document.createElement("div");a.classList.add("buffer-visualizer-pass-row");for(const[r,i]of e){const e=`[${n}, ${t}] ${i.label||r}`,o=document.createElement("div");o.classList.add("buffer-visualizer-pass-tile");const s=document.createElement("p");s.textContent=e,o.appendChild(s),a.appendChild(o),n++}r.appendChild(a)})),this.dom.appendChild(r),document.body.appendChild(this.dom),this.hideDom()}get renderTarget(){return this.compositePass.renderTarget}setSize(e,t){this.width=e,this.height=t,this.rowPasses.forEach((({pass:e})=>{e.setSize(this.width,this.height/6)})),this.compositePass.setSize(this.width,this.height)}setRenderTarget(e,t,n){}update(){}showDom(){this.dom.classList.remove("hidden")}hideDom(){this.dom.classList.add("hidden")}render(e){const{gpu:t,renderer:n,lightActors:r}=e,a=n.realWidth,i=n.realHeight;this.geometry.start(),this.rowPasses.forEach((({pass:e,tiles:t})=>{r?.directionalLight&&t.has(Rr)&&e.material.uniforms.setValue(t.get(Rr).uniformNameTexture,r.directionalLight.shadowMap.read.depthTexture),r?.spotLights&&r.spotLights.forEach(((n,r)=>{const a=`${Ar}${r}`;t.has(a)&&n.shadowMap&&e.material.uniforms.setValue(t.get(a).uniformNameTexture,n.shadowMap.read.depthTexture)})),t.has(Cr)&&e.material.uniforms.setValue(t.get(Cr).uniformNameTexture,n.depthPrePassRenderTarget.depthTexture),t.has(Dr)&&e.material.uniforms.setValue(t.get(Dr).uniformNameTexture,n.gBufferRenderTargets.gBufferATexture),t.has(Br)&&e.material.uniforms.setValue(t.get(Br).uniformNameTexture,n.gBufferRenderTargets.gBufferBTexture),t.has(Mr)&&e.material.uniforms.setValue(t.get(Mr).uniformNameTexture,n.gBufferRenderTargets.gBufferCTexture),t.has(Er)&&e.material.uniforms.setValue(t.get(Er).uniformNameTexture,n.gBufferRenderTargets.gBufferDTexture),t.has(Fr)&&e.material.uniforms.setValue(t.get(Fr).uniformNameTexture,n.ambientOcclusionPass.renderTarget.read.texture),t.has(Vr)&&e.material.uniforms.setValue(t.get(Vr).uniformNameTexture,n.deferredShadingPass.renderTarget.read.texture),t.has(Lr)&&e.material.uniforms.setValue(t.get(Lr).uniformNameTexture,n.ssrPass.renderTarget.read.texture),t.has(_r)&&e.material.uniforms.setValue(t.get(_r).uniformNameTexture,n.lightShaftPass.renderTarget.read.texture),t.has(Ir)&&e.material.uniforms.setValue(t.get(Ir).uniformNameTexture,n.volumetricLightPass.renderTarget.read.texture),t.has(Ur)&&e.material.uniforms.setValue(t.get(Ur).uniformNameTexture,n.depthOfFieldPass.renderTarget.read.texture),t.has(Nr)&&e.material.uniforms.setValue(t.get(Nr).uniformNameTexture,n.fogPass.renderTarget.read.texture),t.has(Or)&&e.material.uniforms.setValue(t.get(Or).uniformNameTexture,n.bloomPass.renderTargetBlurMip4.read.texture),t.has(zr)&&e.material.uniforms.setValue(t.get(zr).uniformNameTexture,n.bloomPass.renderTargetBlurMip8.read.texture),t.has(kr)&&e.material.uniforms.setValue(t.get(kr).uniformNameTexture,n.bloomPass.renderTargetBlurMip16.read.texture),t.has(jr)&&e.material.uniforms.setValue(t.get(jr).uniformNameTexture,n.bloomPass.renderTargetBlurMip32.read.texture),t.has(Gr)&&e.material.uniforms.setValue(t.get(Gr).uniformNameTexture,n.bloomPass.renderTargetBlurMip64.read.texture),t.has(Hr)&&e.material.uniforms.setValue(t.get(Hr).uniformNameTexture,n.bloomPass.renderTarget.read.texture)})),this.rowPasses[0].pass.material.uniforms.setValue("uInverseViewProjectionMatrix",e.targetCamera.inverseViewProjectionMatrix),t.setSize(0,0,this.width,this.height/6),this.rowPasses.forEach((({pass:t,tiles:n},r)=>{n.size>0&&(t.render({...e,isLastPass:!1}),this.compositePass.material.uniforms.setValue(`uRow${r}Texture`,t.renderTarget.read.texture))})),this.compositePass.material.uniforms.setValue("uFullViewTexture",n.gBufferRenderTargets.gBufferBTexture),this.compositePass.material.uniforms.setValue("uFullViewTextureEnabled",this.fullViewTextureEnabled?1:0),t.setSize(0,0,a,i),this.compositePass.render({...e})}}({gpu:Pa});La.enabled=!1,Fa.addPass(La),Fa.enabled=!0,Ba.setPostProcess(Fa);const _a="/labs/street-light/assets/",Ia=async()=>await yr({gpu:Pa,dir:_a,path:"street-light-full.gltf"}),Na=async t=>{const n=await yr({gpu:Pa,dir:_a,path:"butterfly-forward-thin-2.gltf"}),r=n.transform.children[0].transform.children[0];r.name="butterfly",r.animator=n.animator,r.setAnimationClips(n.animator.animationClips),r.subscribeOnStart((()=>{}));const a={position:[],scale:[],rotation:[],velocity:[],color:[]};Vn.range(t).forEach((()=>{a.position.push([0,0,0]);const e=.25*Math.random()+.25;a.scale.push([e,e,e]),a.rotation.push([0,0,0]),a.velocity.push([0,0,0]);const t=Ut.fromRGB(Math.floor(180*Math.random()+20),Math.floor(20*Math.random()+20),Math.floor(180*Math.random()+20));a.color.push([...t.elements])}));const i=Vn.range(t).map((()=>30*Math.random())).flat();r.castShadow=!0,r.geometry.instanceCount=t,r.geometry.setAttribute(new Jt({name:ae.InstancePosition,data:new Float32Array(a.position.flat()),size:3,divisor:1})),r.geometry.setAttribute(new Jt({name:ae.InstanceScale,data:new Float32Array(a.scale.flat()),size:3,divisor:1})),r.geometry.setAttribute(new Jt({name:ae.InstanceRotation,data:new Float32Array(a.rotation.flat()),size:3,divisor:1})),r.geometry.setAttribute(new Jt({name:ae.InstanceAnimationOffset,data:new Float32Array(i),size:1,divisor:1})),r.geometry.setAttribute(new Jt({name:ae.InstanceVertexColor,data:new Float32Array(a.color.flat()),size:4,divisor:1})),r.geometry.setAttribute(new Jt({name:ae.InstanceVelocity,data:new Float32Array(a.velocity.flat()),size:3,divisor:1})),r.material=new wr({metallic:0,roughness:1,receiveShadow:!0,isSkinning:!0,gpuSkinning:!0,isInstancing:!0,useInstanceLookDirection:!0,useVertexColor:!0,faceSide:N});const o=(t=>{const n=new Float32Array(Vn.range(t).map((()=>[10*Math.random()-5,4*Math.random()+2,10*Math.random()-5])).flat()),r=new Float32Array(Vn.range(t).map((()=>[0,0,0])).flat()),a=new Float32Array(Vn.range(t,!0).map((e=>[e,e])).flat()),i=new Zr({gpu:Pa,attributes:[new Jt({name:"aPosition",data:n,size:3,usageType:ne}),new Jt({name:"aVelocity",data:r,size:3,usageType:ne}),new Jt({name:"aSeed",data:a,size:2,usageType:te})],varyings:[{name:"vPosition",data:new Float32Array(n)},{name:"vVelocity",data:new Float32Array(r)}],vertexShader:"#version 300 es\n\n        precision highp float;\n\n        // TODO: \n        layout(location = 0) in vec3 aPosition;\n        layout(location = 1) in vec3 aVelocity;\n        layout(location = 2) in vec2 aSeed;\n\n        out vec3 vPosition;\n        // out mat4 vTransform;\n        out vec3 vVelocity;\n\n\nlayout (std140) uniform ubCommon {\n    float uTime;\n};\n\n        // uniform float uTime;\n        uniform vec2 uNormalizedInputPosition;\n        uniform vec3 uAttractTargetPosition;\n        uniform float uAttractRate;\n\n        // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n        float noise(vec2 seed)\n        {\n            return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n        }\n        \n        void main() {\n            vPosition = aPosition + aVelocity;\n            vec3 target = uAttractTargetPosition;\n            vec2 seed = aSeed;\n            float rand = noise(seed);\n            target += vec3(\n                cos(uTime + rand * 100. + seed.x) * (2. + rand * 1.),\n                sin(uTime - rand * 400. + seed.x) * (1. + rand * 1.) + 1.,\n                cos(uTime - rand * 300. + seed.x) * (2. + rand * 1.)\n            );\n            vec3 v = target - vPosition;\n            vec3 dir = normalize(v);\n            vVelocity = mix(\n                aVelocity,\n                dir * (.1 + uAttractRate * .1),\n                .03 + sin(uTime * .2 + rand * 100.) * .02\n            );\n        }\n        ",uniforms:[{name:"uNormalizedInputPosition",type:ue,value:Hn.zero},{name:"uAttractTargetPosition",type:he,value:e.zero},{name:"uAttractRate",type:ge,value:0}],uniformBlockNames:[wt],drawCount:t});return i.uniformBlockNames.forEach((e=>{const t=Ca.globalUniformBufferObjects.find((({uniformBufferObject:t})=>t.blockName===e));if(!t)return;const n=Pa.bindUniformBlockAndGetBlockIndex(t.uniformBufferObject,i.shader,e);i.uniforms.addUniformBlock(n,t.uniformBufferObject,[])})),i})(na);let s=0;return r.onUpdate=({deltaTime:t})=>{o.uniforms.setValue("uNormalizedInputPosition",xa.normalizedInputPosition),o.uniforms.setValue("uAttractTargetPosition",e.addVectors(ma.transform.position,new e(0,1,0))),s+=(xa.isDown?1:-1)*t*2,s=_n(s,0,1),o.uniforms.setValue("uAttractRate",s),Pa.updateTransformFeedback({shader:o.shader,uniforms:o.uniforms,vertexArrayObject:o.write.vertexArrayObject,transformFeedback:o.write.transformFeedback,drawCount:o.drawCount}),o.swap(),da.geometry.vertexArrayObject.replaceBuffer(ae.InstancePosition,o.read.vertexArrayObject.findBuffer("aPosition")),da.geometry.vertexArrayObject.replaceBuffer(ae.InstanceVelocity,o.read.vertexArrayObject.findBuffer("aVelocity")),da.geometry.instanceCount=oa.instanceNum},r};(async()=>{const t=await tn("/labs/street-light/assets/particle-smoke.png"),n=new en({gpu:Pa,img:t});pa=await async function(e,t,n,r,a,i,o){const s=[{axis:E,path:t},{axis:R,path:n},{axis:A,path:r},{axis:F,path:a},{axis:V,path:i},{axis:L,path:o}];return await Promise.all(s.map((async({axis:e,path:t})=>({axis:e,img:await tn(t)})))).then((t=>rn(e,...t.map((({img:e})=>e)))))}(Pa,"/labs/street-light/assets/px.jpg","/labs/street-light/assets/nx.jpg","/labs/street-light/assets/py.jpg","/labs/street-light/assets/ny.jpg","/labs/street-light/assets/pz.jpg","/labs/street-light/assets/nz.jpg");const r=new vn({gpu:Pa,cubeMap:pa,diffuseIntensity:.2,specularIntensity:.2,renderMesh:!1});ca=await(async()=>await yr({gpu:Pa,dir:_a,path:"street-floor-separete.gltf"}))(),ya.add(ca),ca.transform.children.forEach((e=>{e.type===P&&(e.castShadow=!0)})),(ca?.transform.children[0]).materials[0].uniforms.setValue("uMetallic",.5),(ca?.transform.children[0]).materials[0].uniforms.setValue("uRoughness",1),ha=await Ia(),ha.subscribeOnStart((()=>{ha.transform.position=new e(6,0,0),ha.transform.scale=e.fill(1.8)})),ya.add(ha),fa=await Ia(),fa.subscribeOnStart((()=>{fa.transform.rotation=new Lt(0,180,0),fa.transform.position=new e(-6,0,0),fa.transform.scale=e.fill(1.8)})),ya.add(fa),ma=await(async e=>{const t=(await yr({gpu:Pa,dir:_a,path:"sphere-32x32.gltf"})).transform.children[0];return t.castShadow=!0,t.material=e,t})(new Qr({emissiveColor:new Ut(3,3,3,1)})),ma.subscribeOnStart((({actor:t})=>{t.transform.setScaling(e.fill(.5))})),ma.onFixedUpdate=()=>{const t=function(t,n){const r=t.origin,a=t.dir,i=e.dot(t.dir,n.normal);if(Math.abs(i)<1e-4)return null;const o=n.point.clone().subVector(r),s=e.dot(o,n.normal)/i;if(s<0)return null;const l=a.clone().scale(s);return e.addVectors(r,l)}(Ba.viewpointToRay(new Hn(xa.normalizedInputPosition.x,1-xa.normalizedInputPosition.y)),new ta(e.zero,e.up));if(t){const n=_n(t.x,-5,5),r=_n(t.z,-5,5),a=new e(n,1,r);ma.transform.setTranslation(a)}},da=await Na(na);const a=48,i=new cn({gpu:Pa,attributes:[new Jt({name:ae.Position.toString(),data:new Float32Array(Vn.range(a).map((()=>{const e=6*Math.random()-4,t=.5*Math.random(),n=5.4*Math.random()-1.4;return[e,t,n,e,t,n,e,t,n,e,t,n]})).flat()),size:3}),new Jt({name:ae.Uv.toString(),data:new Float32Array(Vn.range(a).map((()=>[0,1,0,0,1,1,1,0])).flat()),size:2}),new Jt({name:ae.Color.toString(),data:new Float32Array(Vn.range(a).map((()=>{const e=150*Math.random()+50,t=75*Math.random()+25,n=Ut.fromRGB(e,e,e,t);return[...n.elements,...n.elements,...n.elements,...n.elements]})).flat()),size:4}),new Jt({name:"aBillboardSize",data:new Float32Array(Vn.range(a).map((()=>{const e=6.25*Math.random()+1.75;return[e,e,e,e]})).flat()),size:1}),new Jt({name:"aBillboardRateOffset",data:new Float32Array(Vn.range(a).map((()=>{const e=Math.random();return[e,e,e,e]})).flat()),size:1})],indices:Vn.range(a).map(((e,t)=>{const n=4*t;return[0+n,1+n,2+n,2+n,1+n,3+n]})).flat(),drawCount:288}),o=new qt({vertexShader:"#version 300 es\n\n#pragma DEFINES\n\n#pragma ATTRIBUTES\n\nout vec2 vUv;\nout vec3 vWorldPosition;\nout vec3 vNormal;\n\nout vec4 vVertexColor;\nout vec4 vViewPosition;\nout vec4 vClipPosition;\n\nout float vParticleId;\n\n#pragma ENGINE_UNIFORMS\n#pragma TRANSFORM_VERTEX_UNIFORMS\n\nuniform vec2[4] uBillboardPositionConverters;\n\nvoid main() {\n    int particleId = int(mod(float(gl_VertexID), 4.));\n    float fParticleId = float(particleId);\n    vParticleId = fParticleId;\n\n    float t = 3.;\n    float rateOffset = mod(fParticleId, 4.) * .1;\n    float r = mod((((uTime + rateOffset) / t) + aBillboardRateOffset), 1.);\n\n    vec4 localPosition = vec4(aPosition, 1.);\n\n    localPosition.x += mix(0., 4., r) * mix(.4, .8, aBillboardRateOffset);\n    localPosition.z += mix(0., 2., r) * mix(-.4, -.8, aBillboardRateOffset);\n\n    // assign common varyings \n    vUv = aUv; \n    vVertexColor = aColor;\n    vVertexColor.a *= (smoothstep(0., .2, r) * (1. - smoothstep(.2, 1., r)));\n    \n    vec4 worldPosition = uWorldMatrix * localPosition;\n  \n    vWorldPosition = worldPosition.xyz;\n    \n    vec4 viewPosition = uViewMatrix * worldPosition;\n    viewPosition.xy += uBillboardPositionConverters[particleId] * aBillboardSize;\n    vViewPosition = viewPosition;\n    \n    vec4 clipPosition = uProjectionMatrix * viewPosition;\n \n    gl_Position = clipPosition;\n    \n    vClipPosition = clipPosition;\n}",fragmentShader:"#version 300 es\n\n#pragma DEFINES\n\nprecision highp float;\n\nin float vParticleId;\nin vec2 vUv;\nin vec4 vVertexColor;\nin vec4 vViewPosition;\nin vec4 vClipPosition;\n\nout vec4 outColor;\n// layout (location = 0) out vec4 outBaseColor;\n// layout (location = 1) out vec4 outNormalColor;\n\nuniform sampler2D uParticleMap;\nuniform sampler2D uDepthTexture;\nuniform float uNearClip;\nuniform float uFarClip;\n\n#pragma ENGINE_UNIFORMS\n#pragma DEPTH_FUNCTIONS\n\nvoid main() {\n    vec4 texColor = texture(uParticleMap, vUv);\n    vec3 baseColor = vVertexColor.xyz;\n    float alpha = texColor.x * vVertexColor.a;\n    \n    vec4 fadeColor = texture(\n        uParticleMap,\n        vUv + vec2(mod(uTime * .06 + float(vParticleId) * .1, 1.), 0.)\n    );\n    alpha *= fadeColor.x * 2.;\n    \n    // calc soft fade\n    \n    float rawDepth = texelFetch(uDepthTexture, ivec2(gl_FragCoord.xy), 0).x;\n    float sceneDepth = perspectiveDepthToLinearDepth(rawDepth, uNearClip, uFarClip);\n    // for debug\n    // outColor = vec4(vec3(sceneDepth), 1.);\n\n    float currentDepth = viewZToLinearDepth(vViewPosition.z, uNearClip, uFarClip);\n    // for debug\n    // outColor = vec4(vec3(currentDepth), 1.);\n    \n    float diffDepth = abs(sceneDepth) - abs(currentDepth);\n    float softFade = smoothstep(0., .02, diffDepth);\n    // for debug\n    // outColor = vec4(vec3(softFade), 1.);\n    \n    // result\n    \n    // outBaseColor = vec4(1., 0., 0., 1.);\n    // outColor = vec4(1., 0., 0., 1.);\n\n    float fadedAlpha = alpha * softFade;\n    if(fadedAlpha < .01) {\n        discard;\n    }\n\n    outColor = vec4(baseColor, fadedAlpha);\n    // outBaseColor = vec4(baseColor, fadedAlpha);\n    // outNormalColor = vec4(0., 0., 1., 1.); // dummy\n}\n        ",uniforms:[{name:"uParticleMap",type:se,value:n},{name:"uBillboardPositionConverters",type:ce,value:[new Hn(-1,1),new Hn(-1,-1),new Hn(1,1),new Hn(1,-1)]},{name:je,type:se,value:null},{name:nt,type:ge,value:Ba.near},{name:rt,type:ge,value:Ba.far}],blendType:h,depthWrite:!1,uniformBlockNames:[wt]}),s=new hn({geometry:i,material:o});ya.add(ma),ya.add(da),ya.add(r),ya.add(s);const l=()=>{la=Ta.offsetWidth,ua=Ta.offsetHeight,xa.setSize(la,ua),Da.setSize(la,ua)};Da.onBeforeStart=()=>{l(),window.addEventListener("resize",l),Ca.fogPass.fogColor=Ut.black,Ca.fogPass.fogDensity=.023,Ca.fogPass.fogDensityAttenuation=.065,Ca.fogPass.distanceFogStart=18,Ca.fogPass.distanceFogPower=.29,Ca.depthOfFieldPass.focusDistance=17.78,Ca.depthOfFieldPass.focusRange=9.8,Ca.depthOfFieldPass.bokehRadius=5.55,Ca.bloomPass.bloomAmount=.26,Ca.bloomPass.threshold=1.534,Ca.bloomPass.tone=.46,Ma.start()},Da.onBeforeUpdate=()=>{sa||function(){sa=new Kr,sa.addSliderDebugger({label:"instance num",minValue:1,maxValue:na,initialValue:64,stepValue:1,onChange:e=>{oa.instanceNum=e}}),sa.addBorderSpacer(),sa.addSliderDebugger({label:"volume",minValue:0,maxValue:2,stepValue:.01,initialValue:1,onChange:e=>{ga&&ga.setVolume(e)}}),sa.addSliderDebugger({label:"seek",minValue:0,maxValue:24,stepValue:1,initialValue:0,onChange:e=>{ra=e}}),sa.addButtonDebugger({buttonLabel:"play sound",onClick:()=>{ga&&ga.stop(),ga=new Jr(Pa,"#version 300 es\n\nprecision highp float;\n\nuniform float uBlockOffset;\nuniform float uSampleRate;\n\nout vec2 vSound;\n\n#define BPM 110.\n#define PI 3.1415\n#define TAU 6.2831\n\n#define T1 1.\n#define T2 2.\n#define T4 4.\n#define T8 8.\n#define T16 16.\n#define T32 32.\n\n#define N2(a, b) (a | (b << 8))\n#define N3(a, b, c) (a | (b << 8) | (c << 16))\n#define N4(a, b, c, d) (a | (b << 8) | (c << 16) | (d << 24))\n\n#define O(a) 0, a\n\n#define S(a) 1, a\n\n#define E2(a) 40, a\n#define F2(a) 41, a\n#define Fsh2(a) 42, a\n#define G2(a) 43, a\n#define A2(a) 45, a\n#define B2(a) 47, a\n#define C3(a) 48, a\n#define D3(a) 50, a\n#define E3(a) 52, a\n#define F3(a) 53, a\n#define Fsh3(a) 54, a\n#define G3(a) 55, a\n#define A3(a) 57, a\n#define B3(a) 59, a\n#define C4(a) 60, a\n#define D4(a) 62, a\n#define E4(a) 64, a\n#define F4(a) 65, a\n#define Fsh4(a) 66, a\n#define G4(a) 67, a\n#define A4(a) 69, a\n#define B4(a) 71, a\n#define C5(a) 72, a\n#define D5(a) 74, a\n#define E5(a) 76, a\n#define F5(a) 77, a\n#define G5(a) 79, a\n#define A5(a) 81, a\n#define B5(a) 83, a\n#define C6(a) 84, a\n#define D6(a) 86, a\n#define E6(a) 88, a\n\n#define CM2(a) N3(36, 40, 43), a\n#define DM2(a) N3(38, 42, 45), a\n#define Em2(a) N3(40, 43, 47), a\n#define Fshdim2(a) N3(42, 45, 48), a\n#define GM2(a) N3(43, 47, 50), a\n#define Am2(a) N3(45, 48, 52), a\n#define Bm2(a) N3(47, 50, 54), a\n#define CM3(a) N3(48, 52, 55), a\n#define DM3(a) N3(50, 54, 57), a\n#define Em3(a) N3(52, 55, 59), a\n#define Fshdim3(a) N3(53, 56, 59), a\n#define GM3(a) N3(55, 59, 62), a\n#define Am3(a) N3(57, 60, 64), a\n#define Bm3(a) N3(59, 62, 66), a\n#define CM4(a) N3(60, 64, 67), a\n#define DM4(a) N3(62, 66, 69), a\n#define Em4(a) N3(64, 67, 71), a\n#define Fshdim4(a) N3(65, 68, 71), a\n#define GM4(a) N3(67, 71, 74), a\n#define Am4(a) N3(69, 72, 76), a\n#define Bm4(a) N3(71, 74, 78), a\n#define CM5(a) N3(72, 76, 79), a\n#define DM5(a) N3(74, 78, 81), a\n#define Em5(a) N3(76, 79, 83), a\n#define Fshdim5(a) N3(77, 80, 83), a\n#define GM5(a) N3(79, 83, 86), a\n#define Am5(a) N3(81, 84, 88), a\n#define Bm5(a) N3(83, 86, 90), a\n#define CM6(a) N3(84, 88, 91), a\n#define DM6(a) N3(86, 90, 93), a\n#define Em6(a) N3(88, 91, 95), a\n\nfloat chord(float n) {\n    if(n < 1.) {\n        return 0.;\n    }\n    return (\n    n < 2. ? 55. :\n    n < 3. ? 58. :\n    n < 4. ? 62. :\n    65.\n    );\n}\n\nvec4 noise(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(.1050, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 55.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat noise2(float phi) { return fract(sin(phi * 0.055753) * 122.3762) * 4.0 - 3.0; }\n\nfloat quan(float s, float c) {\n    return floor(s / c) * c;\n}\n\nfloat nse(float x) {\n    return fract(sin(x * 110.082) * 19871.8972);\n}\n\nfloat dist(float s, float d) {\n    return clamp(s * d, -1., 1.);\n}\n\nfloat timeToBeat(float time) {\n    return time / 60. * BPM;\n}\n\nfloat beatToTime(float beat) {\n    return beat / BPM * 60.;\n}\n\nfloat noteToFreq(float n) {\n    return 440. * pow(2., (n - 69.) / 12.);\n}\n\nfloat sine(float freq, float time) {\n    return sin(freq * TAU * time);\n}\n\nfloat sine(float phase) {\n    return sin(TAU * phase);\n}\n\nfloat rhy(float time, float fade) {\n    return pow(fract(-time), 6. - fade * 3.);\n}\n\nvec2 delay(float time, float dt) {\n    return exp(-2. * dt) * sin(6.4831 * 440. * time) * vec2(rhy(time - dt * .3, dt), rhy(time - dt * .5, dt));\n}\n\nfloat saw(float note, float phase) {\n    return 2. * fract(phase) - 1.;\n}\n\nfloat square(float phase) {\n    return fract(phase) < .5 ? -1. : 1.;\n}\n\nfloat triangle(float phase) {\n    return 1. - 4. * abs(fract(phase) - .5);\n}\n\nfloat lowPassFilter(float inp, float cut_lp, float res_lp) {\n    float n1 = 0.0;\n    float n2 = 0.0;\n    float n3 = 0.0;\n    float n4 = 0.0;\n    float fb_lp = 0.0;\n    float fb_hp = 0.0;\n    float hp = 0.0;\n    float p4=1.0e-24;\n    fb_lp \t= res_lp+res_lp/(1.0-cut_lp + 1e-20);\n    n1 \t\t= n1+cut_lp*(inp-n1+fb_lp*(n1-n2))+p4;\n    n2\t\t= n2+cut_lp*(n1-n2);\n    return n2;\n}\n\nfloat base( float note, float time )\n{\n    float freq = noteToFreq(note);\n    float ph = 1.0;\n    ph *= sin(6.283185*freq*time*2.0);\n    ph *= 0.5+0.5*max(0.0,5.0-0.01*freq);\n    ph *= exp(-time*freq*0.2);\n\n    float y = 0.0;\n    y += 0.70*sin(1.00*TAU*freq*time+ph)*exp2(-0.7*0.007*freq*time);\n    y += 0.20*sin(2.01*TAU*freq*time+ph)*exp2(-0.7*0.011*freq*time);\n    y += 0.20*sin(3.01*TAU*freq*time+ph)*exp2(-0.7*0.015*freq*time);\n    y += 0.16*sin(4.01*TAU*freq*time+ph)*exp2(-0.7*0.018*freq*time);\n    y += 0.13*sin(5.01*TAU*freq*time+ph)*exp2(-0.7*0.021*freq*time);\n    y += 0.10*sin(6.01*TAU*freq*time+ph)*exp2(-0.7*0.027*freq*time);\n    y += 0.09*sin(8.01*TAU*freq*time+ph)*exp2(-0.7*0.030*freq*time);\n    y += 0.07*sin(9.01*TAU*freq*time+ph)*exp2(-0.7*0.033*freq*time);\n\n    y += 0.35*y*y*y;\n    y += 0.10*y*y*y;\n\n    y *= 1.0 + 1.5*exp(-8.0*time);\n    y *= clamp( time/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)/10.0,0.0,1.0);\n    y *= .1;\n    return y;\n}\n\nvec2 kick(float note, float time) {\n    \n    \n    \n\n    float amp = exp(-3.2 * time);\n    float phase = 35. * time - 16. * exp(-60. * time);\n    return vec2(amp * sine(phase));\n}\n\nvec2 kickAttack(float note, float t) {\n    float i = t * uSampleRate;\n    float env = exp(-t * 28.);\n    float v = .5 * env * (.7 * noise2(i) + .38 * sin(45. * i));\n    return vec2(v);\n}\n\nvec2 hihat1(float note, float time) {\n    float amp = exp(-50. * time);\n    return amp * noise(time * 100.).xy;\n}\n\nvec2 hihat2(float note, float time) {\n    float amp = exp(-70. * time);\n    return amp * noise(time * 300.).xy;\n}\n\nvec2 snare(float note, float t) {\n    float i = t * uSampleRate;\n    float env = exp(-t * 17.);\n    float v = .3 * env * (2.3 * noise2(i) + .5 * sin(30. * i));\n    return vec2(v);\n}\n\nvec2 snareFill(float note, float t) {\n    float i = t * uSampleRate;\n    float env = exp(-t * 30.);\n    float v = .2 * env * (2.3 * noise2(i) + .5 * sin(30. * i));\n    return vec2(v);\n}\n\nvec2 crash1(float note, float time) {\n    float aa = 15.;\n    time = sqrt(time * aa) / aa;\n    float amp = exp(max(time - .15, 0.) * -5.);\n    float v = nse(quan(mod(time, .6), .0001));\n    v = dist(v, .1) * amp;\n    return vec2(dist(v * amp, 2.));\n}\n\n#define NSPC 256\n\nvec2 dist(vec2 s, float d) { return clamp(s * d, -1.0, 1.0); }\n\nfloat _filter(float h, float cut) {\n    cut -= 20.0;\n    float df = max(h - cut, 0.0), df2 = abs(h - cut);\n    return exp(-0.005 * df * df) * 0.5 + exp(df2 * df2 * -0.1) * 2.2;\n}\n\nvec2 attackbass(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.15;\n    float amp = smoothstep(0.1, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.1;\n\n    float base = f;\n    float flt = exp(t * -1.5) * 30.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));  \n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;  \n\n    \n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 leadsub(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.1;\n    float amp = smoothstep(0.2, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.03;\n\n    float base = f;\n    float flt = exp(t * -3.5) * 20.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 leadsub2(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.1;\n    float amp = smoothstep(0.2, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.05;\n\n    float base = f;\n    float flt = exp(t * -2.5) * 20.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 4.0 / h;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-3.0 * max(1.9 - h, 0.0));\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 synth(float note, float t) {\n    vec2 v = vec2(0.0);\n    float dr = 0.15;\n    float amp = smoothstep(0.1, 0.0, abs(t - dr - 0.1) - dr) * exp(t * 0.2);\n    float f = noteToFreq(note);\n    float sqr = 0.1;\n\n    float base = f;\n    float flt = exp(t * -1.5) * 30.0;\n    for (int i = 0; i < NSPC; i++) {\n        float h = float(i + 1);\n        float inten = 2.0 / h;\n\n        inten = mix(inten, inten * mod(h, 2.0), sqr);\n\n        inten *= exp(-2.0 * max(2.0 - h, 0.0));\n\n        inten *= _filter(h, flt);\n\n        v.x += inten * sin((TAU + 0.01) * (t * base * h));\n        v.y += inten * sin(TAU * (t * base * h));\n    }\n\n    float o = v.x * amp;\n\n    return vec2(dist(v * amp, 2.0));\n}\n\nvec2 bass(float note, float time) {\n    float freq = noteToFreq(note);\n    return vec2(square(freq * time) + sine(freq * time)) / 1.5;\n}\n\nvec2 pad(float note, float time) {\n    float freq = noteToFreq(note);\n    float vib = .2 * sine(3. * time);\n    return vec2(\n    saw(1., freq * .99 * time + vib),\n    saw(1., freq * 1.01 * time + vib)\n    );\n}\n\nvec2 arp(float note, float time) {\n    float freq = noteToFreq(note);\n    float fmamp = .1 * exp(-50. * time);\n    float fm = fmamp * sine(time * freq * 7.);\n    \n    float amp = exp(-20. * time);\n    return amp * vec2(\n    sine(freq * .99 * time + fm),\n    sine(freq * 1.01 * time + fm)\n    );\n}\n\n#define msin(x,m) sin(TAU*(x)+(m))\n\nfloat cps(float notenumber)\n{\n    \n    return 440.*exp2((notenumber-69.)/12.);\n}\n\nvec2 epiano(float note, float t)\n{\n    float nuance = 1.;\n\n    float freq = cps(note);\n\n    \n    \n    \n    vec2 f0 = vec2(freq*0.998, freq*1.002);\n\n    \n    \n    \n    vec2 glass = msin((f0+3.)*t, msin(14.*f0*t,0.) * exp(-30.*t) * nuance) * exp(-4.*t)  * nuance;\n    glass = sin(glass); \n\n    \n    \n    vec2 body = msin(f0*t, msin(f0*t,0.) * exp(-0.5*t) * nuance * pow(440./f0.x, 0.5)) * exp(-t) * nuance;\n\n    \n    float panDir = clamp(log2(freq/400.)/2., -1., 1.); \n    vec2 pan = normalize(vec2(0.5-0.5*panDir, 0.5+0.5*panDir));\n    return (glass*pan + body) * 0.05 * smoothstep(0.,0.001,t);\n}\n\n#define SEQUENCER(rawBeat, time, beatTempo, totalBeatCount, notes, noteCount, toneFunc) \\\n    float tempoScale = beatTempo / 4.; /* 4 */ \\\n    float fLocalBeatIndex = mod(rawBeat * tempoScale, float(totalBeatCount)); /*  */ \\\n    int accRawBeatPrevLength = 0; \\\n    int accRawBeatLength = 0; \\\n    int targetNoteIndex = -1; \\\n    for(int i = 0; i < noteCount; i++) { \\\n        if(i == 0) { \\\n            int rawNoteLength = notes[i * 2 + 1]; /* notes[1] */ \\\n            if(0. < fLocalBeatIndex && fLocalBeatIndex < float(rawNoteLength)) { \\\n                targetNoteIndex = 0; \\\n                accRawBeatLength += rawNoteLength; \\\n                break; \\\n            } \\\n            accRawBeatLength += rawNoteLength; \\\n        } else { \\\n            int rawNoteLength = notes[(i - 1) * 2 + 1]; \\\n            int nextRawNoteNumber = notes[i * 2]; \\\n            int nextRawNoteLength = notes[i * 2 + 1]; \\\n            if( \\\n                float(accRawBeatLength) < fLocalBeatIndex \\\n                && fLocalBeatIndex < (float(accRawBeatLength) + float(nextRawNoteLength)) \\\n            ) { \\\n                targetNoteIndex = i; \\\n                accRawBeatPrevLength = accRawBeatLength; \\\n                accRawBeatLength += nextRawNoteLength; \\\n                break; \\\n            } \\\n            accRawBeatPrevLength = accRawBeatLength; \\\n            accRawBeatLength += nextRawNoteLength; \\\n        } \\\n    } \\\n    int currentNoteNumber = notes[targetNoteIndex * 2]; \\\n    int currentNoteLength = notes[targetNoteIndex * 2 + 1]; \\\n    int[4] noteNumbers = int[4]( \\\n        (int(currentNoteNumber) & 255), \\\n        ((int(currentNoteNumber) >> 8) & 255), \\\n        ((int(currentNoteNumber) >> 16) & 255), \\\n        ((int(currentNoteNumber) >> 24) & 255) \\\n    ); \\\n    /* TODO: -1 .  */ \\\n    if(targetNoteIndex == -1) { \\\n        return vec2(0.); \\\n    } \\\n    float fLocalBeatIndexInNote = fLocalBeatIndex - float(accRawBeatPrevLength); \\\n    float localTime = beatToTime(mod(fLocalBeatIndexInNote, float(currentNoteLength)) / tempoScale); \\\n    /* fallback */ \\\n    float fallbackAmp = 1. - smoothstep(.90, .99, fLocalBeatIndexInNote / float(currentNoteLength)); \\\n    fallbackAmp = 1.; /* fallback */\\\n    vec2 res = vec2(0.); \\\n    float acc = 0.; \\\n    for(int i = 0; i < 4; i++) { \\\n        float fNoteNumber = float(noteNumbers[i]); \\\n        float isNoteOn = (fNoteNumber > 0. ? 1. : 0.); \\\n        res += vec2(toneFunc(fNoteNumber, localTime)) * isNoteOn * fallbackAmp; \\\n        acc += isNoteOn; \\\n    } \\\n    float gainAcc = 1.5; /* .  */ \\\n    res /= max(1., acc - gainAcc); \\\n\nvec2 epianoSeqBase(float rawBeat, float time) {\n    \n    \n    \n    \n    \n    \n\n    int[] notes = int[](\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n\n    \n    \n    \n\n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    G3(3), E3(3), A3(3), G3(5), O(2)\n    );\n\n    \n    \n\n    \n    \n\n    \n    \n\n    \n    \n\n    \n    SEQUENCER(rawBeat, time, T8, 16., notes, 5, epiano)\n\nreturn res * 3.;\n}\n\nvec2 epianoHarmonySeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    Am3(4), Am3(4),\n    Em3(4), Em3(4),\n    CM4(4), CM4(4),\n    Bm3(4), Bm3(4)\n    );\n\n    \n    SEQUENCER(rawBeat, time, T8, 32., notes, 8, epiano);\n\nreturn res * 3.;\n}\nvec2 epianoMelodyMainSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    G4(3), E3(3), A3(3), G3(5), O(2),\n    G3(3), E3(3), A3(3), G3(5), O(2),\n    G3(3), E3(3), B3(3), A3(3), B3(2), D4(1),\n    C4(3), B3(3), G3(5), O(5)\n    );\n    SEQUENCER(rawBeat, time, T8, 64., notes, 20, epiano);\nreturn res * 1.;\n}\n\nvec2 arpSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    E4(2), G4(2), A4(2), G4(2)\n    );\n    SEQUENCER(rawBeat, time, T8, 8., notes, 4, arp);\nfloat volume = .5;\nreturn res * volume;\n}\n\nvec2 kickSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), O(1), S(1), O(1),\n    S(1), S(1), S(1), O(1),\n    S(1), O(1), S(1), O(1),\n    S(1), S(1), S(1), O(1)\n    );\n    SEQUENCER(rawBeat, time, T8, 16., notes, 16, kick);\nreturn res * .5;\n}\n\nvec2 bassSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    \n    E4(3), E4(1), O(1), G4(2), O(1),\n    E4(3), E4(1), O(1), B4(2), O(1),\n    E4(3), E4(1), O(1), G4(2), O(1),\n    E4(3), B4(2), G4(2), O(1)\n    );\n    \n    SEQUENCER(rawBeat, time, T8, 32., notes, 19, bass)\nreturn vec2(res) * .1;\n}\n\nvec2 snareSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), S(1), S(1), S(1),\n    S(1), S(1), S(1), S(1)\n    );\n    SEQUENCER(rawBeat, time, T4, 8., notes, 8, snare)\nfloat volume = .2;\nreturn vec2(res) * volume;\n}\n\nvec2 snareFillSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), S(1), S(1), S(1),\n    S(1), S(1), S(1), S(1)\n    );\n    SEQUENCER(rawBeat, time, T4, 8., notes, 8, snareFill)\nfloat volume = .5;\nreturn vec2(res) * volume;\n}\n\nfloat phase(float beat, float inBeat, float outBeat) {\n    return step(inBeat, beat) * (1. - step(outBeat, beat));\n}\n\nvec2 epianoMelodyLoopBaseSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    G4(3), E4(3), A4(3), G4(5), O(2),\n    G4(3), E4(3), A4(3), G4(5), O(2)\n    );\n    SEQUENCER(rawBeat, time, T8, 16., notes, 10, epiano);\nreturn res * 3.;\n}\n\nvec2 epianoHarmonyBaseSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    Am3(4), Am3(4),\n    Em3(4), Em3(4),\n    CM4(4), CM4(4),\n    Bm3(4), Bm3(4)\n    );\n\n    \n    SEQUENCER(rawBeat, time, T8, 32., notes, 8, epiano);\n\nreturn res * 3.;\n}\n\nvec2 baseIntroSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    \n    \n    Am2(2), Am2(2), Am2(2), Am2(2),\n    \n    Em2(2), Em2(2), Em2(2), Em2(2),\n    \n    CM3(2), CM3(2), CM3(2), CM3(2),\n    \n    Bm2(2), Bm2(2), Bm2(2), Bm2(2)\n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    );\n\n    \n    SEQUENCER(rawBeat, time, T8, 32., notes, 16, base)\n\n    \n    \n\n    \n    \n\nreturn vec2(res) * .8;\n}\n\nvec2 snareFillIntroSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), S(1), S(1), S(1),\n    S(1), S(1), S(1), S(1)\n    );\n    SEQUENCER(rawBeat, time, T4, 8., notes, 8, snareFill);\nreturn res * .3;\n}\n\nvec2 snareFillHookSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), O(1), S(1), O(1), S(1), O(1), S(1), O(1),\n    S(1), O(1), S(1), O(1), S(1), O(1), S(1), O(1)\n    );\n    SEQUENCER(rawBeat, time, T16, 16., notes, 16, snareFill);\nreturn res * .1;\n}\n\nvec2 arpBaseLoopSeqBase(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    \n    \n\n    \n    \n    \n    \n    \n    G3(1), G3(1), A3(1), G3(1), G3(1), B3(1), O(2),\n    G3(1), G3(1), A3(1), G3(1), G3(1), B3(1), O(2),\n    E3(1), E3(1), Fsh3(1), E3(1), E3(1), G3(1), O(2),\n    E3(1), E3(1), Fsh3(1), E3(1), E3(1), G3(1), O(2)\n\n    \n    \n    \n    \n    \n    );\n\n    \n    \n\n    \n    SEQUENCER(rawBeat, time, T8, 32., notes, 28, arp);\n\nreturn res * .3;\n}\n\nvec2 hihat1BaseLoopSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    S(1), O(1), S(1), O(1), S(1), O(1), S(1), O(1)\n    );\n    SEQUENCER(rawBeat, time, T8, 8., notes, 8, hihat1);\nreturn res;\n}\n\nvec2 bassBaseLoopSeq(float rawBeat, float time) {\n    int[] notes = int[](\n    \n    Am3(4),\n    Em3(4),\n    CM4(4),\n    Bm3(4)\n\n    \n    \n    \n    \n    \n    );\n    SEQUENCER(rawBeat, time, T2, 16., notes, 4, bass);\nreturn res * .05;\n}\n\nfloat beatToMeasure(float beat) {\n    return beat * .25;\n}\n\nvec2 mainSound(float time) {\n    float beat = timeToBeat(time);\n\n    \n    \n\n    vec2 sound = vec2(0.);\n\n    float measure = beatToMeasure(beat);\n\n    \n\n    if(0. <= measure && measure < 8.) { \n        sound +=\n        0.\n        \n        + baseIntroSeq(beat, time)\n        \n        ;\n    } else if(8. <= measure && measure < 16.) {\n        sound +=\n        0.\n        + bassBaseLoopSeq(beat, time)\n        + baseIntroSeq(beat, time)\n        + epianoMelodyLoopBaseSeq(beat, time)\n        + snareFillIntroSeq(beat, time)\n        + arpBaseLoopSeqBase(beat, time)\n        + hihat1BaseLoopSeq(beat, time)\n        ;\n    } else if(16. <= measure && measure < 24.) {\n        sound +=\n        0.\n        + bassBaseLoopSeq(beat, time)\n        + epianoMelodyLoopBaseSeq(beat, time)\n        + baseIntroSeq(beat, time)\n        + epianoHarmonySeqBase(beat, time)\n        + arpBaseLoopSeqBase(beat, time)\n        + snareFillHookSeq(beat, time)\n        ;\n    } else if(32. <= measure && measure < 40.) {\n    } else if(48. <= measure && measure < 56.) {\n    } else if(56. <= measure && measure < 64.) {\n    } else if(64. <= measure && measure < 72.) {\n    } else if(72. <= measure && measure < 80.) {\n    } else {\n        sound = vec2(0.);\n    }\n\n    return sound;\n\n    return epianoHarmonySeqBase(beat, time);\n    sound +=\n    bassSeqBase(beat, time)\n    + epianoSeqBase(beat, time)\n    + epianoHarmonySeqBase(beat, time)\n    + arpSeqBase(beat, time)\n    + kickSeqBase(beat, time)\n    \n    + snareFillSeqBase(beat, time);\n\n    \n    \n    \n    \n    \n    \n\n    return sound;\n}\n\nvoid main() {\n    float time = uBlockOffset + float(gl_VertexID) / uSampleRate;\n    vSound = mainSound(time);\n}",180),ga.play(240*ra/115)}}),sa.addBorderSpacer(),sa.addToggleDebugger({label:"orbit controls enabled",initialValue:Ma.enabled,onChange:e=>Ma.enabled=e}),sa.addBorderSpacer(),sa.addToggleDebugger({label:"show buffers",initialValue:La.enabled,onChange:e=>{La.enabled=e,e?La.showDom():La.hideDom()}}),sa.addBorderSpacer();const e=sa.addGroup("directional light",!1);e.addToggleDebugger({label:"light enabled",initialValue:Ea.enabled,onChange:e=>Ea.enabled=e}),e.addSliderDebugger({label:"intensity",minValue:0,maxValue:4,stepValue:.001,initialValue:Ea.intensity,onChange:e=>{Ea.intensity=e}}),e.addSliderDebugger({label:"pos x",minValue:-10,maxValue:10,stepValue:.001,initialValue:Ea.transform.position.x,onChange:e=>{Ea.transform.position.x=e}}),e.addSliderDebugger({label:"pos y",minValue:0,maxValue:10,stepValue:.001,initialValue:Ea.transform.position.y,onChange:e=>{Ea.transform.position.y=e}}),e.addSliderDebugger({label:"pos z",minValue:-10,maxValue:10,stepValue:.001,initialValue:Ea.transform.position.z,onChange:e=>{Ea.transform.position.z=e}}),aa(Ra,"spot light 1"),aa(Aa,"spot light 2"),sa.addBorderSpacer();const t=sa.addGroup("ssao",!1);t.addToggleDebugger({label:"ssao pass enabled",initialValue:Ca.ambientOcclusionPass.enabled,onChange:e=>Ca.ambientOcclusionPass.enabled=e}),t.addSliderDebugger({label:"ssao occlusion sample length",minValue:.01,maxValue:1,stepValue:.001,initialValue:Ca.ambientOcclusionPass.occlusionSampleLength,onChange:e=>{Ca.ambientOcclusionPass.occlusionSampleLength=e}}),t.addSliderDebugger({label:"ssao occlusion bias",minValue:1e-4,maxValue:.01,stepValue:1e-4,initialValue:Ca.ambientOcclusionPass.occlusionBias,onChange:e=>{Ca.ambientOcclusionPass.occlusionBias=e}}),t.addSliderDebugger({label:"ssao min distance",minValue:0,maxValue:.1,stepValue:.001,initialValue:Ca.ambientOcclusionPass.occlusionMinDistance,onChange:e=>{Ca.ambientOcclusionPass.occlusionMinDistance=e}}),t.addSliderDebugger({label:"ssao max distance",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.ambientOcclusionPass.occlusionMaxDistance,onChange:e=>{Ca.ambientOcclusionPass.occlusionMaxDistance=e}}),t.addColorDebugger({label:"ssao color",initialValue:Ca.ambientOcclusionPass.occlusionColor.getHexCoord(),onChange:e=>{Ca.ambientOcclusionPass.occlusionColor=Ut.fromHex(e)}}),t.addSliderDebugger({label:"ssao occlusion power",minValue:.5,maxValue:4,stepValue:.01,initialValue:Ca.ambientOcclusionPass.occlusionPower,onChange:e=>{Ca.ambientOcclusionPass.occlusionPower=e}}),t.addSliderDebugger({label:"ssao occlusion strength",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.ambientOcclusionPass.occlusionStrength,onChange:e=>{Ca.ambientOcclusionPass.occlusionStrength=e}}),t.addSliderDebugger({label:"ssao blend rate",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.ambientOcclusionPass.blendRate,onChange:e=>{Ca.ambientOcclusionPass.blendRate=e}}),sa.addBorderSpacer();const n=sa.addGroup("light shaft",!1);n.addToggleDebugger({label:"light shaft pass enabled",initialValue:Ca.lightShaftPass.enabled,onChange:e=>Ca.lightShaftPass.enabled=e}),n.addSliderDebugger({label:"blend rate",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.lightShaftPass.blendRate,onChange:e=>{Ca.lightShaftPass.blendRate=e}}),n.addSliderDebugger({label:"pass scale",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.lightShaftPass.passScaleBase,onChange:e=>{Ca.lightShaftPass.passScaleBase=e}}),n.addSliderDebugger({label:"ray step strength",minValue:.001,maxValue:.05,stepValue:.001,initialValue:Ca.lightShaftPass.rayStepStrength,onChange:e=>{Ca.lightShaftPass.rayStepStrength=e}}),sa.addBorderSpacer();const r=sa.addGroup("volumetric light",!1);r.addSliderDebugger({label:"ray step",initialValue:Ca.volumetricLightPass.rayStep,minValue:.001,maxValue:1,stepValue:.001,onChange:e=>{Ca.volumetricLightPass.rayStep=e}}),r.addSliderDebugger({label:"density multiplier",initialValue:Ca.volumetricLightPass.densityMultiplier,minValue:.001,maxValue:10,stepValue:.001,onChange:e=>{Ca.volumetricLightPass.densityMultiplier=e}}),r.addSliderDebugger({label:"jitter size x",initialValue:Ca.volumetricLightPass.rayJitterSizeX,minValue:0,maxValue:1,stepValue:.001,onChange:e=>{Ca.volumetricLightPass.rayJitterSizeX=e}}),r.addSliderDebugger({label:"jitter size y",initialValue:Ca.volumetricLightPass.rayJitterSizeY,minValue:0,maxValue:1,stepValue:.001,onChange:e=>{Ca.volumetricLightPass.rayJitterSizeY=e}}),r.addSliderDebugger({label:"blend rate",initialValue:Ca.volumetricLightPass.blendRate,minValue:0,maxValue:1,stepValue:.001,onChange:e=>{Ca.volumetricLightPass.blendRate=e}}),sa.addBorderSpacer();const a=sa.addGroup("fog",!1);a.addColorDebugger({label:"fog color",initialValue:Ca.fogPass.fogColor.getHexCoord(),onChange:e=>{Ca.fogPass.fogColor=Ut.fromHex(e)}}),a.addSliderDebugger({label:"density",minValue:0,maxValue:1,stepValue:1e-4,initialValue:Ca.fogPass.fogDensity,onChange:e=>{Ca.fogPass.fogDensity=e}}),a.addSliderDebugger({label:"attenuation",minValue:0,maxValue:1,stepValue:1e-4,initialValue:Ca.fogPass.fogDensityAttenuation,onChange:e=>{Ca.fogPass.fogDensityAttenuation=e}}),a.addSliderDebugger({label:"distance fog start",minValue:0,maxValue:Ba.far,stepValue:.01,initialValue:Ca.fogPass.distanceFogStart,onChange:e=>{Ca.fogPass.distanceFogStart=e}}),a.addSliderDebugger({label:"distance fog power",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.fogPass.distanceFogPower,onChange:e=>{Ca.fogPass.distanceFogPower=e}}),sa.addBorderSpacer();const i=sa.addGroup("depth of field",!1);i.addToggleDebugger({label:"DoF pass enabled",initialValue:Ca.depthOfFieldPass.enabled,onChange:e=>Ca.depthOfFieldPass.enabled=e}),i.addSliderDebugger({label:"DoF focus distance",minValue:.1,maxValue:100,stepValue:.001,initialValue:Ca.depthOfFieldPass.focusDistance,onChange:e=>{Ca.depthOfFieldPass.focusDistance=e}}),i.addSliderDebugger({label:"DoF focus range",minValue:.1,maxValue:30,stepValue:.001,initialValue:Ca.depthOfFieldPass.focusRange,onChange:e=>{Ca.depthOfFieldPass.focusRange=e}}),i.addSliderDebugger({label:"DoF bokeh radius",minValue:.01,maxValue:10,stepValue:.001,initialValue:Ca.depthOfFieldPass.bokehRadius,onChange:e=>{Ca.depthOfFieldPass.bokehRadius=e}}),sa.addBorderSpacer();const o=sa.addGroup("bloom",!1);o.addToggleDebugger({label:"Bloom pass enabled",initialValue:Ca.bloomPass.enabled,onChange:e=>Ca.bloomPass.enabled=e}),o.addSliderDebugger({label:"bloom amount",minValue:0,maxValue:4,stepValue:.001,initialValue:Ca.bloomPass.bloomAmount,onChange:e=>{Ca.bloomPass.bloomAmount=e}}),o.addSliderDebugger({label:"bloom threshold",minValue:0,maxValue:5,stepValue:.001,initialValue:Ca.bloomPass.threshold,onChange:e=>{Ca.bloomPass.threshold=e}}),o.addSliderDebugger({label:"bloom tone",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.bloomPass.tone,onChange:e=>{Ca.bloomPass.tone=e}}),sa.addBorderSpacer();const s=sa.addGroup("streak",!1);s.addSliderDebugger({label:"threshold",minValue:0,maxValue:4,stepValue:.001,initialValue:Ca.streakPass.threshold,onChange:e=>{Ca.streakPass.threshold=e}}),s.addSliderDebugger({label:"vertical scale",minValue:0,maxValue:10,stepValue:.001,initialValue:Ca.streakPass.verticalScale,onChange:e=>{Ca.streakPass.verticalScale=e}}),s.addSliderDebugger({label:"horizontal scale",minValue:0,maxValue:2,stepValue:.001,initialValue:Ca.streakPass.horizontalScale,onChange:e=>{Ca.streakPass.horizontalScale=e}}),s.addSliderDebugger({label:"stretch",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.streakPass.stretch,onChange:e=>{Ca.streakPass.stretch=e}}),s.addColorDebugger({label:"color",initialValue:Ca.streakPass.color.getHexCoord(),onChange:e=>{Ca.streakPass.color=Ut.fromHex(e)}}),s.addSliderDebugger({label:"intensity",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.streakPass.intensity,onChange:e=>{Ca.streakPass.intensity=e}}),sa.addBorderSpacer();const l=sa.addGroup("ssr",!1);l.addToggleDebugger({label:"ssr pass enabled",initialValue:Ca.ssrPass.enabled,onChange:e=>Ca.ssrPass.enabled=e}),l.addSliderDebugger({label:"depth bias",minValue:.001,maxValue:.1,stepValue:.001,initialValue:Ca.ssrPass.rayDepthBias,onChange:e=>{Ca.ssrPass.rayDepthBias=e}}),l.addSliderDebugger({label:"ray nearest distance",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.rayNearestDistance,onChange:e=>{Ca.ssrPass.rayNearestDistance=e}}),l.addSliderDebugger({label:"ray max distance",minValue:.001,maxValue:10,stepValue:.001,initialValue:Ca.ssrPass.rayMaxDistance,onChange:e=>{Ca.ssrPass.rayMaxDistance=e}}),l.addSliderDebugger({label:"ray thickness",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.reflectionRayThickness,onChange:e=>{Ca.ssrPass.reflectionRayThickness=e}}),l.addSliderDebugger({label:"jitter size x",minValue:.001,maxValue:.1,stepValue:.001,initialValue:Ca.ssrPass.reflectionRayJitterSizeX,onChange:e=>{Ca.ssrPass.reflectionRayJitterSizeX=e}}),l.addSliderDebugger({label:"jitter size y",minValue:.001,maxValue:.1,stepValue:.001,initialValue:Ca.ssrPass.reflectionRayJitterSizeY,onChange:e=>{Ca.ssrPass.reflectionRayJitterSizeY=e}}),l.addSliderDebugger({label:"roughness power",minValue:0,maxValue:5,stepValue:.01,initialValue:Ca.ssrPass.reflectionRoughnessPower,onChange:e=>{Ca.ssrPass.reflectionRoughnessPower=e}}),l.addSliderDebugger({label:"fade min distance",minValue:.001,maxValue:10,stepValue:.001,initialValue:Ca.ssrPass.reflectionFadeMinDistance,onChange:e=>{Ca.ssrPass.reflectionFadeMinDistance=e}}),l.addSliderDebugger({label:"fade max distance",minValue:.001,maxValue:10,stepValue:.001,initialValue:Ca.ssrPass.reflectionFadeMaxDistance,onChange:e=>{Ca.ssrPass.reflectionFadeMaxDistance=e}}),l.addSliderDebugger({label:"edge fade factor min x",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.reflectionScreenEdgeFadeFactorMinX,onChange:e=>{Ca.ssrPass.reflectionScreenEdgeFadeFactorMinX=e}}),l.addSliderDebugger({label:"edge fade factor max x",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.reflectionScreenEdgeFadeFactorMaxX,onChange:e=>{Ca.ssrPass.reflectionScreenEdgeFadeFactorMaxX=e}}),l.addSliderDebugger({label:"edge fade factor min y",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.reflectionScreenEdgeFadeFactorMinY,onChange:e=>{Ca.ssrPass.reflectionScreenEdgeFadeFactorMinY=e}}),l.addSliderDebugger({label:"edge fade factor max y",minValue:.001,maxValue:1,stepValue:.001,initialValue:Ca.ssrPass.reflectionScreenEdgeFadeFactorMaxY,onChange:e=>{Ca.ssrPass.reflectionScreenEdgeFadeFactorMaxY=e}}),l.addSliderDebugger({label:"additional rate",minValue:.01,maxValue:1,stepValue:.01,initialValue:Ca.ssrPass.reflectionAdditionalRate,onChange:e=>{Ca.ssrPass.reflectionAdditionalRate=e}}),sa.addBorderSpacer();sa.addGroup("chromatic aberration",!1).addSliderDebugger({label:"scale",minValue:0,maxValue:.1,stepValue:.001,initialValue:Ca.chromaticAberrationPass.chromaticAberrationScale,onChange:e=>Ca.chromaticAberrationPass.chromaticAberrationScale=e}),sa.addBorderSpacer();const u=sa.addGroup("vignette",!1);u.addSliderDebugger({label:"radius",minValue:0,maxValue:3,stepValue:.001,initialValue:Ca.vignettePass.vignetteRadius,onChange:e=>Ca.vignettePass.vignetteRadius=e}),u.addSliderDebugger({label:"power",minValue:.01,maxValue:8,stepValue:.001,initialValue:Ca.vignettePass.vignettePower,onChange:e=>Ca.vignettePass.vignettePower=e}),u.addSliderDebugger({label:"blend rate",minValue:0,maxValue:1,stepValue:.001,initialValue:Ca.vignettePass.blendRate,onChange:e=>Ca.vignettePass.blendRate=e}),sa.addBorderSpacer();sa.addGroup("fxaa",!1).addToggleDebugger({label:"fxaa pass enabled",initialValue:Va.enabled,onChange:e=>Va.enabled=e}),Ta.appendChild(sa.domElement)}(),xa.update()},Da.onBeforeFixedUpdate=()=>{},Da.onRender=e=>{Ca.render(ya,Ba,{time:e})};const u=e=>{Da.run(e),requestAnimationFrame(u)};Da.start(),requestAnimationFrame(u)})();
